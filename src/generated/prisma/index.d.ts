
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Test
 * 
 */
export type Test = $Result.DefaultSelection<Prisma.$TestPayload>
/**
 * Model TestAssignment
 * 
 */
export type TestAssignment = $Result.DefaultSelection<Prisma.$TestAssignmentPayload>
/**
 * Model Sample
 * 
 */
export type Sample = $Result.DefaultSelection<Prisma.$SamplePayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model QueueNumber
 * 
 */
export type QueueNumber = $Result.DefaultSelection<Prisma.$QueueNumberPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model PurchaseInvoice
 * 
 */
export type PurchaseInvoice = $Result.DefaultSelection<Prisma.$PurchaseInvoicePayload>
/**
 * Model PurchaseInvoiceItem
 * 
 */
export type PurchaseInvoiceItem = $Result.DefaultSelection<Prisma.$PurchaseInvoiceItemPayload>
/**
 * Model RadiationResult
 * 
 */
export type RadiationResult = $Result.DefaultSelection<Prisma.$RadiationResultPayload>
/**
 * Model LabMaterial
 * 
 */
export type LabMaterial = $Result.DefaultSelection<Prisma.$LabMaterialPayload>
/**
 * Model MaterialTransaction
 * 
 */
export type MaterialTransaction = $Result.DefaultSelection<Prisma.$MaterialTransactionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  RECEPTIONIST: 'RECEPTIONIST',
  LAB_TECHNICIAN: 'LAB_TECHNICIAN',
  ACCOUNTANT: 'ACCOUNTANT',
  PENDING: 'PENDING'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const TestStatus: {
  PENDING: 'PENDING',
  SAMPLE_COLLECTED: 'SAMPLE_COLLECTED',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TestStatus = (typeof TestStatus)[keyof typeof TestStatus]


export const QueueStatus: {
  WAITING: 'WAITING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type QueueStatus = (typeof QueueStatus)[keyof typeof QueueStatus]


export const ReportType: {
  PATIENT: 'PATIENT',
  TEST: 'TEST',
  FINANCIAL: 'FINANCIAL',
  SAMPLE: 'SAMPLE',
  SUMMARY: 'SUMMARY'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]


export const TransactionType: {
  ADD: 'ADD',
  REDUCE: 'REDUCE',
  ADJUST: 'ADJUST',
  EXPIRED: 'EXPIRED',
  DAMAGED: 'DAMAGED'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const MaterialCategory: {
  REAGENT: 'REAGENT',
  CONSUMABLE: 'CONSUMABLE',
  EQUIPMENT: 'EQUIPMENT',
  GLASSWARE: 'GLASSWARE',
  CHEMICAL: 'CHEMICAL',
  OTHER: 'OTHER'
};

export type MaterialCategory = (typeof MaterialCategory)[keyof typeof MaterialCategory]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type TestStatus = $Enums.TestStatus

export const TestStatus: typeof $Enums.TestStatus

export type QueueStatus = $Enums.QueueStatus

export const QueueStatus: typeof $Enums.QueueStatus

export type ReportType = $Enums.ReportType

export const ReportType: typeof $Enums.ReportType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type MaterialCategory = $Enums.MaterialCategory

export const MaterialCategory: typeof $Enums.MaterialCategory

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test`: Exposes CRUD operations for the **Test** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tests
    * const tests = await prisma.test.findMany()
    * ```
    */
  get test(): Prisma.TestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testAssignment`: Exposes CRUD operations for the **TestAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestAssignments
    * const testAssignments = await prisma.testAssignment.findMany()
    * ```
    */
  get testAssignment(): Prisma.TestAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sample`: Exposes CRUD operations for the **Sample** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Samples
    * const samples = await prisma.sample.findMany()
    * ```
    */
  get sample(): Prisma.SampleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queueNumber`: Exposes CRUD operations for the **QueueNumber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QueueNumbers
    * const queueNumbers = await prisma.queueNumber.findMany()
    * ```
    */
  get queueNumber(): Prisma.QueueNumberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseInvoice`: Exposes CRUD operations for the **PurchaseInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseInvoices
    * const purchaseInvoices = await prisma.purchaseInvoice.findMany()
    * ```
    */
  get purchaseInvoice(): Prisma.PurchaseInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseInvoiceItem`: Exposes CRUD operations for the **PurchaseInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseInvoiceItems
    * const purchaseInvoiceItems = await prisma.purchaseInvoiceItem.findMany()
    * ```
    */
  get purchaseInvoiceItem(): Prisma.PurchaseInvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.radiationResult`: Exposes CRUD operations for the **RadiationResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RadiationResults
    * const radiationResults = await prisma.radiationResult.findMany()
    * ```
    */
  get radiationResult(): Prisma.RadiationResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labMaterial`: Exposes CRUD operations for the **LabMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabMaterials
    * const labMaterials = await prisma.labMaterial.findMany()
    * ```
    */
  get labMaterial(): Prisma.LabMaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materialTransaction`: Exposes CRUD operations for the **MaterialTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialTransactions
    * const materialTransactions = await prisma.materialTransaction.findMany()
    * ```
    */
  get materialTransaction(): Prisma.MaterialTransactionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Patient: 'Patient',
    Test: 'Test',
    TestAssignment: 'TestAssignment',
    Sample: 'Sample',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    QueueNumber: 'QueueNumber',
    Report: 'Report',
    PurchaseInvoice: 'PurchaseInvoice',
    PurchaseInvoiceItem: 'PurchaseInvoiceItem',
    RadiationResult: 'RadiationResult',
    LabMaterial: 'LabMaterial',
    MaterialTransaction: 'MaterialTransaction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "patient" | "test" | "testAssignment" | "sample" | "invoice" | "invoiceItem" | "queueNumber" | "report" | "purchaseInvoice" | "purchaseInvoiceItem" | "radiationResult" | "labMaterial" | "materialTransaction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Test: {
        payload: Prisma.$TestPayload<ExtArgs>
        fields: Prisma.TestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findFirst: {
            args: Prisma.TestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findMany: {
            args: Prisma.TestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>[]
          }
          create: {
            args: Prisma.TestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          createMany: {
            args: Prisma.TestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          update: {
            args: Prisma.TestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          deleteMany: {
            args: Prisma.TestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          aggregate: {
            args: Prisma.TestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest>
          }
          groupBy: {
            args: Prisma.TestGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestCountArgs<ExtArgs>
            result: $Utils.Optional<TestCountAggregateOutputType> | number
          }
        }
      }
      TestAssignment: {
        payload: Prisma.$TestAssignmentPayload<ExtArgs>
        fields: Prisma.TestAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAssignmentPayload>
          }
          findFirst: {
            args: Prisma.TestAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAssignmentPayload>
          }
          findMany: {
            args: Prisma.TestAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAssignmentPayload>[]
          }
          create: {
            args: Prisma.TestAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAssignmentPayload>
          }
          createMany: {
            args: Prisma.TestAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TestAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAssignmentPayload>
          }
          update: {
            args: Prisma.TestAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.TestAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAssignmentPayload>
          }
          aggregate: {
            args: Prisma.TestAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestAssignment>
          }
          groupBy: {
            args: Prisma.TestAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<TestAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Sample: {
        payload: Prisma.$SamplePayload<ExtArgs>
        fields: Prisma.SampleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SampleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SampleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>
          }
          findFirst: {
            args: Prisma.SampleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SampleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>
          }
          findMany: {
            args: Prisma.SampleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>[]
          }
          create: {
            args: Prisma.SampleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>
          }
          createMany: {
            args: Prisma.SampleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SampleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>
          }
          update: {
            args: Prisma.SampleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>
          }
          deleteMany: {
            args: Prisma.SampleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SampleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SampleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>
          }
          aggregate: {
            args: Prisma.SampleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSample>
          }
          groupBy: {
            args: Prisma.SampleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SampleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SampleCountArgs<ExtArgs>
            result: $Utils.Optional<SampleCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      QueueNumber: {
        payload: Prisma.$QueueNumberPayload<ExtArgs>
        fields: Prisma.QueueNumberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueueNumberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueNumberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueueNumberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueNumberPayload>
          }
          findFirst: {
            args: Prisma.QueueNumberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueNumberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueueNumberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueNumberPayload>
          }
          findMany: {
            args: Prisma.QueueNumberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueNumberPayload>[]
          }
          create: {
            args: Prisma.QueueNumberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueNumberPayload>
          }
          createMany: {
            args: Prisma.QueueNumberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QueueNumberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueNumberPayload>
          }
          update: {
            args: Prisma.QueueNumberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueNumberPayload>
          }
          deleteMany: {
            args: Prisma.QueueNumberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueueNumberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QueueNumberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueNumberPayload>
          }
          aggregate: {
            args: Prisma.QueueNumberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueueNumber>
          }
          groupBy: {
            args: Prisma.QueueNumberGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueueNumberGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueueNumberCountArgs<ExtArgs>
            result: $Utils.Optional<QueueNumberCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      PurchaseInvoice: {
        payload: Prisma.$PurchaseInvoicePayload<ExtArgs>
        fields: Prisma.PurchaseInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          findFirst: {
            args: Prisma.PurchaseInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          findMany: {
            args: Prisma.PurchaseInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>[]
          }
          create: {
            args: Prisma.PurchaseInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          createMany: {
            args: Prisma.PurchaseInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          update: {
            args: Prisma.PurchaseInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          aggregate: {
            args: Prisma.PurchaseInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseInvoice>
          }
          groupBy: {
            args: Prisma.PurchaseInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceCountAggregateOutputType> | number
          }
        }
      }
      PurchaseInvoiceItem: {
        payload: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>
        fields: Prisma.PurchaseInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          update: {
            args: Prisma.PurchaseInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseInvoiceItem>
          }
          groupBy: {
            args: Prisma.PurchaseInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      RadiationResult: {
        payload: Prisma.$RadiationResultPayload<ExtArgs>
        fields: Prisma.RadiationResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RadiationResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RadiationResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationResultPayload>
          }
          findFirst: {
            args: Prisma.RadiationResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RadiationResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationResultPayload>
          }
          findMany: {
            args: Prisma.RadiationResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationResultPayload>[]
          }
          create: {
            args: Prisma.RadiationResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationResultPayload>
          }
          createMany: {
            args: Prisma.RadiationResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RadiationResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationResultPayload>
          }
          update: {
            args: Prisma.RadiationResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationResultPayload>
          }
          deleteMany: {
            args: Prisma.RadiationResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RadiationResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RadiationResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationResultPayload>
          }
          aggregate: {
            args: Prisma.RadiationResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRadiationResult>
          }
          groupBy: {
            args: Prisma.RadiationResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<RadiationResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.RadiationResultCountArgs<ExtArgs>
            result: $Utils.Optional<RadiationResultCountAggregateOutputType> | number
          }
        }
      }
      LabMaterial: {
        payload: Prisma.$LabMaterialPayload<ExtArgs>
        fields: Prisma.LabMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabMaterialPayload>
          }
          findFirst: {
            args: Prisma.LabMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabMaterialPayload>
          }
          findMany: {
            args: Prisma.LabMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabMaterialPayload>[]
          }
          create: {
            args: Prisma.LabMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabMaterialPayload>
          }
          createMany: {
            args: Prisma.LabMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LabMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabMaterialPayload>
          }
          update: {
            args: Prisma.LabMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabMaterialPayload>
          }
          deleteMany: {
            args: Prisma.LabMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LabMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabMaterialPayload>
          }
          aggregate: {
            args: Prisma.LabMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabMaterial>
          }
          groupBy: {
            args: Prisma.LabMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<LabMaterialCountAggregateOutputType> | number
          }
        }
      }
      MaterialTransaction: {
        payload: Prisma.$MaterialTransactionPayload<ExtArgs>
        fields: Prisma.MaterialTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialTransactionPayload>
          }
          findFirst: {
            args: Prisma.MaterialTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialTransactionPayload>
          }
          findMany: {
            args: Prisma.MaterialTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialTransactionPayload>[]
          }
          create: {
            args: Prisma.MaterialTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialTransactionPayload>
          }
          createMany: {
            args: Prisma.MaterialTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaterialTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialTransactionPayload>
          }
          update: {
            args: Prisma.MaterialTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialTransactionPayload>
          }
          deleteMany: {
            args: Prisma.MaterialTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialTransactionPayload>
          }
          aggregate: {
            args: Prisma.MaterialTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialTransaction>
          }
          groupBy: {
            args: Prisma.MaterialTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialTransactionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    patient?: PatientOmit
    test?: TestOmit
    testAssignment?: TestAssignmentOmit
    sample?: SampleOmit
    invoice?: InvoiceOmit
    invoiceItem?: InvoiceItemOmit
    queueNumber?: QueueNumberOmit
    report?: ReportOmit
    purchaseInvoice?: PurchaseInvoiceOmit
    purchaseInvoiceItem?: PurchaseInvoiceItemOmit
    radiationResult?: RadiationResultOmit
    labMaterial?: LabMaterialOmit
    materialTransaction?: MaterialTransactionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    invoices: number
    patients: number
    purchaseInvoices: number
    radiationResults: number
    reports: number
    samples: number
    testAssignments: number
    materialTransactions: number
    labMaterials: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    patients?: boolean | UserCountOutputTypeCountPatientsArgs
    purchaseInvoices?: boolean | UserCountOutputTypeCountPurchaseInvoicesArgs
    radiationResults?: boolean | UserCountOutputTypeCountRadiationResultsArgs
    reports?: boolean | UserCountOutputTypeCountReportsArgs
    samples?: boolean | UserCountOutputTypeCountSamplesArgs
    testAssignments?: boolean | UserCountOutputTypeCountTestAssignmentsArgs
    materialTransactions?: boolean | UserCountOutputTypeCountMaterialTransactionsArgs
    labMaterials?: boolean | UserCountOutputTypeCountLabMaterialsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchaseInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRadiationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiationResultWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMaterialTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLabMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabMaterialWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    invoices: number
    queueNumbers: number
    radiationResults: number
    testAssignments: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | PatientCountOutputTypeCountInvoicesArgs
    queueNumbers?: boolean | PatientCountOutputTypeCountQueueNumbersArgs
    radiationResults?: boolean | PatientCountOutputTypeCountRadiationResultsArgs
    testAssignments?: boolean | PatientCountOutputTypeCountTestAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountQueueNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueNumberWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountRadiationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiationResultWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountTestAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestAssignmentWhereInput
  }


  /**
   * Count Type TestCountOutputType
   */

  export type TestCountOutputType = {
    testAssignments: number
  }

  export type TestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testAssignments?: boolean | TestCountOutputTypeCountTestAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * TestCountOutputType without action
   */
  export type TestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCountOutputType
     */
    select?: TestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestCountOutputType without action
   */
  export type TestCountOutputTypeCountTestAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestAssignmentWhereInput
  }


  /**
   * Count Type TestAssignmentCountOutputType
   */

  export type TestAssignmentCountOutputType = {
    invoiceItems: number
    radiationResults: number
    samples: number
  }

  export type TestAssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | TestAssignmentCountOutputTypeCountInvoiceItemsArgs
    radiationResults?: boolean | TestAssignmentCountOutputTypeCountRadiationResultsArgs
    samples?: boolean | TestAssignmentCountOutputTypeCountSamplesArgs
  }

  // Custom InputTypes
  /**
   * TestAssignmentCountOutputType without action
   */
  export type TestAssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignmentCountOutputType
     */
    select?: TestAssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestAssignmentCountOutputType without action
   */
  export type TestAssignmentCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * TestAssignmentCountOutputType without action
   */
  export type TestAssignmentCountOutputTypeCountRadiationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiationResultWhereInput
  }

  /**
   * TestAssignmentCountOutputType without action
   */
  export type TestAssignmentCountOutputTypeCountSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type PurchaseInvoiceCountOutputType
   */

  export type PurchaseInvoiceCountOutputType = {
    items: number
  }

  export type PurchaseInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseInvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseInvoiceCountOutputType without action
   */
  export type PurchaseInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceCountOutputType
     */
    select?: PurchaseInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseInvoiceCountOutputType without action
   */
  export type PurchaseInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
  }


  /**
   * Count Type LabMaterialCountOutputType
   */

  export type LabMaterialCountOutputType = {
    transactions: number
  }

  export type LabMaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | LabMaterialCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * LabMaterialCountOutputType without action
   */
  export type LabMaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabMaterialCountOutputType
     */
    select?: LabMaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabMaterialCountOutputType without action
   */
  export type LabMaterialCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialTransactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    sessionVersion: number | null
  }

  export type UserSumAggregateOutputType = {
    sessionVersion: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    approved: boolean | null
    sessionVersion: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    approved: boolean | null
    sessionVersion: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    approved: number
    sessionVersion: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    sessionVersion?: true
  }

  export type UserSumAggregateInputType = {
    sessionVersion?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    approved?: true
    sessionVersion?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    approved?: true
    sessionVersion?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    approved?: true
    sessionVersion?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    approved: boolean
    sessionVersion: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approved?: boolean
    sessionVersion?: boolean
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    patients?: boolean | User$patientsArgs<ExtArgs>
    purchaseInvoices?: boolean | User$purchaseInvoicesArgs<ExtArgs>
    radiationResults?: boolean | User$radiationResultsArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    samples?: boolean | User$samplesArgs<ExtArgs>
    testAssignments?: boolean | User$testAssignmentsArgs<ExtArgs>
    materialTransactions?: boolean | User$materialTransactionsArgs<ExtArgs>
    labMaterials?: boolean | User$labMaterialsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approved?: boolean
    sessionVersion?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "createdAt" | "updatedAt" | "approved" | "sessionVersion", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    patients?: boolean | User$patientsArgs<ExtArgs>
    purchaseInvoices?: boolean | User$purchaseInvoicesArgs<ExtArgs>
    radiationResults?: boolean | User$radiationResultsArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    samples?: boolean | User$samplesArgs<ExtArgs>
    testAssignments?: boolean | User$testAssignmentsArgs<ExtArgs>
    materialTransactions?: boolean | User$materialTransactionsArgs<ExtArgs>
    labMaterials?: boolean | User$labMaterialsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      patients: Prisma.$PatientPayload<ExtArgs>[]
      purchaseInvoices: Prisma.$PurchaseInvoicePayload<ExtArgs>[]
      radiationResults: Prisma.$RadiationResultPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      samples: Prisma.$SamplePayload<ExtArgs>[]
      testAssignments: Prisma.$TestAssignmentPayload<ExtArgs>[]
      materialTransactions: Prisma.$MaterialTransactionPayload<ExtArgs>[]
      labMaterials: Prisma.$LabMaterialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
      approved: boolean
      sessionVersion: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patients<T extends User$patientsArgs<ExtArgs> = {}>(args?: Subset<T, User$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseInvoices<T extends User$purchaseInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$purchaseInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radiationResults<T extends User$radiationResultsArgs<ExtArgs> = {}>(args?: Subset<T, User$radiationResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiationResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends User$reportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    samples<T extends User$samplesArgs<ExtArgs> = {}>(args?: Subset<T, User$samplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testAssignments<T extends User$testAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$testAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    materialTransactions<T extends User$materialTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$materialTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labMaterials<T extends User$labMaterialsArgs<ExtArgs> = {}>(args?: Subset<T, User$labMaterialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly approved: FieldRef<"User", 'Boolean'>
    readonly sessionVersion: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.invoices
   */
  export type User$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.patients
   */
  export type User$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * User.purchaseInvoices
   */
  export type User$purchaseInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * User.radiationResults
   */
  export type User$radiationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationResult
     */
    select?: RadiationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationResult
     */
    omit?: RadiationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationResultInclude<ExtArgs> | null
    where?: RadiationResultWhereInput
    orderBy?: RadiationResultOrderByWithRelationInput | RadiationResultOrderByWithRelationInput[]
    cursor?: RadiationResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadiationResultScalarFieldEnum | RadiationResultScalarFieldEnum[]
  }

  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.samples
   */
  export type User$samplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    where?: SampleWhereInput
    orderBy?: SampleOrderByWithRelationInput | SampleOrderByWithRelationInput[]
    cursor?: SampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SampleScalarFieldEnum | SampleScalarFieldEnum[]
  }

  /**
   * User.testAssignments
   */
  export type User$testAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignment
     */
    select?: TestAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAssignment
     */
    omit?: TestAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAssignmentInclude<ExtArgs> | null
    where?: TestAssignmentWhereInput
    orderBy?: TestAssignmentOrderByWithRelationInput | TestAssignmentOrderByWithRelationInput[]
    cursor?: TestAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestAssignmentScalarFieldEnum | TestAssignmentScalarFieldEnum[]
  }

  /**
   * User.materialTransactions
   */
  export type User$materialTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialTransaction
     */
    select?: MaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialTransaction
     */
    omit?: MaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialTransactionInclude<ExtArgs> | null
    where?: MaterialTransactionWhereInput
    orderBy?: MaterialTransactionOrderByWithRelationInput | MaterialTransactionOrderByWithRelationInput[]
    cursor?: MaterialTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialTransactionScalarFieldEnum | MaterialTransactionScalarFieldEnum[]
  }

  /**
   * User.labMaterials
   */
  export type User$labMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabMaterial
     */
    select?: LabMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabMaterial
     */
    omit?: LabMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabMaterialInclude<ExtArgs> | null
    where?: LabMaterialWhereInput
    orderBy?: LabMaterialOrderByWithRelationInput | LabMaterialOrderByWithRelationInput[]
    cursor?: LabMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabMaterialScalarFieldEnum | LabMaterialScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    fileNumber: string | null
    name: string | null
    phone: string | null
    address: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    fileNumber: string | null
    name: string | null
    phone: string | null
    address: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    fileNumber: number
    name: number
    phone: number
    address: number
    dateOfBirth: number
    gender: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    fileNumber?: true
    name?: true
    phone?: true
    address?: true
    dateOfBirth?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    fileNumber?: true
    name?: true
    phone?: true
    address?: true
    dateOfBirth?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    fileNumber?: true
    name?: true
    phone?: true
    address?: true
    dateOfBirth?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    fileNumber: string
    name: string
    phone: string | null
    address: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileNumber?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    queueNumbers?: boolean | Patient$queueNumbersArgs<ExtArgs>
    radiationResults?: boolean | Patient$radiationResultsArgs<ExtArgs>
    testAssignments?: boolean | Patient$testAssignmentsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>



  export type PatientSelectScalar = {
    id?: boolean
    fileNumber?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fileNumber" | "name" | "phone" | "address" | "dateOfBirth" | "gender" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    queueNumbers?: boolean | Patient$queueNumbersArgs<ExtArgs>
    radiationResults?: boolean | Patient$radiationResultsArgs<ExtArgs>
    testAssignments?: boolean | Patient$testAssignmentsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs>
      queueNumbers: Prisma.$QueueNumberPayload<ExtArgs>[]
      radiationResults: Prisma.$RadiationResultPayload<ExtArgs>[]
      testAssignments: Prisma.$TestAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileNumber: string
      name: string
      phone: string | null
      address: string | null
      dateOfBirth: Date | null
      gender: $Enums.Gender
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends Patient$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    queueNumbers<T extends Patient$queueNumbersArgs<ExtArgs> = {}>(args?: Subset<T, Patient$queueNumbersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueNumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radiationResults<T extends Patient$radiationResultsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$radiationResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiationResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testAssignments<T extends Patient$testAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$testAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly fileNumber: FieldRef<"Patient", 'String'>
    readonly name: FieldRef<"Patient", 'String'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly address: FieldRef<"Patient", 'String'>
    readonly dateOfBirth: FieldRef<"Patient", 'DateTime'>
    readonly gender: FieldRef<"Patient", 'Gender'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
    readonly createdById: FieldRef<"Patient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.invoices
   */
  export type Patient$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Patient.queueNumbers
   */
  export type Patient$queueNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueNumber
     */
    select?: QueueNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueNumber
     */
    omit?: QueueNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueNumberInclude<ExtArgs> | null
    where?: QueueNumberWhereInput
    orderBy?: QueueNumberOrderByWithRelationInput | QueueNumberOrderByWithRelationInput[]
    cursor?: QueueNumberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueNumberScalarFieldEnum | QueueNumberScalarFieldEnum[]
  }

  /**
   * Patient.radiationResults
   */
  export type Patient$radiationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationResult
     */
    select?: RadiationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationResult
     */
    omit?: RadiationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationResultInclude<ExtArgs> | null
    where?: RadiationResultWhereInput
    orderBy?: RadiationResultOrderByWithRelationInput | RadiationResultOrderByWithRelationInput[]
    cursor?: RadiationResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadiationResultScalarFieldEnum | RadiationResultScalarFieldEnum[]
  }

  /**
   * Patient.testAssignments
   */
  export type Patient$testAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignment
     */
    select?: TestAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAssignment
     */
    omit?: TestAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAssignmentInclude<ExtArgs> | null
    where?: TestAssignmentWhereInput
    orderBy?: TestAssignmentOrderByWithRelationInput | TestAssignmentOrderByWithRelationInput[]
    cursor?: TestAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestAssignmentScalarFieldEnum | TestAssignmentScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Test
   */

  export type AggregateTest = {
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  export type TestAvgAggregateOutputType = {
    price: number | null
  }

  export type TestSumAggregateOutputType = {
    price: number | null
  }

  export type TestMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    price: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    price: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestCountAggregateOutputType = {
    id: number
    name: number
    category: number
    price: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestAvgAggregateInputType = {
    price?: true
  }

  export type TestSumAggregateInputType = {
    price?: true
  }

  export type TestMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    price?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    price?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    price?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Test to aggregate.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tests
    **/
    _count?: true | TestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestMaxAggregateInputType
  }

  export type GetTestAggregateType<T extends TestAggregateArgs> = {
        [P in keyof T & keyof AggregateTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest[P]>
      : GetScalarType<T[P], AggregateTest[P]>
  }




  export type TestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestWhereInput
    orderBy?: TestOrderByWithAggregationInput | TestOrderByWithAggregationInput[]
    by: TestScalarFieldEnum[] | TestScalarFieldEnum
    having?: TestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestCountAggregateInputType | true
    _avg?: TestAvgAggregateInputType
    _sum?: TestSumAggregateInputType
    _min?: TestMinAggregateInputType
    _max?: TestMaxAggregateInputType
  }

  export type TestGroupByOutputType = {
    id: string
    name: string
    category: string
    price: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  type GetTestGroupByPayload<T extends TestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestGroupByOutputType[P]>
            : GetScalarType<T[P], TestGroupByOutputType[P]>
        }
      >
    >


  export type TestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testAssignments?: boolean | Test$testAssignmentsArgs<ExtArgs>
    _count?: boolean | TestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test"]>



  export type TestSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "price" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["test"]>
  export type TestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testAssignments?: boolean | Test$testAssignmentsArgs<ExtArgs>
    _count?: boolean | TestCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Test"
    objects: {
      testAssignments: Prisma.$TestAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string
      price: number
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["test"]>
    composites: {}
  }

  type TestGetPayload<S extends boolean | null | undefined | TestDefaultArgs> = $Result.GetResult<Prisma.$TestPayload, S>

  type TestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestCountAggregateInputType | true
    }

  export interface TestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Test'], meta: { name: 'Test' } }
    /**
     * Find zero or one Test that matches the filter.
     * @param {TestFindUniqueArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestFindUniqueArgs>(args: SelectSubset<T, TestFindUniqueArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestFindUniqueOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestFindUniqueOrThrowArgs>(args: SelectSubset<T, TestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestFindFirstArgs>(args?: SelectSubset<T, TestFindFirstArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestFindFirstOrThrowArgs>(args?: SelectSubset<T, TestFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tests
     * const tests = await prisma.test.findMany()
     * 
     * // Get first 10 Tests
     * const tests = await prisma.test.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testWithIdOnly = await prisma.test.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestFindManyArgs>(args?: SelectSubset<T, TestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test.
     * @param {TestCreateArgs} args - Arguments to create a Test.
     * @example
     * // Create one Test
     * const Test = await prisma.test.create({
     *   data: {
     *     // ... data to create a Test
     *   }
     * })
     * 
     */
    create<T extends TestCreateArgs>(args: SelectSubset<T, TestCreateArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tests.
     * @param {TestCreateManyArgs} args - Arguments to create many Tests.
     * @example
     * // Create many Tests
     * const test = await prisma.test.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestCreateManyArgs>(args?: SelectSubset<T, TestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test.
     * @param {TestDeleteArgs} args - Arguments to delete one Test.
     * @example
     * // Delete one Test
     * const Test = await prisma.test.delete({
     *   where: {
     *     // ... filter to delete one Test
     *   }
     * })
     * 
     */
    delete<T extends TestDeleteArgs>(args: SelectSubset<T, TestDeleteArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test.
     * @param {TestUpdateArgs} args - Arguments to update one Test.
     * @example
     * // Update one Test
     * const test = await prisma.test.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestUpdateArgs>(args: SelectSubset<T, TestUpdateArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tests.
     * @param {TestDeleteManyArgs} args - Arguments to filter Tests to delete.
     * @example
     * // Delete a few Tests
     * const { count } = await prisma.test.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestDeleteManyArgs>(args?: SelectSubset<T, TestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tests
     * const test = await prisma.test.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestUpdateManyArgs>(args: SelectSubset<T, TestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test.
     * @param {TestUpsertArgs} args - Arguments to update or create a Test.
     * @example
     * // Update or create a Test
     * const test = await prisma.test.upsert({
     *   create: {
     *     // ... data to create a Test
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test we want to update
     *   }
     * })
     */
    upsert<T extends TestUpsertArgs>(args: SelectSubset<T, TestUpsertArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCountArgs} args - Arguments to filter Tests to count.
     * @example
     * // Count the number of Tests
     * const count = await prisma.test.count({
     *   where: {
     *     // ... the filter for the Tests we want to count
     *   }
     * })
    **/
    count<T extends TestCountArgs>(
      args?: Subset<T, TestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestAggregateArgs>(args: Subset<T, TestAggregateArgs>): Prisma.PrismaPromise<GetTestAggregateType<T>>

    /**
     * Group by Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestGroupByArgs['orderBy'] }
        : { orderBy?: TestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Test model
   */
  readonly fields: TestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Test.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testAssignments<T extends Test$testAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Test$testAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Test model
   */
  interface TestFieldRefs {
    readonly id: FieldRef<"Test", 'String'>
    readonly name: FieldRef<"Test", 'String'>
    readonly category: FieldRef<"Test", 'String'>
    readonly price: FieldRef<"Test", 'Float'>
    readonly description: FieldRef<"Test", 'String'>
    readonly createdAt: FieldRef<"Test", 'DateTime'>
    readonly updatedAt: FieldRef<"Test", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Test findUnique
   */
  export type TestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test findUniqueOrThrow
   */
  export type TestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test findFirst
   */
  export type TestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test findFirstOrThrow
   */
  export type TestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test findMany
   */
  export type TestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Tests to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test create
   */
  export type TestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The data needed to create a Test.
     */
    data: XOR<TestCreateInput, TestUncheckedCreateInput>
  }

  /**
   * Test createMany
   */
  export type TestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tests.
     */
    data: TestCreateManyInput | TestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Test update
   */
  export type TestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The data needed to update a Test.
     */
    data: XOR<TestUpdateInput, TestUncheckedUpdateInput>
    /**
     * Choose, which Test to update.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test updateMany
   */
  export type TestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tests.
     */
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyInput>
    /**
     * Filter which Tests to update
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to update.
     */
    limit?: number
  }

  /**
   * Test upsert
   */
  export type TestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The filter to search for the Test to update in case it exists.
     */
    where: TestWhereUniqueInput
    /**
     * In case the Test found by the `where` argument doesn't exist, create a new Test with this data.
     */
    create: XOR<TestCreateInput, TestUncheckedCreateInput>
    /**
     * In case the Test was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestUpdateInput, TestUncheckedUpdateInput>
  }

  /**
   * Test delete
   */
  export type TestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter which Test to delete.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test deleteMany
   */
  export type TestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tests to delete
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to delete.
     */
    limit?: number
  }

  /**
   * Test.testAssignments
   */
  export type Test$testAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignment
     */
    select?: TestAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAssignment
     */
    omit?: TestAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAssignmentInclude<ExtArgs> | null
    where?: TestAssignmentWhereInput
    orderBy?: TestAssignmentOrderByWithRelationInput | TestAssignmentOrderByWithRelationInput[]
    cursor?: TestAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestAssignmentScalarFieldEnum | TestAssignmentScalarFieldEnum[]
  }

  /**
   * Test without action
   */
  export type TestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
  }


  /**
   * Model TestAssignment
   */

  export type AggregateTestAssignment = {
    _count: TestAssignmentCountAggregateOutputType | null
    _min: TestAssignmentMinAggregateOutputType | null
    _max: TestAssignmentMaxAggregateOutputType | null
  }

  export type TestAssignmentMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    testId: string | null
    status: $Enums.TestStatus | null
    assignedById: string | null
    assignedAt: Date | null
    updatedAt: Date | null
  }

  export type TestAssignmentMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    testId: string | null
    status: $Enums.TestStatus | null
    assignedById: string | null
    assignedAt: Date | null
    updatedAt: Date | null
  }

  export type TestAssignmentCountAggregateOutputType = {
    id: number
    patientId: number
    testId: number
    status: number
    assignedById: number
    assignedAt: number
    updatedAt: number
    _all: number
  }


  export type TestAssignmentMinAggregateInputType = {
    id?: true
    patientId?: true
    testId?: true
    status?: true
    assignedById?: true
    assignedAt?: true
    updatedAt?: true
  }

  export type TestAssignmentMaxAggregateInputType = {
    id?: true
    patientId?: true
    testId?: true
    status?: true
    assignedById?: true
    assignedAt?: true
    updatedAt?: true
  }

  export type TestAssignmentCountAggregateInputType = {
    id?: true
    patientId?: true
    testId?: true
    status?: true
    assignedById?: true
    assignedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestAssignment to aggregate.
     */
    where?: TestAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestAssignments to fetch.
     */
    orderBy?: TestAssignmentOrderByWithRelationInput | TestAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestAssignments
    **/
    _count?: true | TestAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestAssignmentMaxAggregateInputType
  }

  export type GetTestAssignmentAggregateType<T extends TestAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTestAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestAssignment[P]>
      : GetScalarType<T[P], AggregateTestAssignment[P]>
  }




  export type TestAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestAssignmentWhereInput
    orderBy?: TestAssignmentOrderByWithAggregationInput | TestAssignmentOrderByWithAggregationInput[]
    by: TestAssignmentScalarFieldEnum[] | TestAssignmentScalarFieldEnum
    having?: TestAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestAssignmentCountAggregateInputType | true
    _min?: TestAssignmentMinAggregateInputType
    _max?: TestAssignmentMaxAggregateInputType
  }

  export type TestAssignmentGroupByOutputType = {
    id: string
    patientId: string
    testId: string
    status: $Enums.TestStatus
    assignedById: string
    assignedAt: Date
    updatedAt: Date
    _count: TestAssignmentCountAggregateOutputType | null
    _min: TestAssignmentMinAggregateOutputType | null
    _max: TestAssignmentMaxAggregateOutputType | null
  }

  type GetTestAssignmentGroupByPayload<T extends TestAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], TestAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type TestAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    testId?: boolean
    status?: boolean
    assignedById?: boolean
    assignedAt?: boolean
    updatedAt?: boolean
    invoiceItems?: boolean | TestAssignment$invoiceItemsArgs<ExtArgs>
    radiationResults?: boolean | TestAssignment$radiationResultsArgs<ExtArgs>
    samples?: boolean | TestAssignment$samplesArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    test?: boolean | TestDefaultArgs<ExtArgs>
    _count?: boolean | TestAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testAssignment"]>



  export type TestAssignmentSelectScalar = {
    id?: boolean
    patientId?: boolean
    testId?: boolean
    status?: boolean
    assignedById?: boolean
    assignedAt?: boolean
    updatedAt?: boolean
  }

  export type TestAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "testId" | "status" | "assignedById" | "assignedAt" | "updatedAt", ExtArgs["result"]["testAssignment"]>
  export type TestAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | TestAssignment$invoiceItemsArgs<ExtArgs>
    radiationResults?: boolean | TestAssignment$radiationResultsArgs<ExtArgs>
    samples?: boolean | TestAssignment$samplesArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    test?: boolean | TestDefaultArgs<ExtArgs>
    _count?: boolean | TestAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TestAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestAssignment"
    objects: {
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
      radiationResults: Prisma.$RadiationResultPayload<ExtArgs>[]
      samples: Prisma.$SamplePayload<ExtArgs>[]
      assignedBy: Prisma.$UserPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      test: Prisma.$TestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      testId: string
      status: $Enums.TestStatus
      assignedById: string
      assignedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testAssignment"]>
    composites: {}
  }

  type TestAssignmentGetPayload<S extends boolean | null | undefined | TestAssignmentDefaultArgs> = $Result.GetResult<Prisma.$TestAssignmentPayload, S>

  type TestAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestAssignmentCountAggregateInputType | true
    }

  export interface TestAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestAssignment'], meta: { name: 'TestAssignment' } }
    /**
     * Find zero or one TestAssignment that matches the filter.
     * @param {TestAssignmentFindUniqueArgs} args - Arguments to find a TestAssignment
     * @example
     * // Get one TestAssignment
     * const testAssignment = await prisma.testAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestAssignmentFindUniqueArgs>(args: SelectSubset<T, TestAssignmentFindUniqueArgs<ExtArgs>>): Prisma__TestAssignmentClient<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestAssignmentFindUniqueOrThrowArgs} args - Arguments to find a TestAssignment
     * @example
     * // Get one TestAssignment
     * const testAssignment = await prisma.testAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TestAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestAssignmentClient<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAssignmentFindFirstArgs} args - Arguments to find a TestAssignment
     * @example
     * // Get one TestAssignment
     * const testAssignment = await prisma.testAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestAssignmentFindFirstArgs>(args?: SelectSubset<T, TestAssignmentFindFirstArgs<ExtArgs>>): Prisma__TestAssignmentClient<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAssignmentFindFirstOrThrowArgs} args - Arguments to find a TestAssignment
     * @example
     * // Get one TestAssignment
     * const testAssignment = await prisma.testAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TestAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestAssignmentClient<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestAssignments
     * const testAssignments = await prisma.testAssignment.findMany()
     * 
     * // Get first 10 TestAssignments
     * const testAssignments = await prisma.testAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testAssignmentWithIdOnly = await prisma.testAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestAssignmentFindManyArgs>(args?: SelectSubset<T, TestAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestAssignment.
     * @param {TestAssignmentCreateArgs} args - Arguments to create a TestAssignment.
     * @example
     * // Create one TestAssignment
     * const TestAssignment = await prisma.testAssignment.create({
     *   data: {
     *     // ... data to create a TestAssignment
     *   }
     * })
     * 
     */
    create<T extends TestAssignmentCreateArgs>(args: SelectSubset<T, TestAssignmentCreateArgs<ExtArgs>>): Prisma__TestAssignmentClient<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestAssignments.
     * @param {TestAssignmentCreateManyArgs} args - Arguments to create many TestAssignments.
     * @example
     * // Create many TestAssignments
     * const testAssignment = await prisma.testAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestAssignmentCreateManyArgs>(args?: SelectSubset<T, TestAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TestAssignment.
     * @param {TestAssignmentDeleteArgs} args - Arguments to delete one TestAssignment.
     * @example
     * // Delete one TestAssignment
     * const TestAssignment = await prisma.testAssignment.delete({
     *   where: {
     *     // ... filter to delete one TestAssignment
     *   }
     * })
     * 
     */
    delete<T extends TestAssignmentDeleteArgs>(args: SelectSubset<T, TestAssignmentDeleteArgs<ExtArgs>>): Prisma__TestAssignmentClient<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestAssignment.
     * @param {TestAssignmentUpdateArgs} args - Arguments to update one TestAssignment.
     * @example
     * // Update one TestAssignment
     * const testAssignment = await prisma.testAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestAssignmentUpdateArgs>(args: SelectSubset<T, TestAssignmentUpdateArgs<ExtArgs>>): Prisma__TestAssignmentClient<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestAssignments.
     * @param {TestAssignmentDeleteManyArgs} args - Arguments to filter TestAssignments to delete.
     * @example
     * // Delete a few TestAssignments
     * const { count } = await prisma.testAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestAssignmentDeleteManyArgs>(args?: SelectSubset<T, TestAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestAssignments
     * const testAssignment = await prisma.testAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestAssignmentUpdateManyArgs>(args: SelectSubset<T, TestAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestAssignment.
     * @param {TestAssignmentUpsertArgs} args - Arguments to update or create a TestAssignment.
     * @example
     * // Update or create a TestAssignment
     * const testAssignment = await prisma.testAssignment.upsert({
     *   create: {
     *     // ... data to create a TestAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestAssignment we want to update
     *   }
     * })
     */
    upsert<T extends TestAssignmentUpsertArgs>(args: SelectSubset<T, TestAssignmentUpsertArgs<ExtArgs>>): Prisma__TestAssignmentClient<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAssignmentCountArgs} args - Arguments to filter TestAssignments to count.
     * @example
     * // Count the number of TestAssignments
     * const count = await prisma.testAssignment.count({
     *   where: {
     *     // ... the filter for the TestAssignments we want to count
     *   }
     * })
    **/
    count<T extends TestAssignmentCountArgs>(
      args?: Subset<T, TestAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestAssignmentAggregateArgs>(args: Subset<T, TestAssignmentAggregateArgs>): Prisma.PrismaPromise<GetTestAssignmentAggregateType<T>>

    /**
     * Group by TestAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: TestAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestAssignment model
   */
  readonly fields: TestAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoiceItems<T extends TestAssignment$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, TestAssignment$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radiationResults<T extends TestAssignment$radiationResultsArgs<ExtArgs> = {}>(args?: Subset<T, TestAssignment$radiationResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiationResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    samples<T extends TestAssignment$samplesArgs<ExtArgs> = {}>(args?: Subset<T, TestAssignment$samplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    test<T extends TestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestDefaultArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestAssignment model
   */
  interface TestAssignmentFieldRefs {
    readonly id: FieldRef<"TestAssignment", 'String'>
    readonly patientId: FieldRef<"TestAssignment", 'String'>
    readonly testId: FieldRef<"TestAssignment", 'String'>
    readonly status: FieldRef<"TestAssignment", 'TestStatus'>
    readonly assignedById: FieldRef<"TestAssignment", 'String'>
    readonly assignedAt: FieldRef<"TestAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"TestAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestAssignment findUnique
   */
  export type TestAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignment
     */
    select?: TestAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAssignment
     */
    omit?: TestAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TestAssignment to fetch.
     */
    where: TestAssignmentWhereUniqueInput
  }

  /**
   * TestAssignment findUniqueOrThrow
   */
  export type TestAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignment
     */
    select?: TestAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAssignment
     */
    omit?: TestAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TestAssignment to fetch.
     */
    where: TestAssignmentWhereUniqueInput
  }

  /**
   * TestAssignment findFirst
   */
  export type TestAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignment
     */
    select?: TestAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAssignment
     */
    omit?: TestAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TestAssignment to fetch.
     */
    where?: TestAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestAssignments to fetch.
     */
    orderBy?: TestAssignmentOrderByWithRelationInput | TestAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestAssignments.
     */
    cursor?: TestAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestAssignments.
     */
    distinct?: TestAssignmentScalarFieldEnum | TestAssignmentScalarFieldEnum[]
  }

  /**
   * TestAssignment findFirstOrThrow
   */
  export type TestAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignment
     */
    select?: TestAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAssignment
     */
    omit?: TestAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TestAssignment to fetch.
     */
    where?: TestAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestAssignments to fetch.
     */
    orderBy?: TestAssignmentOrderByWithRelationInput | TestAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestAssignments.
     */
    cursor?: TestAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestAssignments.
     */
    distinct?: TestAssignmentScalarFieldEnum | TestAssignmentScalarFieldEnum[]
  }

  /**
   * TestAssignment findMany
   */
  export type TestAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignment
     */
    select?: TestAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAssignment
     */
    omit?: TestAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TestAssignments to fetch.
     */
    where?: TestAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestAssignments to fetch.
     */
    orderBy?: TestAssignmentOrderByWithRelationInput | TestAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestAssignments.
     */
    cursor?: TestAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestAssignments.
     */
    skip?: number
    distinct?: TestAssignmentScalarFieldEnum | TestAssignmentScalarFieldEnum[]
  }

  /**
   * TestAssignment create
   */
  export type TestAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignment
     */
    select?: TestAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAssignment
     */
    omit?: TestAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TestAssignment.
     */
    data: XOR<TestAssignmentCreateInput, TestAssignmentUncheckedCreateInput>
  }

  /**
   * TestAssignment createMany
   */
  export type TestAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestAssignments.
     */
    data: TestAssignmentCreateManyInput | TestAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestAssignment update
   */
  export type TestAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignment
     */
    select?: TestAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAssignment
     */
    omit?: TestAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TestAssignment.
     */
    data: XOR<TestAssignmentUpdateInput, TestAssignmentUncheckedUpdateInput>
    /**
     * Choose, which TestAssignment to update.
     */
    where: TestAssignmentWhereUniqueInput
  }

  /**
   * TestAssignment updateMany
   */
  export type TestAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestAssignments.
     */
    data: XOR<TestAssignmentUpdateManyMutationInput, TestAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TestAssignments to update
     */
    where?: TestAssignmentWhereInput
    /**
     * Limit how many TestAssignments to update.
     */
    limit?: number
  }

  /**
   * TestAssignment upsert
   */
  export type TestAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignment
     */
    select?: TestAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAssignment
     */
    omit?: TestAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TestAssignment to update in case it exists.
     */
    where: TestAssignmentWhereUniqueInput
    /**
     * In case the TestAssignment found by the `where` argument doesn't exist, create a new TestAssignment with this data.
     */
    create: XOR<TestAssignmentCreateInput, TestAssignmentUncheckedCreateInput>
    /**
     * In case the TestAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestAssignmentUpdateInput, TestAssignmentUncheckedUpdateInput>
  }

  /**
   * TestAssignment delete
   */
  export type TestAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignment
     */
    select?: TestAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAssignment
     */
    omit?: TestAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAssignmentInclude<ExtArgs> | null
    /**
     * Filter which TestAssignment to delete.
     */
    where: TestAssignmentWhereUniqueInput
  }

  /**
   * TestAssignment deleteMany
   */
  export type TestAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestAssignments to delete
     */
    where?: TestAssignmentWhereInput
    /**
     * Limit how many TestAssignments to delete.
     */
    limit?: number
  }

  /**
   * TestAssignment.invoiceItems
   */
  export type TestAssignment$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * TestAssignment.radiationResults
   */
  export type TestAssignment$radiationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationResult
     */
    select?: RadiationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationResult
     */
    omit?: RadiationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationResultInclude<ExtArgs> | null
    where?: RadiationResultWhereInput
    orderBy?: RadiationResultOrderByWithRelationInput | RadiationResultOrderByWithRelationInput[]
    cursor?: RadiationResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadiationResultScalarFieldEnum | RadiationResultScalarFieldEnum[]
  }

  /**
   * TestAssignment.samples
   */
  export type TestAssignment$samplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    where?: SampleWhereInput
    orderBy?: SampleOrderByWithRelationInput | SampleOrderByWithRelationInput[]
    cursor?: SampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SampleScalarFieldEnum | SampleScalarFieldEnum[]
  }

  /**
   * TestAssignment without action
   */
  export type TestAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAssignment
     */
    select?: TestAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAssignment
     */
    omit?: TestAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Sample
   */

  export type AggregateSample = {
    _count: SampleCountAggregateOutputType | null
    _min: SampleMinAggregateOutputType | null
    _max: SampleMaxAggregateOutputType | null
  }

  export type SampleMinAggregateOutputType = {
    id: string | null
    testAssignmentId: string | null
    sampleCode: string | null
    collectedAt: Date | null
    collectedById: string | null
    notes: string | null
    results: string | null
    reportPdfUrl: string | null
  }

  export type SampleMaxAggregateOutputType = {
    id: string | null
    testAssignmentId: string | null
    sampleCode: string | null
    collectedAt: Date | null
    collectedById: string | null
    notes: string | null
    results: string | null
    reportPdfUrl: string | null
  }

  export type SampleCountAggregateOutputType = {
    id: number
    testAssignmentId: number
    sampleCode: number
    collectedAt: number
    collectedById: number
    notes: number
    results: number
    reportPdfUrl: number
    _all: number
  }


  export type SampleMinAggregateInputType = {
    id?: true
    testAssignmentId?: true
    sampleCode?: true
    collectedAt?: true
    collectedById?: true
    notes?: true
    results?: true
    reportPdfUrl?: true
  }

  export type SampleMaxAggregateInputType = {
    id?: true
    testAssignmentId?: true
    sampleCode?: true
    collectedAt?: true
    collectedById?: true
    notes?: true
    results?: true
    reportPdfUrl?: true
  }

  export type SampleCountAggregateInputType = {
    id?: true
    testAssignmentId?: true
    sampleCode?: true
    collectedAt?: true
    collectedById?: true
    notes?: true
    results?: true
    reportPdfUrl?: true
    _all?: true
  }

  export type SampleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sample to aggregate.
     */
    where?: SampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Samples to fetch.
     */
    orderBy?: SampleOrderByWithRelationInput | SampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Samples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Samples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Samples
    **/
    _count?: true | SampleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SampleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SampleMaxAggregateInputType
  }

  export type GetSampleAggregateType<T extends SampleAggregateArgs> = {
        [P in keyof T & keyof AggregateSample]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSample[P]>
      : GetScalarType<T[P], AggregateSample[P]>
  }




  export type SampleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleWhereInput
    orderBy?: SampleOrderByWithAggregationInput | SampleOrderByWithAggregationInput[]
    by: SampleScalarFieldEnum[] | SampleScalarFieldEnum
    having?: SampleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SampleCountAggregateInputType | true
    _min?: SampleMinAggregateInputType
    _max?: SampleMaxAggregateInputType
  }

  export type SampleGroupByOutputType = {
    id: string
    testAssignmentId: string
    sampleCode: string
    collectedAt: Date
    collectedById: string
    notes: string | null
    results: string | null
    reportPdfUrl: string | null
    _count: SampleCountAggregateOutputType | null
    _min: SampleMinAggregateOutputType | null
    _max: SampleMaxAggregateOutputType | null
  }

  type GetSampleGroupByPayload<T extends SampleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SampleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SampleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SampleGroupByOutputType[P]>
            : GetScalarType<T[P], SampleGroupByOutputType[P]>
        }
      >
    >


  export type SampleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testAssignmentId?: boolean
    sampleCode?: boolean
    collectedAt?: boolean
    collectedById?: boolean
    notes?: boolean
    results?: boolean
    reportPdfUrl?: boolean
    collectedBy?: boolean | UserDefaultArgs<ExtArgs>
    testAssignment?: boolean | TestAssignmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sample"]>



  export type SampleSelectScalar = {
    id?: boolean
    testAssignmentId?: boolean
    sampleCode?: boolean
    collectedAt?: boolean
    collectedById?: boolean
    notes?: boolean
    results?: boolean
    reportPdfUrl?: boolean
  }

  export type SampleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testAssignmentId" | "sampleCode" | "collectedAt" | "collectedById" | "notes" | "results" | "reportPdfUrl", ExtArgs["result"]["sample"]>
  export type SampleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectedBy?: boolean | UserDefaultArgs<ExtArgs>
    testAssignment?: boolean | TestAssignmentDefaultArgs<ExtArgs>
  }

  export type $SamplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sample"
    objects: {
      collectedBy: Prisma.$UserPayload<ExtArgs>
      testAssignment: Prisma.$TestAssignmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testAssignmentId: string
      sampleCode: string
      collectedAt: Date
      collectedById: string
      notes: string | null
      results: string | null
      reportPdfUrl: string | null
    }, ExtArgs["result"]["sample"]>
    composites: {}
  }

  type SampleGetPayload<S extends boolean | null | undefined | SampleDefaultArgs> = $Result.GetResult<Prisma.$SamplePayload, S>

  type SampleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SampleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SampleCountAggregateInputType | true
    }

  export interface SampleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sample'], meta: { name: 'Sample' } }
    /**
     * Find zero or one Sample that matches the filter.
     * @param {SampleFindUniqueArgs} args - Arguments to find a Sample
     * @example
     * // Get one Sample
     * const sample = await prisma.sample.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SampleFindUniqueArgs>(args: SelectSubset<T, SampleFindUniqueArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sample that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SampleFindUniqueOrThrowArgs} args - Arguments to find a Sample
     * @example
     * // Get one Sample
     * const sample = await prisma.sample.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SampleFindUniqueOrThrowArgs>(args: SelectSubset<T, SampleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sample that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleFindFirstArgs} args - Arguments to find a Sample
     * @example
     * // Get one Sample
     * const sample = await prisma.sample.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SampleFindFirstArgs>(args?: SelectSubset<T, SampleFindFirstArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sample that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleFindFirstOrThrowArgs} args - Arguments to find a Sample
     * @example
     * // Get one Sample
     * const sample = await prisma.sample.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SampleFindFirstOrThrowArgs>(args?: SelectSubset<T, SampleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Samples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Samples
     * const samples = await prisma.sample.findMany()
     * 
     * // Get first 10 Samples
     * const samples = await prisma.sample.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sampleWithIdOnly = await prisma.sample.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SampleFindManyArgs>(args?: SelectSubset<T, SampleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sample.
     * @param {SampleCreateArgs} args - Arguments to create a Sample.
     * @example
     * // Create one Sample
     * const Sample = await prisma.sample.create({
     *   data: {
     *     // ... data to create a Sample
     *   }
     * })
     * 
     */
    create<T extends SampleCreateArgs>(args: SelectSubset<T, SampleCreateArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Samples.
     * @param {SampleCreateManyArgs} args - Arguments to create many Samples.
     * @example
     * // Create many Samples
     * const sample = await prisma.sample.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SampleCreateManyArgs>(args?: SelectSubset<T, SampleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sample.
     * @param {SampleDeleteArgs} args - Arguments to delete one Sample.
     * @example
     * // Delete one Sample
     * const Sample = await prisma.sample.delete({
     *   where: {
     *     // ... filter to delete one Sample
     *   }
     * })
     * 
     */
    delete<T extends SampleDeleteArgs>(args: SelectSubset<T, SampleDeleteArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sample.
     * @param {SampleUpdateArgs} args - Arguments to update one Sample.
     * @example
     * // Update one Sample
     * const sample = await prisma.sample.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SampleUpdateArgs>(args: SelectSubset<T, SampleUpdateArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Samples.
     * @param {SampleDeleteManyArgs} args - Arguments to filter Samples to delete.
     * @example
     * // Delete a few Samples
     * const { count } = await prisma.sample.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SampleDeleteManyArgs>(args?: SelectSubset<T, SampleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Samples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Samples
     * const sample = await prisma.sample.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SampleUpdateManyArgs>(args: SelectSubset<T, SampleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sample.
     * @param {SampleUpsertArgs} args - Arguments to update or create a Sample.
     * @example
     * // Update or create a Sample
     * const sample = await prisma.sample.upsert({
     *   create: {
     *     // ... data to create a Sample
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sample we want to update
     *   }
     * })
     */
    upsert<T extends SampleUpsertArgs>(args: SelectSubset<T, SampleUpsertArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Samples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleCountArgs} args - Arguments to filter Samples to count.
     * @example
     * // Count the number of Samples
     * const count = await prisma.sample.count({
     *   where: {
     *     // ... the filter for the Samples we want to count
     *   }
     * })
    **/
    count<T extends SampleCountArgs>(
      args?: Subset<T, SampleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SampleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SampleAggregateArgs>(args: Subset<T, SampleAggregateArgs>): Prisma.PrismaPromise<GetSampleAggregateType<T>>

    /**
     * Group by Sample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SampleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SampleGroupByArgs['orderBy'] }
        : { orderBy?: SampleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSampleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sample model
   */
  readonly fields: SampleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sample.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SampleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collectedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    testAssignment<T extends TestAssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestAssignmentDefaultArgs<ExtArgs>>): Prisma__TestAssignmentClient<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sample model
   */
  interface SampleFieldRefs {
    readonly id: FieldRef<"Sample", 'String'>
    readonly testAssignmentId: FieldRef<"Sample", 'String'>
    readonly sampleCode: FieldRef<"Sample", 'String'>
    readonly collectedAt: FieldRef<"Sample", 'DateTime'>
    readonly collectedById: FieldRef<"Sample", 'String'>
    readonly notes: FieldRef<"Sample", 'String'>
    readonly results: FieldRef<"Sample", 'String'>
    readonly reportPdfUrl: FieldRef<"Sample", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sample findUnique
   */
  export type SampleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * Filter, which Sample to fetch.
     */
    where: SampleWhereUniqueInput
  }

  /**
   * Sample findUniqueOrThrow
   */
  export type SampleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * Filter, which Sample to fetch.
     */
    where: SampleWhereUniqueInput
  }

  /**
   * Sample findFirst
   */
  export type SampleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * Filter, which Sample to fetch.
     */
    where?: SampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Samples to fetch.
     */
    orderBy?: SampleOrderByWithRelationInput | SampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Samples.
     */
    cursor?: SampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Samples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Samples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Samples.
     */
    distinct?: SampleScalarFieldEnum | SampleScalarFieldEnum[]
  }

  /**
   * Sample findFirstOrThrow
   */
  export type SampleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * Filter, which Sample to fetch.
     */
    where?: SampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Samples to fetch.
     */
    orderBy?: SampleOrderByWithRelationInput | SampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Samples.
     */
    cursor?: SampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Samples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Samples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Samples.
     */
    distinct?: SampleScalarFieldEnum | SampleScalarFieldEnum[]
  }

  /**
   * Sample findMany
   */
  export type SampleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * Filter, which Samples to fetch.
     */
    where?: SampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Samples to fetch.
     */
    orderBy?: SampleOrderByWithRelationInput | SampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Samples.
     */
    cursor?: SampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Samples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Samples.
     */
    skip?: number
    distinct?: SampleScalarFieldEnum | SampleScalarFieldEnum[]
  }

  /**
   * Sample create
   */
  export type SampleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sample.
     */
    data: XOR<SampleCreateInput, SampleUncheckedCreateInput>
  }

  /**
   * Sample createMany
   */
  export type SampleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Samples.
     */
    data: SampleCreateManyInput | SampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sample update
   */
  export type SampleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sample.
     */
    data: XOR<SampleUpdateInput, SampleUncheckedUpdateInput>
    /**
     * Choose, which Sample to update.
     */
    where: SampleWhereUniqueInput
  }

  /**
   * Sample updateMany
   */
  export type SampleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Samples.
     */
    data: XOR<SampleUpdateManyMutationInput, SampleUncheckedUpdateManyInput>
    /**
     * Filter which Samples to update
     */
    where?: SampleWhereInput
    /**
     * Limit how many Samples to update.
     */
    limit?: number
  }

  /**
   * Sample upsert
   */
  export type SampleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sample to update in case it exists.
     */
    where: SampleWhereUniqueInput
    /**
     * In case the Sample found by the `where` argument doesn't exist, create a new Sample with this data.
     */
    create: XOR<SampleCreateInput, SampleUncheckedCreateInput>
    /**
     * In case the Sample was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SampleUpdateInput, SampleUncheckedUpdateInput>
  }

  /**
   * Sample delete
   */
  export type SampleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * Filter which Sample to delete.
     */
    where: SampleWhereUniqueInput
  }

  /**
   * Sample deleteMany
   */
  export type SampleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Samples to delete
     */
    where?: SampleWhereInput
    /**
     * Limit how many Samples to delete.
     */
    limit?: number
  }

  /**
   * Sample without action
   */
  export type SampleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    totalAmount: number | null
    paidAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    totalAmount: number | null
    paidAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    totalAmount: number | null
    paidAmount: number | null
    isPaid: boolean | null
    invoiceDate: Date | null
    dueDate: Date | null
    createdById: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    totalAmount: number | null
    paidAmount: number | null
    isPaid: boolean | null
    invoiceDate: Date | null
    dueDate: Date | null
    createdById: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    patientId: number
    totalAmount: number
    paidAmount: number
    isPaid: number
    invoiceDate: number
    dueDate: number
    createdById: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    patientId?: true
    totalAmount?: true
    paidAmount?: true
    isPaid?: true
    invoiceDate?: true
    dueDate?: true
    createdById?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    patientId?: true
    totalAmount?: true
    paidAmount?: true
    isPaid?: true
    invoiceDate?: true
    dueDate?: true
    createdById?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    patientId?: true
    totalAmount?: true
    paidAmount?: true
    isPaid?: true
    invoiceDate?: true
    dueDate?: true
    createdById?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    patientId: string
    totalAmount: number
    paidAmount: number
    isPaid: boolean
    invoiceDate: Date
    dueDate: Date | null
    createdById: string
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    isPaid?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>



  export type InvoiceSelectScalar = {
    id?: boolean
    patientId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    isPaid?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    createdById?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "totalAmount" | "paidAmount" | "isPaid" | "invoiceDate" | "dueDate" | "createdById", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      totalAmount: number
      paidAmount: number
      isPaid: boolean
      invoiceDate: Date
      dueDate: Date | null
      createdById: string
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly patientId: FieldRef<"Invoice", 'String'>
    readonly totalAmount: FieldRef<"Invoice", 'Float'>
    readonly paidAmount: FieldRef<"Invoice", 'Float'>
    readonly isPaid: FieldRef<"Invoice", 'Boolean'>
    readonly invoiceDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly createdById: FieldRef<"Invoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    price: number | null
    quantity: number | null
    subtotal: number | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    price: number | null
    quantity: number | null
    subtotal: number | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    testAssignmentId: string | null
    price: number | null
    quantity: number | null
    subtotal: number | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    testAssignmentId: string | null
    price: number | null
    quantity: number | null
    subtotal: number | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    testAssignmentId: number
    price: number
    quantity: number
    subtotal: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    price?: true
    quantity?: true
    subtotal?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    price?: true
    quantity?: true
    subtotal?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    testAssignmentId?: true
    price?: true
    quantity?: true
    subtotal?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    testAssignmentId?: true
    price?: true
    quantity?: true
    subtotal?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    testAssignmentId?: true
    price?: true
    quantity?: true
    subtotal?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    testAssignmentId: string
    price: number
    quantity: number
    subtotal: number
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    testAssignmentId?: boolean
    price?: boolean
    quantity?: boolean
    subtotal?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    testAssignment?: boolean | TestAssignmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>



  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    testAssignmentId?: boolean
    price?: boolean
    quantity?: boolean
    subtotal?: boolean
  }

  export type InvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "testAssignmentId" | "price" | "quantity" | "subtotal", ExtArgs["result"]["invoiceItem"]>
  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    testAssignment?: boolean | TestAssignmentDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      testAssignment: Prisma.$TestAssignmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      testAssignmentId: string
      price: number
      quantity: number
      subtotal: number
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    testAssignment<T extends TestAssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestAssignmentDefaultArgs<ExtArgs>>): Prisma__TestAssignmentClient<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'String'>
    readonly testAssignmentId: FieldRef<"InvoiceItem", 'String'>
    readonly price: FieldRef<"InvoiceItem", 'Float'>
    readonly quantity: FieldRef<"InvoiceItem", 'Int'>
    readonly subtotal: FieldRef<"InvoiceItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model QueueNumber
   */

  export type AggregateQueueNumber = {
    _count: QueueNumberCountAggregateOutputType | null
    _avg: QueueNumberAvgAggregateOutputType | null
    _sum: QueueNumberSumAggregateOutputType | null
    _min: QueueNumberMinAggregateOutputType | null
    _max: QueueNumberMaxAggregateOutputType | null
  }

  export type QueueNumberAvgAggregateOutputType = {
    number: number | null
  }

  export type QueueNumberSumAggregateOutputType = {
    number: number | null
  }

  export type QueueNumberMinAggregateOutputType = {
    id: string | null
    number: number | null
    patientId: string | null
    date: Date | null
    status: $Enums.QueueStatus | null
  }

  export type QueueNumberMaxAggregateOutputType = {
    id: string | null
    number: number | null
    patientId: string | null
    date: Date | null
    status: $Enums.QueueStatus | null
  }

  export type QueueNumberCountAggregateOutputType = {
    id: number
    number: number
    patientId: number
    date: number
    status: number
    _all: number
  }


  export type QueueNumberAvgAggregateInputType = {
    number?: true
  }

  export type QueueNumberSumAggregateInputType = {
    number?: true
  }

  export type QueueNumberMinAggregateInputType = {
    id?: true
    number?: true
    patientId?: true
    date?: true
    status?: true
  }

  export type QueueNumberMaxAggregateInputType = {
    id?: true
    number?: true
    patientId?: true
    date?: true
    status?: true
  }

  export type QueueNumberCountAggregateInputType = {
    id?: true
    number?: true
    patientId?: true
    date?: true
    status?: true
    _all?: true
  }

  export type QueueNumberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueNumber to aggregate.
     */
    where?: QueueNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueNumbers to fetch.
     */
    orderBy?: QueueNumberOrderByWithRelationInput | QueueNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueueNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QueueNumbers
    **/
    _count?: true | QueueNumberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueueNumberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueueNumberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueueNumberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueueNumberMaxAggregateInputType
  }

  export type GetQueueNumberAggregateType<T extends QueueNumberAggregateArgs> = {
        [P in keyof T & keyof AggregateQueueNumber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueueNumber[P]>
      : GetScalarType<T[P], AggregateQueueNumber[P]>
  }




  export type QueueNumberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueNumberWhereInput
    orderBy?: QueueNumberOrderByWithAggregationInput | QueueNumberOrderByWithAggregationInput[]
    by: QueueNumberScalarFieldEnum[] | QueueNumberScalarFieldEnum
    having?: QueueNumberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueueNumberCountAggregateInputType | true
    _avg?: QueueNumberAvgAggregateInputType
    _sum?: QueueNumberSumAggregateInputType
    _min?: QueueNumberMinAggregateInputType
    _max?: QueueNumberMaxAggregateInputType
  }

  export type QueueNumberGroupByOutputType = {
    id: string
    number: number
    patientId: string
    date: Date
    status: $Enums.QueueStatus
    _count: QueueNumberCountAggregateOutputType | null
    _avg: QueueNumberAvgAggregateOutputType | null
    _sum: QueueNumberSumAggregateOutputType | null
    _min: QueueNumberMinAggregateOutputType | null
    _max: QueueNumberMaxAggregateOutputType | null
  }

  type GetQueueNumberGroupByPayload<T extends QueueNumberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueueNumberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueueNumberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueNumberGroupByOutputType[P]>
            : GetScalarType<T[P], QueueNumberGroupByOutputType[P]>
        }
      >
    >


  export type QueueNumberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    patientId?: boolean
    date?: boolean
    status?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queueNumber"]>



  export type QueueNumberSelectScalar = {
    id?: boolean
    number?: boolean
    patientId?: boolean
    date?: boolean
    status?: boolean
  }

  export type QueueNumberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "patientId" | "date" | "status", ExtArgs["result"]["queueNumber"]>
  export type QueueNumberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $QueueNumberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QueueNumber"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: number
      patientId: string
      date: Date
      status: $Enums.QueueStatus
    }, ExtArgs["result"]["queueNumber"]>
    composites: {}
  }

  type QueueNumberGetPayload<S extends boolean | null | undefined | QueueNumberDefaultArgs> = $Result.GetResult<Prisma.$QueueNumberPayload, S>

  type QueueNumberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueueNumberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueueNumberCountAggregateInputType | true
    }

  export interface QueueNumberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QueueNumber'], meta: { name: 'QueueNumber' } }
    /**
     * Find zero or one QueueNumber that matches the filter.
     * @param {QueueNumberFindUniqueArgs} args - Arguments to find a QueueNumber
     * @example
     * // Get one QueueNumber
     * const queueNumber = await prisma.queueNumber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueNumberFindUniqueArgs>(args: SelectSubset<T, QueueNumberFindUniqueArgs<ExtArgs>>): Prisma__QueueNumberClient<$Result.GetResult<Prisma.$QueueNumberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QueueNumber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueueNumberFindUniqueOrThrowArgs} args - Arguments to find a QueueNumber
     * @example
     * // Get one QueueNumber
     * const queueNumber = await prisma.queueNumber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueNumberFindUniqueOrThrowArgs>(args: SelectSubset<T, QueueNumberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueueNumberClient<$Result.GetResult<Prisma.$QueueNumberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueueNumber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueNumberFindFirstArgs} args - Arguments to find a QueueNumber
     * @example
     * // Get one QueueNumber
     * const queueNumber = await prisma.queueNumber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueNumberFindFirstArgs>(args?: SelectSubset<T, QueueNumberFindFirstArgs<ExtArgs>>): Prisma__QueueNumberClient<$Result.GetResult<Prisma.$QueueNumberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueueNumber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueNumberFindFirstOrThrowArgs} args - Arguments to find a QueueNumber
     * @example
     * // Get one QueueNumber
     * const queueNumber = await prisma.queueNumber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueNumberFindFirstOrThrowArgs>(args?: SelectSubset<T, QueueNumberFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueueNumberClient<$Result.GetResult<Prisma.$QueueNumberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QueueNumbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueNumberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueueNumbers
     * const queueNumbers = await prisma.queueNumber.findMany()
     * 
     * // Get first 10 QueueNumbers
     * const queueNumbers = await prisma.queueNumber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queueNumberWithIdOnly = await prisma.queueNumber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueueNumberFindManyArgs>(args?: SelectSubset<T, QueueNumberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueNumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QueueNumber.
     * @param {QueueNumberCreateArgs} args - Arguments to create a QueueNumber.
     * @example
     * // Create one QueueNumber
     * const QueueNumber = await prisma.queueNumber.create({
     *   data: {
     *     // ... data to create a QueueNumber
     *   }
     * })
     * 
     */
    create<T extends QueueNumberCreateArgs>(args: SelectSubset<T, QueueNumberCreateArgs<ExtArgs>>): Prisma__QueueNumberClient<$Result.GetResult<Prisma.$QueueNumberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QueueNumbers.
     * @param {QueueNumberCreateManyArgs} args - Arguments to create many QueueNumbers.
     * @example
     * // Create many QueueNumbers
     * const queueNumber = await prisma.queueNumber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueueNumberCreateManyArgs>(args?: SelectSubset<T, QueueNumberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QueueNumber.
     * @param {QueueNumberDeleteArgs} args - Arguments to delete one QueueNumber.
     * @example
     * // Delete one QueueNumber
     * const QueueNumber = await prisma.queueNumber.delete({
     *   where: {
     *     // ... filter to delete one QueueNumber
     *   }
     * })
     * 
     */
    delete<T extends QueueNumberDeleteArgs>(args: SelectSubset<T, QueueNumberDeleteArgs<ExtArgs>>): Prisma__QueueNumberClient<$Result.GetResult<Prisma.$QueueNumberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QueueNumber.
     * @param {QueueNumberUpdateArgs} args - Arguments to update one QueueNumber.
     * @example
     * // Update one QueueNumber
     * const queueNumber = await prisma.queueNumber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueueNumberUpdateArgs>(args: SelectSubset<T, QueueNumberUpdateArgs<ExtArgs>>): Prisma__QueueNumberClient<$Result.GetResult<Prisma.$QueueNumberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QueueNumbers.
     * @param {QueueNumberDeleteManyArgs} args - Arguments to filter QueueNumbers to delete.
     * @example
     * // Delete a few QueueNumbers
     * const { count } = await prisma.queueNumber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueueNumberDeleteManyArgs>(args?: SelectSubset<T, QueueNumberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueNumberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueueNumbers
     * const queueNumber = await prisma.queueNumber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueueNumberUpdateManyArgs>(args: SelectSubset<T, QueueNumberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QueueNumber.
     * @param {QueueNumberUpsertArgs} args - Arguments to update or create a QueueNumber.
     * @example
     * // Update or create a QueueNumber
     * const queueNumber = await prisma.queueNumber.upsert({
     *   create: {
     *     // ... data to create a QueueNumber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueueNumber we want to update
     *   }
     * })
     */
    upsert<T extends QueueNumberUpsertArgs>(args: SelectSubset<T, QueueNumberUpsertArgs<ExtArgs>>): Prisma__QueueNumberClient<$Result.GetResult<Prisma.$QueueNumberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QueueNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueNumberCountArgs} args - Arguments to filter QueueNumbers to count.
     * @example
     * // Count the number of QueueNumbers
     * const count = await prisma.queueNumber.count({
     *   where: {
     *     // ... the filter for the QueueNumbers we want to count
     *   }
     * })
    **/
    count<T extends QueueNumberCountArgs>(
      args?: Subset<T, QueueNumberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueNumberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QueueNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueNumberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueueNumberAggregateArgs>(args: Subset<T, QueueNumberAggregateArgs>): Prisma.PrismaPromise<GetQueueNumberAggregateType<T>>

    /**
     * Group by QueueNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueNumberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueueNumberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueNumberGroupByArgs['orderBy'] }
        : { orderBy?: QueueNumberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueueNumberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueueNumberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QueueNumber model
   */
  readonly fields: QueueNumberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueueNumber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueNumberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QueueNumber model
   */
  interface QueueNumberFieldRefs {
    readonly id: FieldRef<"QueueNumber", 'String'>
    readonly number: FieldRef<"QueueNumber", 'Int'>
    readonly patientId: FieldRef<"QueueNumber", 'String'>
    readonly date: FieldRef<"QueueNumber", 'DateTime'>
    readonly status: FieldRef<"QueueNumber", 'QueueStatus'>
  }
    

  // Custom InputTypes
  /**
   * QueueNumber findUnique
   */
  export type QueueNumberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueNumber
     */
    select?: QueueNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueNumber
     */
    omit?: QueueNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueNumberInclude<ExtArgs> | null
    /**
     * Filter, which QueueNumber to fetch.
     */
    where: QueueNumberWhereUniqueInput
  }

  /**
   * QueueNumber findUniqueOrThrow
   */
  export type QueueNumberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueNumber
     */
    select?: QueueNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueNumber
     */
    omit?: QueueNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueNumberInclude<ExtArgs> | null
    /**
     * Filter, which QueueNumber to fetch.
     */
    where: QueueNumberWhereUniqueInput
  }

  /**
   * QueueNumber findFirst
   */
  export type QueueNumberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueNumber
     */
    select?: QueueNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueNumber
     */
    omit?: QueueNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueNumberInclude<ExtArgs> | null
    /**
     * Filter, which QueueNumber to fetch.
     */
    where?: QueueNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueNumbers to fetch.
     */
    orderBy?: QueueNumberOrderByWithRelationInput | QueueNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueNumbers.
     */
    cursor?: QueueNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueNumbers.
     */
    distinct?: QueueNumberScalarFieldEnum | QueueNumberScalarFieldEnum[]
  }

  /**
   * QueueNumber findFirstOrThrow
   */
  export type QueueNumberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueNumber
     */
    select?: QueueNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueNumber
     */
    omit?: QueueNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueNumberInclude<ExtArgs> | null
    /**
     * Filter, which QueueNumber to fetch.
     */
    where?: QueueNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueNumbers to fetch.
     */
    orderBy?: QueueNumberOrderByWithRelationInput | QueueNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueNumbers.
     */
    cursor?: QueueNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueNumbers.
     */
    distinct?: QueueNumberScalarFieldEnum | QueueNumberScalarFieldEnum[]
  }

  /**
   * QueueNumber findMany
   */
  export type QueueNumberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueNumber
     */
    select?: QueueNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueNumber
     */
    omit?: QueueNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueNumberInclude<ExtArgs> | null
    /**
     * Filter, which QueueNumbers to fetch.
     */
    where?: QueueNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueNumbers to fetch.
     */
    orderBy?: QueueNumberOrderByWithRelationInput | QueueNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QueueNumbers.
     */
    cursor?: QueueNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueNumbers.
     */
    skip?: number
    distinct?: QueueNumberScalarFieldEnum | QueueNumberScalarFieldEnum[]
  }

  /**
   * QueueNumber create
   */
  export type QueueNumberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueNumber
     */
    select?: QueueNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueNumber
     */
    omit?: QueueNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueNumberInclude<ExtArgs> | null
    /**
     * The data needed to create a QueueNumber.
     */
    data: XOR<QueueNumberCreateInput, QueueNumberUncheckedCreateInput>
  }

  /**
   * QueueNumber createMany
   */
  export type QueueNumberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QueueNumbers.
     */
    data: QueueNumberCreateManyInput | QueueNumberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueueNumber update
   */
  export type QueueNumberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueNumber
     */
    select?: QueueNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueNumber
     */
    omit?: QueueNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueNumberInclude<ExtArgs> | null
    /**
     * The data needed to update a QueueNumber.
     */
    data: XOR<QueueNumberUpdateInput, QueueNumberUncheckedUpdateInput>
    /**
     * Choose, which QueueNumber to update.
     */
    where: QueueNumberWhereUniqueInput
  }

  /**
   * QueueNumber updateMany
   */
  export type QueueNumberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QueueNumbers.
     */
    data: XOR<QueueNumberUpdateManyMutationInput, QueueNumberUncheckedUpdateManyInput>
    /**
     * Filter which QueueNumbers to update
     */
    where?: QueueNumberWhereInput
    /**
     * Limit how many QueueNumbers to update.
     */
    limit?: number
  }

  /**
   * QueueNumber upsert
   */
  export type QueueNumberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueNumber
     */
    select?: QueueNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueNumber
     */
    omit?: QueueNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueNumberInclude<ExtArgs> | null
    /**
     * The filter to search for the QueueNumber to update in case it exists.
     */
    where: QueueNumberWhereUniqueInput
    /**
     * In case the QueueNumber found by the `where` argument doesn't exist, create a new QueueNumber with this data.
     */
    create: XOR<QueueNumberCreateInput, QueueNumberUncheckedCreateInput>
    /**
     * In case the QueueNumber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueNumberUpdateInput, QueueNumberUncheckedUpdateInput>
  }

  /**
   * QueueNumber delete
   */
  export type QueueNumberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueNumber
     */
    select?: QueueNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueNumber
     */
    omit?: QueueNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueNumberInclude<ExtArgs> | null
    /**
     * Filter which QueueNumber to delete.
     */
    where: QueueNumberWhereUniqueInput
  }

  /**
   * QueueNumber deleteMany
   */
  export type QueueNumberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueNumbers to delete
     */
    where?: QueueNumberWhereInput
    /**
     * Limit how many QueueNumbers to delete.
     */
    limit?: number
  }

  /**
   * QueueNumber without action
   */
  export type QueueNumberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueNumber
     */
    select?: QueueNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueNumber
     */
    omit?: QueueNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueNumberInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    title: string | null
    type: $Enums.ReportType | null
    description: string | null
    createdAt: Date | null
    startDate: Date | null
    endDate: Date | null
    pdfUrl: string | null
    createdById: string | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    title: string | null
    type: $Enums.ReportType | null
    description: string | null
    createdAt: Date | null
    startDate: Date | null
    endDate: Date | null
    pdfUrl: string | null
    createdById: string | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    title: number
    type: number
    description: number
    createdAt: number
    startDate: number
    endDate: number
    pdfUrl: number
    createdById: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    description?: true
    createdAt?: true
    startDate?: true
    endDate?: true
    pdfUrl?: true
    createdById?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    description?: true
    createdAt?: true
    startDate?: true
    endDate?: true
    pdfUrl?: true
    createdById?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    description?: true
    createdAt?: true
    startDate?: true
    endDate?: true
    pdfUrl?: true
    createdById?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    title: string
    type: $Enums.ReportType
    description: string | null
    createdAt: Date
    startDate: Date
    endDate: Date
    pdfUrl: string | null
    createdById: string
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    startDate?: boolean
    endDate?: boolean
    pdfUrl?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>



  export type ReportSelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    startDate?: boolean
    endDate?: boolean
    pdfUrl?: boolean
    createdById?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "type" | "description" | "createdAt" | "startDate" | "endDate" | "pdfUrl" | "createdById", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      type: $Enums.ReportType
      description: string | null
      createdAt: Date
      startDate: Date
      endDate: Date
      pdfUrl: string | null
      createdById: string
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly title: FieldRef<"Report", 'String'>
    readonly type: FieldRef<"Report", 'ReportType'>
    readonly description: FieldRef<"Report", 'String'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly startDate: FieldRef<"Report", 'DateTime'>
    readonly endDate: FieldRef<"Report", 'DateTime'>
    readonly pdfUrl: FieldRef<"Report", 'String'>
    readonly createdById: FieldRef<"Report", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseInvoice
   */

  export type AggregatePurchaseInvoice = {
    _count: PurchaseInvoiceCountAggregateOutputType | null
    _avg: PurchaseInvoiceAvgAggregateOutputType | null
    _sum: PurchaseInvoiceSumAggregateOutputType | null
    _min: PurchaseInvoiceMinAggregateOutputType | null
    _max: PurchaseInvoiceMaxAggregateOutputType | null
  }

  export type PurchaseInvoiceAvgAggregateOutputType = {
    totalAmount: number | null
    paidAmount: number | null
  }

  export type PurchaseInvoiceSumAggregateOutputType = {
    totalAmount: number | null
    paidAmount: number | null
  }

  export type PurchaseInvoiceMinAggregateOutputType = {
    id: string | null
    supplierName: string | null
    invoiceNumber: string | null
    totalAmount: number | null
    paidAmount: number | null
    isPaid: boolean | null
    invoiceDate: Date | null
    dueDate: Date | null
    notes: string | null
    createdById: string | null
  }

  export type PurchaseInvoiceMaxAggregateOutputType = {
    id: string | null
    supplierName: string | null
    invoiceNumber: string | null
    totalAmount: number | null
    paidAmount: number | null
    isPaid: boolean | null
    invoiceDate: Date | null
    dueDate: Date | null
    notes: string | null
    createdById: string | null
  }

  export type PurchaseInvoiceCountAggregateOutputType = {
    id: number
    supplierName: number
    invoiceNumber: number
    totalAmount: number
    paidAmount: number
    isPaid: number
    invoiceDate: number
    dueDate: number
    notes: number
    createdById: number
    _all: number
  }


  export type PurchaseInvoiceAvgAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type PurchaseInvoiceSumAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type PurchaseInvoiceMinAggregateInputType = {
    id?: true
    supplierName?: true
    invoiceNumber?: true
    totalAmount?: true
    paidAmount?: true
    isPaid?: true
    invoiceDate?: true
    dueDate?: true
    notes?: true
    createdById?: true
  }

  export type PurchaseInvoiceMaxAggregateInputType = {
    id?: true
    supplierName?: true
    invoiceNumber?: true
    totalAmount?: true
    paidAmount?: true
    isPaid?: true
    invoiceDate?: true
    dueDate?: true
    notes?: true
    createdById?: true
  }

  export type PurchaseInvoiceCountAggregateInputType = {
    id?: true
    supplierName?: true
    invoiceNumber?: true
    totalAmount?: true
    paidAmount?: true
    isPaid?: true
    invoiceDate?: true
    dueDate?: true
    notes?: true
    createdById?: true
    _all?: true
  }

  export type PurchaseInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoice to aggregate.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseInvoices
    **/
    _count?: true | PurchaseInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseInvoiceMaxAggregateInputType
  }

  export type GetPurchaseInvoiceAggregateType<T extends PurchaseInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseInvoice[P]>
      : GetScalarType<T[P], AggregatePurchaseInvoice[P]>
  }




  export type PurchaseInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithAggregationInput | PurchaseInvoiceOrderByWithAggregationInput[]
    by: PurchaseInvoiceScalarFieldEnum[] | PurchaseInvoiceScalarFieldEnum
    having?: PurchaseInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseInvoiceCountAggregateInputType | true
    _avg?: PurchaseInvoiceAvgAggregateInputType
    _sum?: PurchaseInvoiceSumAggregateInputType
    _min?: PurchaseInvoiceMinAggregateInputType
    _max?: PurchaseInvoiceMaxAggregateInputType
  }

  export type PurchaseInvoiceGroupByOutputType = {
    id: string
    supplierName: string
    invoiceNumber: string | null
    totalAmount: number
    paidAmount: number
    isPaid: boolean
    invoiceDate: Date
    dueDate: Date | null
    notes: string | null
    createdById: string
    _count: PurchaseInvoiceCountAggregateOutputType | null
    _avg: PurchaseInvoiceAvgAggregateOutputType | null
    _sum: PurchaseInvoiceSumAggregateOutputType | null
    _min: PurchaseInvoiceMinAggregateOutputType | null
    _max: PurchaseInvoiceMaxAggregateOutputType | null
  }

  type GetPurchaseInvoiceGroupByPayload<T extends PurchaseInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierName?: boolean
    invoiceNumber?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    isPaid?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    notes?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | PurchaseInvoice$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoice"]>



  export type PurchaseInvoiceSelectScalar = {
    id?: boolean
    supplierName?: boolean
    invoiceNumber?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    isPaid?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    notes?: boolean
    createdById?: boolean
  }

  export type PurchaseInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplierName" | "invoiceNumber" | "totalAmount" | "paidAmount" | "isPaid" | "invoiceDate" | "dueDate" | "notes" | "createdById", ExtArgs["result"]["purchaseInvoice"]>
  export type PurchaseInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | PurchaseInvoice$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PurchaseInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseInvoice"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplierName: string
      invoiceNumber: string | null
      totalAmount: number
      paidAmount: number
      isPaid: boolean
      invoiceDate: Date
      dueDate: Date | null
      notes: string | null
      createdById: string
    }, ExtArgs["result"]["purchaseInvoice"]>
    composites: {}
  }

  type PurchaseInvoiceGetPayload<S extends boolean | null | undefined | PurchaseInvoiceDefaultArgs> = $Result.GetResult<Prisma.$PurchaseInvoicePayload, S>

  type PurchaseInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseInvoiceCountAggregateInputType | true
    }

  export interface PurchaseInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseInvoice'], meta: { name: 'PurchaseInvoice' } }
    /**
     * Find zero or one PurchaseInvoice that matches the filter.
     * @param {PurchaseInvoiceFindUniqueArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseInvoiceFindUniqueArgs>(args: SelectSubset<T, PurchaseInvoiceFindUniqueArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseInvoiceFindUniqueOrThrowArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindFirstArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseInvoiceFindFirstArgs>(args?: SelectSubset<T, PurchaseInvoiceFindFirstArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindFirstOrThrowArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseInvoices
     * const purchaseInvoices = await prisma.purchaseInvoice.findMany()
     * 
     * // Get first 10 PurchaseInvoices
     * const purchaseInvoices = await prisma.purchaseInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseInvoiceWithIdOnly = await prisma.purchaseInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseInvoiceFindManyArgs>(args?: SelectSubset<T, PurchaseInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseInvoice.
     * @param {PurchaseInvoiceCreateArgs} args - Arguments to create a PurchaseInvoice.
     * @example
     * // Create one PurchaseInvoice
     * const PurchaseInvoice = await prisma.purchaseInvoice.create({
     *   data: {
     *     // ... data to create a PurchaseInvoice
     *   }
     * })
     * 
     */
    create<T extends PurchaseInvoiceCreateArgs>(args: SelectSubset<T, PurchaseInvoiceCreateArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseInvoices.
     * @param {PurchaseInvoiceCreateManyArgs} args - Arguments to create many PurchaseInvoices.
     * @example
     * // Create many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseInvoiceCreateManyArgs>(args?: SelectSubset<T, PurchaseInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseInvoice.
     * @param {PurchaseInvoiceDeleteArgs} args - Arguments to delete one PurchaseInvoice.
     * @example
     * // Delete one PurchaseInvoice
     * const PurchaseInvoice = await prisma.purchaseInvoice.delete({
     *   where: {
     *     // ... filter to delete one PurchaseInvoice
     *   }
     * })
     * 
     */
    delete<T extends PurchaseInvoiceDeleteArgs>(args: SelectSubset<T, PurchaseInvoiceDeleteArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseInvoice.
     * @param {PurchaseInvoiceUpdateArgs} args - Arguments to update one PurchaseInvoice.
     * @example
     * // Update one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseInvoiceUpdateArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseInvoices.
     * @param {PurchaseInvoiceDeleteManyArgs} args - Arguments to filter PurchaseInvoices to delete.
     * @example
     * // Delete a few PurchaseInvoices
     * const { count } = await prisma.purchaseInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseInvoiceDeleteManyArgs>(args?: SelectSubset<T, PurchaseInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseInvoiceUpdateManyArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseInvoice.
     * @param {PurchaseInvoiceUpsertArgs} args - Arguments to update or create a PurchaseInvoice.
     * @example
     * // Update or create a PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.upsert({
     *   create: {
     *     // ... data to create a PurchaseInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseInvoice we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseInvoiceUpsertArgs>(args: SelectSubset<T, PurchaseInvoiceUpsertArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceCountArgs} args - Arguments to filter PurchaseInvoices to count.
     * @example
     * // Count the number of PurchaseInvoices
     * const count = await prisma.purchaseInvoice.count({
     *   where: {
     *     // ... the filter for the PurchaseInvoices we want to count
     *   }
     * })
    **/
    count<T extends PurchaseInvoiceCountArgs>(
      args?: Subset<T, PurchaseInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseInvoiceAggregateArgs>(args: Subset<T, PurchaseInvoiceAggregateArgs>): Prisma.PrismaPromise<GetPurchaseInvoiceAggregateType<T>>

    /**
     * Group by PurchaseInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseInvoice model
   */
  readonly fields: PurchaseInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends PurchaseInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseInvoice model
   */
  interface PurchaseInvoiceFieldRefs {
    readonly id: FieldRef<"PurchaseInvoice", 'String'>
    readonly supplierName: FieldRef<"PurchaseInvoice", 'String'>
    readonly invoiceNumber: FieldRef<"PurchaseInvoice", 'String'>
    readonly totalAmount: FieldRef<"PurchaseInvoice", 'Float'>
    readonly paidAmount: FieldRef<"PurchaseInvoice", 'Float'>
    readonly isPaid: FieldRef<"PurchaseInvoice", 'Boolean'>
    readonly invoiceDate: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly dueDate: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly notes: FieldRef<"PurchaseInvoice", 'String'>
    readonly createdById: FieldRef<"PurchaseInvoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseInvoice findUnique
   */
  export type PurchaseInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice findUniqueOrThrow
   */
  export type PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice findFirst
   */
  export type PurchaseInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoices.
     */
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice findFirstOrThrow
   */
  export type PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoices.
     */
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice findMany
   */
  export type PurchaseInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoices to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice create
   */
  export type PurchaseInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseInvoice.
     */
    data: XOR<PurchaseInvoiceCreateInput, PurchaseInvoiceUncheckedCreateInput>
  }

  /**
   * PurchaseInvoice createMany
   */
  export type PurchaseInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseInvoices.
     */
    data: PurchaseInvoiceCreateManyInput | PurchaseInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseInvoice update
   */
  export type PurchaseInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseInvoice.
     */
    data: XOR<PurchaseInvoiceUpdateInput, PurchaseInvoiceUncheckedUpdateInput>
    /**
     * Choose, which PurchaseInvoice to update.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice updateMany
   */
  export type PurchaseInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseInvoices.
     */
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoices to update
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to update.
     */
    limit?: number
  }

  /**
   * PurchaseInvoice upsert
   */
  export type PurchaseInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseInvoice to update in case it exists.
     */
    where: PurchaseInvoiceWhereUniqueInput
    /**
     * In case the PurchaseInvoice found by the `where` argument doesn't exist, create a new PurchaseInvoice with this data.
     */
    create: XOR<PurchaseInvoiceCreateInput, PurchaseInvoiceUncheckedCreateInput>
    /**
     * In case the PurchaseInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseInvoiceUpdateInput, PurchaseInvoiceUncheckedUpdateInput>
  }

  /**
   * PurchaseInvoice delete
   */
  export type PurchaseInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter which PurchaseInvoice to delete.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice deleteMany
   */
  export type PurchaseInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoices to delete
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to delete.
     */
    limit?: number
  }

  /**
   * PurchaseInvoice.items
   */
  export type PurchaseInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice without action
   */
  export type PurchaseInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseInvoiceItem
   */

  export type AggregatePurchaseInvoiceItem = {
    _count: PurchaseInvoiceItemCountAggregateOutputType | null
    _avg: PurchaseInvoiceItemAvgAggregateOutputType | null
    _sum: PurchaseInvoiceItemSumAggregateOutputType | null
    _min: PurchaseInvoiceItemMinAggregateOutputType | null
    _max: PurchaseInvoiceItemMaxAggregateOutputType | null
  }

  export type PurchaseInvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
  }

  export type PurchaseInvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
  }

  export type PurchaseInvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    itemName: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
  }

  export type PurchaseInvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    itemName: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
  }

  export type PurchaseInvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    itemName: number
    description: number
    quantity: number
    unitPrice: number
    subtotal: number
    _all: number
  }


  export type PurchaseInvoiceItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type PurchaseInvoiceItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type PurchaseInvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    itemName?: true
    description?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type PurchaseInvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    itemName?: true
    description?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type PurchaseInvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    itemName?: true
    description?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    _all?: true
  }

  export type PurchaseInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoiceItem to aggregate.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseInvoiceItems
    **/
    _count?: true | PurchaseInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseInvoiceItemMaxAggregateInputType
  }

  export type GetPurchaseInvoiceItemAggregateType<T extends PurchaseInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseInvoiceItem[P]>
      : GetScalarType<T[P], AggregatePurchaseInvoiceItem[P]>
  }




  export type PurchaseInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithAggregationInput | PurchaseInvoiceItemOrderByWithAggregationInput[]
    by: PurchaseInvoiceItemScalarFieldEnum[] | PurchaseInvoiceItemScalarFieldEnum
    having?: PurchaseInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseInvoiceItemCountAggregateInputType | true
    _avg?: PurchaseInvoiceItemAvgAggregateInputType
    _sum?: PurchaseInvoiceItemSumAggregateInputType
    _min?: PurchaseInvoiceItemMinAggregateInputType
    _max?: PurchaseInvoiceItemMaxAggregateInputType
  }

  export type PurchaseInvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    itemName: string
    description: string | null
    quantity: number
    unitPrice: number
    subtotal: number
    _count: PurchaseInvoiceItemCountAggregateOutputType | null
    _avg: PurchaseInvoiceItemAvgAggregateOutputType | null
    _sum: PurchaseInvoiceItemSumAggregateOutputType | null
    _min: PurchaseInvoiceItemMinAggregateOutputType | null
    _max: PurchaseInvoiceItemMaxAggregateOutputType | null
  }

  type GetPurchaseInvoiceItemGroupByPayload<T extends PurchaseInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemName?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    invoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoiceItem"]>



  export type PurchaseInvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    itemName?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
  }

  export type PurchaseInvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "itemName" | "description" | "quantity" | "unitPrice" | "subtotal", ExtArgs["result"]["purchaseInvoiceItem"]>
  export type PurchaseInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
  }

  export type $PurchaseInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseInvoiceItem"
    objects: {
      invoice: Prisma.$PurchaseInvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      itemName: string
      description: string | null
      quantity: number
      unitPrice: number
      subtotal: number
    }, ExtArgs["result"]["purchaseInvoiceItem"]>
    composites: {}
  }

  type PurchaseInvoiceItemGetPayload<S extends boolean | null | undefined | PurchaseInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseInvoiceItemPayload, S>

  type PurchaseInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseInvoiceItemCountAggregateInputType | true
    }

  export interface PurchaseInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseInvoiceItem'], meta: { name: 'PurchaseInvoiceItem' } }
    /**
     * Find zero or one PurchaseInvoiceItem that matches the filter.
     * @param {PurchaseInvoiceItemFindUniqueArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseInvoiceItemFindUniqueArgs>(args: SelectSubset<T, PurchaseInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseInvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemFindFirstArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseInvoiceItemFindFirstArgs>(args?: SelectSubset<T, PurchaseInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseInvoiceItems
     * const purchaseInvoiceItems = await prisma.purchaseInvoiceItem.findMany()
     * 
     * // Get first 10 PurchaseInvoiceItems
     * const purchaseInvoiceItems = await prisma.purchaseInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseInvoiceItemWithIdOnly = await prisma.purchaseInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseInvoiceItemFindManyArgs>(args?: SelectSubset<T, PurchaseInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemCreateArgs} args - Arguments to create a PurchaseInvoiceItem.
     * @example
     * // Create one PurchaseInvoiceItem
     * const PurchaseInvoiceItem = await prisma.purchaseInvoiceItem.create({
     *   data: {
     *     // ... data to create a PurchaseInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseInvoiceItemCreateArgs>(args: SelectSubset<T, PurchaseInvoiceItemCreateArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseInvoiceItems.
     * @param {PurchaseInvoiceItemCreateManyArgs} args - Arguments to create many PurchaseInvoiceItems.
     * @example
     * // Create many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseInvoiceItemCreateManyArgs>(args?: SelectSubset<T, PurchaseInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemDeleteArgs} args - Arguments to delete one PurchaseInvoiceItem.
     * @example
     * // Delete one PurchaseInvoiceItem
     * const PurchaseInvoiceItem = await prisma.purchaseInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseInvoiceItemDeleteArgs>(args: SelectSubset<T, PurchaseInvoiceItemDeleteArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemUpdateArgs} args - Arguments to update one PurchaseInvoiceItem.
     * @example
     * // Update one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseInvoiceItemUpdateArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpdateArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseInvoiceItems.
     * @param {PurchaseInvoiceItemDeleteManyArgs} args - Arguments to filter PurchaseInvoiceItems to delete.
     * @example
     * // Delete a few PurchaseInvoiceItems
     * const { count } = await prisma.purchaseInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseInvoiceItemUpdateManyArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemUpsertArgs} args - Arguments to update or create a PurchaseInvoiceItem.
     * @example
     * // Update or create a PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseInvoiceItemUpsertArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpsertArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemCountArgs} args - Arguments to filter PurchaseInvoiceItems to count.
     * @example
     * // Count the number of PurchaseInvoiceItems
     * const count = await prisma.purchaseInvoiceItem.count({
     *   where: {
     *     // ... the filter for the PurchaseInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseInvoiceItemCountArgs>(
      args?: Subset<T, PurchaseInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseInvoiceItemAggregateArgs>(args: Subset<T, PurchaseInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseInvoiceItemAggregateType<T>>

    /**
     * Group by PurchaseInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseInvoiceItem model
   */
  readonly fields: PurchaseInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends PurchaseInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoiceDefaultArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseInvoiceItem model
   */
  interface PurchaseInvoiceItemFieldRefs {
    readonly id: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly itemName: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly description: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly quantity: FieldRef<"PurchaseInvoiceItem", 'Int'>
    readonly unitPrice: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly subtotal: FieldRef<"PurchaseInvoiceItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseInvoiceItem findUnique
   */
  export type PurchaseInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem findUniqueOrThrow
   */
  export type PurchaseInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem findFirst
   */
  export type PurchaseInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoiceItems.
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoiceItems.
     */
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoiceItem findFirstOrThrow
   */
  export type PurchaseInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoiceItems.
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoiceItems.
     */
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoiceItem findMany
   */
  export type PurchaseInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItems to fetch.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseInvoiceItems.
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoiceItem create
   */
  export type PurchaseInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseInvoiceItem.
     */
    data: XOR<PurchaseInvoiceItemCreateInput, PurchaseInvoiceItemUncheckedCreateInput>
  }

  /**
   * PurchaseInvoiceItem createMany
   */
  export type PurchaseInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseInvoiceItems.
     */
    data: PurchaseInvoiceItemCreateManyInput | PurchaseInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseInvoiceItem update
   */
  export type PurchaseInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseInvoiceItem.
     */
    data: XOR<PurchaseInvoiceItemUpdateInput, PurchaseInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseInvoiceItem to update.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem updateMany
   */
  export type PurchaseInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseInvoiceItems.
     */
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoiceItems to update
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * Limit how many PurchaseInvoiceItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseInvoiceItem upsert
   */
  export type PurchaseInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseInvoiceItem to update in case it exists.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
    /**
     * In case the PurchaseInvoiceItem found by the `where` argument doesn't exist, create a new PurchaseInvoiceItem with this data.
     */
    create: XOR<PurchaseInvoiceItemCreateInput, PurchaseInvoiceItemUncheckedCreateInput>
    /**
     * In case the PurchaseInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseInvoiceItemUpdateInput, PurchaseInvoiceItemUncheckedUpdateInput>
  }

  /**
   * PurchaseInvoiceItem delete
   */
  export type PurchaseInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseInvoiceItem to delete.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem deleteMany
   */
  export type PurchaseInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoiceItems to delete
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * Limit how many PurchaseInvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseInvoiceItem without action
   */
  export type PurchaseInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model RadiationResult
   */

  export type AggregateRadiationResult = {
    _count: RadiationResultCountAggregateOutputType | null
    _min: RadiationResultMinAggregateOutputType | null
    _max: RadiationResultMaxAggregateOutputType | null
  }

  export type RadiationResultMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    resultDetails: string | null
    reportText: string | null
    imageUrl: string | null
    pdfUrl: string | null
    patientId: string | null
    testAssignmentId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RadiationResultMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    resultDetails: string | null
    reportText: string | null
    imageUrl: string | null
    pdfUrl: string | null
    patientId: string | null
    testAssignmentId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RadiationResultCountAggregateOutputType = {
    id: number
    title: number
    description: number
    resultDetails: number
    reportText: number
    imageUrl: number
    pdfUrl: number
    patientId: number
    testAssignmentId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RadiationResultMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    resultDetails?: true
    reportText?: true
    imageUrl?: true
    pdfUrl?: true
    patientId?: true
    testAssignmentId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RadiationResultMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    resultDetails?: true
    reportText?: true
    imageUrl?: true
    pdfUrl?: true
    patientId?: true
    testAssignmentId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RadiationResultCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    resultDetails?: true
    reportText?: true
    imageUrl?: true
    pdfUrl?: true
    patientId?: true
    testAssignmentId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RadiationResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RadiationResult to aggregate.
     */
    where?: RadiationResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiationResults to fetch.
     */
    orderBy?: RadiationResultOrderByWithRelationInput | RadiationResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RadiationResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiationResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiationResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RadiationResults
    **/
    _count?: true | RadiationResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RadiationResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RadiationResultMaxAggregateInputType
  }

  export type GetRadiationResultAggregateType<T extends RadiationResultAggregateArgs> = {
        [P in keyof T & keyof AggregateRadiationResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRadiationResult[P]>
      : GetScalarType<T[P], AggregateRadiationResult[P]>
  }




  export type RadiationResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiationResultWhereInput
    orderBy?: RadiationResultOrderByWithAggregationInput | RadiationResultOrderByWithAggregationInput[]
    by: RadiationResultScalarFieldEnum[] | RadiationResultScalarFieldEnum
    having?: RadiationResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RadiationResultCountAggregateInputType | true
    _min?: RadiationResultMinAggregateInputType
    _max?: RadiationResultMaxAggregateInputType
  }

  export type RadiationResultGroupByOutputType = {
    id: string
    title: string
    description: string | null
    resultDetails: string
    reportText: string | null
    imageUrl: string | null
    pdfUrl: string | null
    patientId: string
    testAssignmentId: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: RadiationResultCountAggregateOutputType | null
    _min: RadiationResultMinAggregateOutputType | null
    _max: RadiationResultMaxAggregateOutputType | null
  }

  type GetRadiationResultGroupByPayload<T extends RadiationResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RadiationResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RadiationResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RadiationResultGroupByOutputType[P]>
            : GetScalarType<T[P], RadiationResultGroupByOutputType[P]>
        }
      >
    >


  export type RadiationResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    resultDetails?: boolean
    reportText?: boolean
    imageUrl?: boolean
    pdfUrl?: boolean
    patientId?: boolean
    testAssignmentId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    testAssignment?: boolean | TestAssignmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["radiationResult"]>



  export type RadiationResultSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    resultDetails?: boolean
    reportText?: boolean
    imageUrl?: boolean
    pdfUrl?: boolean
    patientId?: boolean
    testAssignmentId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RadiationResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "resultDetails" | "reportText" | "imageUrl" | "pdfUrl" | "patientId" | "testAssignmentId" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["radiationResult"]>
  export type RadiationResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    testAssignment?: boolean | TestAssignmentDefaultArgs<ExtArgs>
  }

  export type $RadiationResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RadiationResult"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      testAssignment: Prisma.$TestAssignmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      resultDetails: string
      reportText: string | null
      imageUrl: string | null
      pdfUrl: string | null
      patientId: string
      testAssignmentId: string
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["radiationResult"]>
    composites: {}
  }

  type RadiationResultGetPayload<S extends boolean | null | undefined | RadiationResultDefaultArgs> = $Result.GetResult<Prisma.$RadiationResultPayload, S>

  type RadiationResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RadiationResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RadiationResultCountAggregateInputType | true
    }

  export interface RadiationResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RadiationResult'], meta: { name: 'RadiationResult' } }
    /**
     * Find zero or one RadiationResult that matches the filter.
     * @param {RadiationResultFindUniqueArgs} args - Arguments to find a RadiationResult
     * @example
     * // Get one RadiationResult
     * const radiationResult = await prisma.radiationResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RadiationResultFindUniqueArgs>(args: SelectSubset<T, RadiationResultFindUniqueArgs<ExtArgs>>): Prisma__RadiationResultClient<$Result.GetResult<Prisma.$RadiationResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RadiationResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RadiationResultFindUniqueOrThrowArgs} args - Arguments to find a RadiationResult
     * @example
     * // Get one RadiationResult
     * const radiationResult = await prisma.radiationResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RadiationResultFindUniqueOrThrowArgs>(args: SelectSubset<T, RadiationResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RadiationResultClient<$Result.GetResult<Prisma.$RadiationResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RadiationResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationResultFindFirstArgs} args - Arguments to find a RadiationResult
     * @example
     * // Get one RadiationResult
     * const radiationResult = await prisma.radiationResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RadiationResultFindFirstArgs>(args?: SelectSubset<T, RadiationResultFindFirstArgs<ExtArgs>>): Prisma__RadiationResultClient<$Result.GetResult<Prisma.$RadiationResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RadiationResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationResultFindFirstOrThrowArgs} args - Arguments to find a RadiationResult
     * @example
     * // Get one RadiationResult
     * const radiationResult = await prisma.radiationResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RadiationResultFindFirstOrThrowArgs>(args?: SelectSubset<T, RadiationResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__RadiationResultClient<$Result.GetResult<Prisma.$RadiationResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RadiationResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RadiationResults
     * const radiationResults = await prisma.radiationResult.findMany()
     * 
     * // Get first 10 RadiationResults
     * const radiationResults = await prisma.radiationResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const radiationResultWithIdOnly = await prisma.radiationResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RadiationResultFindManyArgs>(args?: SelectSubset<T, RadiationResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiationResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RadiationResult.
     * @param {RadiationResultCreateArgs} args - Arguments to create a RadiationResult.
     * @example
     * // Create one RadiationResult
     * const RadiationResult = await prisma.radiationResult.create({
     *   data: {
     *     // ... data to create a RadiationResult
     *   }
     * })
     * 
     */
    create<T extends RadiationResultCreateArgs>(args: SelectSubset<T, RadiationResultCreateArgs<ExtArgs>>): Prisma__RadiationResultClient<$Result.GetResult<Prisma.$RadiationResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RadiationResults.
     * @param {RadiationResultCreateManyArgs} args - Arguments to create many RadiationResults.
     * @example
     * // Create many RadiationResults
     * const radiationResult = await prisma.radiationResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RadiationResultCreateManyArgs>(args?: SelectSubset<T, RadiationResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RadiationResult.
     * @param {RadiationResultDeleteArgs} args - Arguments to delete one RadiationResult.
     * @example
     * // Delete one RadiationResult
     * const RadiationResult = await prisma.radiationResult.delete({
     *   where: {
     *     // ... filter to delete one RadiationResult
     *   }
     * })
     * 
     */
    delete<T extends RadiationResultDeleteArgs>(args: SelectSubset<T, RadiationResultDeleteArgs<ExtArgs>>): Prisma__RadiationResultClient<$Result.GetResult<Prisma.$RadiationResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RadiationResult.
     * @param {RadiationResultUpdateArgs} args - Arguments to update one RadiationResult.
     * @example
     * // Update one RadiationResult
     * const radiationResult = await prisma.radiationResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RadiationResultUpdateArgs>(args: SelectSubset<T, RadiationResultUpdateArgs<ExtArgs>>): Prisma__RadiationResultClient<$Result.GetResult<Prisma.$RadiationResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RadiationResults.
     * @param {RadiationResultDeleteManyArgs} args - Arguments to filter RadiationResults to delete.
     * @example
     * // Delete a few RadiationResults
     * const { count } = await prisma.radiationResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RadiationResultDeleteManyArgs>(args?: SelectSubset<T, RadiationResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RadiationResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RadiationResults
     * const radiationResult = await prisma.radiationResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RadiationResultUpdateManyArgs>(args: SelectSubset<T, RadiationResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RadiationResult.
     * @param {RadiationResultUpsertArgs} args - Arguments to update or create a RadiationResult.
     * @example
     * // Update or create a RadiationResult
     * const radiationResult = await prisma.radiationResult.upsert({
     *   create: {
     *     // ... data to create a RadiationResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RadiationResult we want to update
     *   }
     * })
     */
    upsert<T extends RadiationResultUpsertArgs>(args: SelectSubset<T, RadiationResultUpsertArgs<ExtArgs>>): Prisma__RadiationResultClient<$Result.GetResult<Prisma.$RadiationResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RadiationResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationResultCountArgs} args - Arguments to filter RadiationResults to count.
     * @example
     * // Count the number of RadiationResults
     * const count = await prisma.radiationResult.count({
     *   where: {
     *     // ... the filter for the RadiationResults we want to count
     *   }
     * })
    **/
    count<T extends RadiationResultCountArgs>(
      args?: Subset<T, RadiationResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RadiationResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RadiationResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RadiationResultAggregateArgs>(args: Subset<T, RadiationResultAggregateArgs>): Prisma.PrismaPromise<GetRadiationResultAggregateType<T>>

    /**
     * Group by RadiationResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RadiationResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RadiationResultGroupByArgs['orderBy'] }
        : { orderBy?: RadiationResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RadiationResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRadiationResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RadiationResult model
   */
  readonly fields: RadiationResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RadiationResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RadiationResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    testAssignment<T extends TestAssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestAssignmentDefaultArgs<ExtArgs>>): Prisma__TestAssignmentClient<$Result.GetResult<Prisma.$TestAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RadiationResult model
   */
  interface RadiationResultFieldRefs {
    readonly id: FieldRef<"RadiationResult", 'String'>
    readonly title: FieldRef<"RadiationResult", 'String'>
    readonly description: FieldRef<"RadiationResult", 'String'>
    readonly resultDetails: FieldRef<"RadiationResult", 'String'>
    readonly reportText: FieldRef<"RadiationResult", 'String'>
    readonly imageUrl: FieldRef<"RadiationResult", 'String'>
    readonly pdfUrl: FieldRef<"RadiationResult", 'String'>
    readonly patientId: FieldRef<"RadiationResult", 'String'>
    readonly testAssignmentId: FieldRef<"RadiationResult", 'String'>
    readonly createdById: FieldRef<"RadiationResult", 'String'>
    readonly createdAt: FieldRef<"RadiationResult", 'DateTime'>
    readonly updatedAt: FieldRef<"RadiationResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RadiationResult findUnique
   */
  export type RadiationResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationResult
     */
    select?: RadiationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationResult
     */
    omit?: RadiationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationResultInclude<ExtArgs> | null
    /**
     * Filter, which RadiationResult to fetch.
     */
    where: RadiationResultWhereUniqueInput
  }

  /**
   * RadiationResult findUniqueOrThrow
   */
  export type RadiationResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationResult
     */
    select?: RadiationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationResult
     */
    omit?: RadiationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationResultInclude<ExtArgs> | null
    /**
     * Filter, which RadiationResult to fetch.
     */
    where: RadiationResultWhereUniqueInput
  }

  /**
   * RadiationResult findFirst
   */
  export type RadiationResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationResult
     */
    select?: RadiationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationResult
     */
    omit?: RadiationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationResultInclude<ExtArgs> | null
    /**
     * Filter, which RadiationResult to fetch.
     */
    where?: RadiationResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiationResults to fetch.
     */
    orderBy?: RadiationResultOrderByWithRelationInput | RadiationResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RadiationResults.
     */
    cursor?: RadiationResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiationResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiationResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RadiationResults.
     */
    distinct?: RadiationResultScalarFieldEnum | RadiationResultScalarFieldEnum[]
  }

  /**
   * RadiationResult findFirstOrThrow
   */
  export type RadiationResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationResult
     */
    select?: RadiationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationResult
     */
    omit?: RadiationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationResultInclude<ExtArgs> | null
    /**
     * Filter, which RadiationResult to fetch.
     */
    where?: RadiationResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiationResults to fetch.
     */
    orderBy?: RadiationResultOrderByWithRelationInput | RadiationResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RadiationResults.
     */
    cursor?: RadiationResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiationResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiationResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RadiationResults.
     */
    distinct?: RadiationResultScalarFieldEnum | RadiationResultScalarFieldEnum[]
  }

  /**
   * RadiationResult findMany
   */
  export type RadiationResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationResult
     */
    select?: RadiationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationResult
     */
    omit?: RadiationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationResultInclude<ExtArgs> | null
    /**
     * Filter, which RadiationResults to fetch.
     */
    where?: RadiationResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiationResults to fetch.
     */
    orderBy?: RadiationResultOrderByWithRelationInput | RadiationResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RadiationResults.
     */
    cursor?: RadiationResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiationResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiationResults.
     */
    skip?: number
    distinct?: RadiationResultScalarFieldEnum | RadiationResultScalarFieldEnum[]
  }

  /**
   * RadiationResult create
   */
  export type RadiationResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationResult
     */
    select?: RadiationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationResult
     */
    omit?: RadiationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationResultInclude<ExtArgs> | null
    /**
     * The data needed to create a RadiationResult.
     */
    data: XOR<RadiationResultCreateInput, RadiationResultUncheckedCreateInput>
  }

  /**
   * RadiationResult createMany
   */
  export type RadiationResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RadiationResults.
     */
    data: RadiationResultCreateManyInput | RadiationResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RadiationResult update
   */
  export type RadiationResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationResult
     */
    select?: RadiationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationResult
     */
    omit?: RadiationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationResultInclude<ExtArgs> | null
    /**
     * The data needed to update a RadiationResult.
     */
    data: XOR<RadiationResultUpdateInput, RadiationResultUncheckedUpdateInput>
    /**
     * Choose, which RadiationResult to update.
     */
    where: RadiationResultWhereUniqueInput
  }

  /**
   * RadiationResult updateMany
   */
  export type RadiationResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RadiationResults.
     */
    data: XOR<RadiationResultUpdateManyMutationInput, RadiationResultUncheckedUpdateManyInput>
    /**
     * Filter which RadiationResults to update
     */
    where?: RadiationResultWhereInput
    /**
     * Limit how many RadiationResults to update.
     */
    limit?: number
  }

  /**
   * RadiationResult upsert
   */
  export type RadiationResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationResult
     */
    select?: RadiationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationResult
     */
    omit?: RadiationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationResultInclude<ExtArgs> | null
    /**
     * The filter to search for the RadiationResult to update in case it exists.
     */
    where: RadiationResultWhereUniqueInput
    /**
     * In case the RadiationResult found by the `where` argument doesn't exist, create a new RadiationResult with this data.
     */
    create: XOR<RadiationResultCreateInput, RadiationResultUncheckedCreateInput>
    /**
     * In case the RadiationResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RadiationResultUpdateInput, RadiationResultUncheckedUpdateInput>
  }

  /**
   * RadiationResult delete
   */
  export type RadiationResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationResult
     */
    select?: RadiationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationResult
     */
    omit?: RadiationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationResultInclude<ExtArgs> | null
    /**
     * Filter which RadiationResult to delete.
     */
    where: RadiationResultWhereUniqueInput
  }

  /**
   * RadiationResult deleteMany
   */
  export type RadiationResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RadiationResults to delete
     */
    where?: RadiationResultWhereInput
    /**
     * Limit how many RadiationResults to delete.
     */
    limit?: number
  }

  /**
   * RadiationResult without action
   */
  export type RadiationResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationResult
     */
    select?: RadiationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationResult
     */
    omit?: RadiationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationResultInclude<ExtArgs> | null
  }


  /**
   * Model LabMaterial
   */

  export type AggregateLabMaterial = {
    _count: LabMaterialCountAggregateOutputType | null
    _avg: LabMaterialAvgAggregateOutputType | null
    _sum: LabMaterialSumAggregateOutputType | null
    _min: LabMaterialMinAggregateOutputType | null
    _max: LabMaterialMaxAggregateOutputType | null
  }

  export type LabMaterialAvgAggregateOutputType = {
    currentQuantity: number | null
    minimumQuantity: number | null
    price: number | null
  }

  export type LabMaterialSumAggregateOutputType = {
    currentQuantity: number | null
    minimumQuantity: number | null
    price: number | null
  }

  export type LabMaterialMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    category: $Enums.MaterialCategory | null
    description: string | null
    unit: string | null
    currentQuantity: number | null
    minimumQuantity: number | null
    price: number | null
    supplier: string | null
    expiryDate: Date | null
    location: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type LabMaterialMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    category: $Enums.MaterialCategory | null
    description: string | null
    unit: string | null
    currentQuantity: number | null
    minimumQuantity: number | null
    price: number | null
    supplier: string | null
    expiryDate: Date | null
    location: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type LabMaterialCountAggregateOutputType = {
    id: number
    name: number
    code: number
    category: number
    description: number
    unit: number
    currentQuantity: number
    minimumQuantity: number
    price: number
    supplier: number
    expiryDate: number
    location: number
    notes: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type LabMaterialAvgAggregateInputType = {
    currentQuantity?: true
    minimumQuantity?: true
    price?: true
  }

  export type LabMaterialSumAggregateInputType = {
    currentQuantity?: true
    minimumQuantity?: true
    price?: true
  }

  export type LabMaterialMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    category?: true
    description?: true
    unit?: true
    currentQuantity?: true
    minimumQuantity?: true
    price?: true
    supplier?: true
    expiryDate?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type LabMaterialMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    category?: true
    description?: true
    unit?: true
    currentQuantity?: true
    minimumQuantity?: true
    price?: true
    supplier?: true
    expiryDate?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type LabMaterialCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    category?: true
    description?: true
    unit?: true
    currentQuantity?: true
    minimumQuantity?: true
    price?: true
    supplier?: true
    expiryDate?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type LabMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabMaterial to aggregate.
     */
    where?: LabMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabMaterials to fetch.
     */
    orderBy?: LabMaterialOrderByWithRelationInput | LabMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabMaterials
    **/
    _count?: true | LabMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabMaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabMaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabMaterialMaxAggregateInputType
  }

  export type GetLabMaterialAggregateType<T extends LabMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateLabMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabMaterial[P]>
      : GetScalarType<T[P], AggregateLabMaterial[P]>
  }




  export type LabMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabMaterialWhereInput
    orderBy?: LabMaterialOrderByWithAggregationInput | LabMaterialOrderByWithAggregationInput[]
    by: LabMaterialScalarFieldEnum[] | LabMaterialScalarFieldEnum
    having?: LabMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabMaterialCountAggregateInputType | true
    _avg?: LabMaterialAvgAggregateInputType
    _sum?: LabMaterialSumAggregateInputType
    _min?: LabMaterialMinAggregateInputType
    _max?: LabMaterialMaxAggregateInputType
  }

  export type LabMaterialGroupByOutputType = {
    id: string
    name: string
    code: string | null
    category: $Enums.MaterialCategory
    description: string | null
    unit: string
    currentQuantity: number
    minimumQuantity: number
    price: number | null
    supplier: string | null
    expiryDate: Date | null
    location: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    _count: LabMaterialCountAggregateOutputType | null
    _avg: LabMaterialAvgAggregateOutputType | null
    _sum: LabMaterialSumAggregateOutputType | null
    _min: LabMaterialMinAggregateOutputType | null
    _max: LabMaterialMaxAggregateOutputType | null
  }

  type GetLabMaterialGroupByPayload<T extends LabMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], LabMaterialGroupByOutputType[P]>
        }
      >
    >


  export type LabMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    category?: boolean
    description?: boolean
    unit?: boolean
    currentQuantity?: boolean
    minimumQuantity?: boolean
    price?: boolean
    supplier?: boolean
    expiryDate?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | LabMaterial$createdByArgs<ExtArgs>
    transactions?: boolean | LabMaterial$transactionsArgs<ExtArgs>
    _count?: boolean | LabMaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labMaterial"]>



  export type LabMaterialSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    category?: boolean
    description?: boolean
    unit?: boolean
    currentQuantity?: boolean
    minimumQuantity?: boolean
    price?: boolean
    supplier?: boolean
    expiryDate?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type LabMaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "category" | "description" | "unit" | "currentQuantity" | "minimumQuantity" | "price" | "supplier" | "expiryDate" | "location" | "notes" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["labMaterial"]>
  export type LabMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | LabMaterial$createdByArgs<ExtArgs>
    transactions?: boolean | LabMaterial$transactionsArgs<ExtArgs>
    _count?: boolean | LabMaterialCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LabMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabMaterial"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      transactions: Prisma.$MaterialTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      category: $Enums.MaterialCategory
      description: string | null
      unit: string
      currentQuantity: number
      minimumQuantity: number
      price: number | null
      supplier: string | null
      expiryDate: Date | null
      location: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      createdById: string | null
    }, ExtArgs["result"]["labMaterial"]>
    composites: {}
  }

  type LabMaterialGetPayload<S extends boolean | null | undefined | LabMaterialDefaultArgs> = $Result.GetResult<Prisma.$LabMaterialPayload, S>

  type LabMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabMaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabMaterialCountAggregateInputType | true
    }

  export interface LabMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabMaterial'], meta: { name: 'LabMaterial' } }
    /**
     * Find zero or one LabMaterial that matches the filter.
     * @param {LabMaterialFindUniqueArgs} args - Arguments to find a LabMaterial
     * @example
     * // Get one LabMaterial
     * const labMaterial = await prisma.labMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabMaterialFindUniqueArgs>(args: SelectSubset<T, LabMaterialFindUniqueArgs<ExtArgs>>): Prisma__LabMaterialClient<$Result.GetResult<Prisma.$LabMaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabMaterial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabMaterialFindUniqueOrThrowArgs} args - Arguments to find a LabMaterial
     * @example
     * // Get one LabMaterial
     * const labMaterial = await prisma.labMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, LabMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabMaterialClient<$Result.GetResult<Prisma.$LabMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabMaterialFindFirstArgs} args - Arguments to find a LabMaterial
     * @example
     * // Get one LabMaterial
     * const labMaterial = await prisma.labMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabMaterialFindFirstArgs>(args?: SelectSubset<T, LabMaterialFindFirstArgs<ExtArgs>>): Prisma__LabMaterialClient<$Result.GetResult<Prisma.$LabMaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabMaterialFindFirstOrThrowArgs} args - Arguments to find a LabMaterial
     * @example
     * // Get one LabMaterial
     * const labMaterial = await prisma.labMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, LabMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabMaterialClient<$Result.GetResult<Prisma.$LabMaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabMaterials
     * const labMaterials = await prisma.labMaterial.findMany()
     * 
     * // Get first 10 LabMaterials
     * const labMaterials = await prisma.labMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labMaterialWithIdOnly = await prisma.labMaterial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabMaterialFindManyArgs>(args?: SelectSubset<T, LabMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabMaterial.
     * @param {LabMaterialCreateArgs} args - Arguments to create a LabMaterial.
     * @example
     * // Create one LabMaterial
     * const LabMaterial = await prisma.labMaterial.create({
     *   data: {
     *     // ... data to create a LabMaterial
     *   }
     * })
     * 
     */
    create<T extends LabMaterialCreateArgs>(args: SelectSubset<T, LabMaterialCreateArgs<ExtArgs>>): Prisma__LabMaterialClient<$Result.GetResult<Prisma.$LabMaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabMaterials.
     * @param {LabMaterialCreateManyArgs} args - Arguments to create many LabMaterials.
     * @example
     * // Create many LabMaterials
     * const labMaterial = await prisma.labMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabMaterialCreateManyArgs>(args?: SelectSubset<T, LabMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LabMaterial.
     * @param {LabMaterialDeleteArgs} args - Arguments to delete one LabMaterial.
     * @example
     * // Delete one LabMaterial
     * const LabMaterial = await prisma.labMaterial.delete({
     *   where: {
     *     // ... filter to delete one LabMaterial
     *   }
     * })
     * 
     */
    delete<T extends LabMaterialDeleteArgs>(args: SelectSubset<T, LabMaterialDeleteArgs<ExtArgs>>): Prisma__LabMaterialClient<$Result.GetResult<Prisma.$LabMaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabMaterial.
     * @param {LabMaterialUpdateArgs} args - Arguments to update one LabMaterial.
     * @example
     * // Update one LabMaterial
     * const labMaterial = await prisma.labMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabMaterialUpdateArgs>(args: SelectSubset<T, LabMaterialUpdateArgs<ExtArgs>>): Prisma__LabMaterialClient<$Result.GetResult<Prisma.$LabMaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabMaterials.
     * @param {LabMaterialDeleteManyArgs} args - Arguments to filter LabMaterials to delete.
     * @example
     * // Delete a few LabMaterials
     * const { count } = await prisma.labMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabMaterialDeleteManyArgs>(args?: SelectSubset<T, LabMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabMaterials
     * const labMaterial = await prisma.labMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabMaterialUpdateManyArgs>(args: SelectSubset<T, LabMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LabMaterial.
     * @param {LabMaterialUpsertArgs} args - Arguments to update or create a LabMaterial.
     * @example
     * // Update or create a LabMaterial
     * const labMaterial = await prisma.labMaterial.upsert({
     *   create: {
     *     // ... data to create a LabMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabMaterial we want to update
     *   }
     * })
     */
    upsert<T extends LabMaterialUpsertArgs>(args: SelectSubset<T, LabMaterialUpsertArgs<ExtArgs>>): Prisma__LabMaterialClient<$Result.GetResult<Prisma.$LabMaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabMaterialCountArgs} args - Arguments to filter LabMaterials to count.
     * @example
     * // Count the number of LabMaterials
     * const count = await prisma.labMaterial.count({
     *   where: {
     *     // ... the filter for the LabMaterials we want to count
     *   }
     * })
    **/
    count<T extends LabMaterialCountArgs>(
      args?: Subset<T, LabMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabMaterialAggregateArgs>(args: Subset<T, LabMaterialAggregateArgs>): Prisma.PrismaPromise<GetLabMaterialAggregateType<T>>

    /**
     * Group by LabMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabMaterialGroupByArgs['orderBy'] }
        : { orderBy?: LabMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabMaterial model
   */
  readonly fields: LabMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends LabMaterial$createdByArgs<ExtArgs> = {}>(args?: Subset<T, LabMaterial$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactions<T extends LabMaterial$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, LabMaterial$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabMaterial model
   */
  interface LabMaterialFieldRefs {
    readonly id: FieldRef<"LabMaterial", 'String'>
    readonly name: FieldRef<"LabMaterial", 'String'>
    readonly code: FieldRef<"LabMaterial", 'String'>
    readonly category: FieldRef<"LabMaterial", 'MaterialCategory'>
    readonly description: FieldRef<"LabMaterial", 'String'>
    readonly unit: FieldRef<"LabMaterial", 'String'>
    readonly currentQuantity: FieldRef<"LabMaterial", 'Float'>
    readonly minimumQuantity: FieldRef<"LabMaterial", 'Float'>
    readonly price: FieldRef<"LabMaterial", 'Float'>
    readonly supplier: FieldRef<"LabMaterial", 'String'>
    readonly expiryDate: FieldRef<"LabMaterial", 'DateTime'>
    readonly location: FieldRef<"LabMaterial", 'String'>
    readonly notes: FieldRef<"LabMaterial", 'String'>
    readonly createdAt: FieldRef<"LabMaterial", 'DateTime'>
    readonly updatedAt: FieldRef<"LabMaterial", 'DateTime'>
    readonly createdById: FieldRef<"LabMaterial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LabMaterial findUnique
   */
  export type LabMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabMaterial
     */
    select?: LabMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabMaterial
     */
    omit?: LabMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LabMaterial to fetch.
     */
    where: LabMaterialWhereUniqueInput
  }

  /**
   * LabMaterial findUniqueOrThrow
   */
  export type LabMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabMaterial
     */
    select?: LabMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabMaterial
     */
    omit?: LabMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LabMaterial to fetch.
     */
    where: LabMaterialWhereUniqueInput
  }

  /**
   * LabMaterial findFirst
   */
  export type LabMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabMaterial
     */
    select?: LabMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabMaterial
     */
    omit?: LabMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LabMaterial to fetch.
     */
    where?: LabMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabMaterials to fetch.
     */
    orderBy?: LabMaterialOrderByWithRelationInput | LabMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabMaterials.
     */
    cursor?: LabMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabMaterials.
     */
    distinct?: LabMaterialScalarFieldEnum | LabMaterialScalarFieldEnum[]
  }

  /**
   * LabMaterial findFirstOrThrow
   */
  export type LabMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabMaterial
     */
    select?: LabMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabMaterial
     */
    omit?: LabMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LabMaterial to fetch.
     */
    where?: LabMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabMaterials to fetch.
     */
    orderBy?: LabMaterialOrderByWithRelationInput | LabMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabMaterials.
     */
    cursor?: LabMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabMaterials.
     */
    distinct?: LabMaterialScalarFieldEnum | LabMaterialScalarFieldEnum[]
  }

  /**
   * LabMaterial findMany
   */
  export type LabMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabMaterial
     */
    select?: LabMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabMaterial
     */
    omit?: LabMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LabMaterials to fetch.
     */
    where?: LabMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabMaterials to fetch.
     */
    orderBy?: LabMaterialOrderByWithRelationInput | LabMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabMaterials.
     */
    cursor?: LabMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabMaterials.
     */
    skip?: number
    distinct?: LabMaterialScalarFieldEnum | LabMaterialScalarFieldEnum[]
  }

  /**
   * LabMaterial create
   */
  export type LabMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabMaterial
     */
    select?: LabMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabMaterial
     */
    omit?: LabMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a LabMaterial.
     */
    data: XOR<LabMaterialCreateInput, LabMaterialUncheckedCreateInput>
  }

  /**
   * LabMaterial createMany
   */
  export type LabMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabMaterials.
     */
    data: LabMaterialCreateManyInput | LabMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabMaterial update
   */
  export type LabMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabMaterial
     */
    select?: LabMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabMaterial
     */
    omit?: LabMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a LabMaterial.
     */
    data: XOR<LabMaterialUpdateInput, LabMaterialUncheckedUpdateInput>
    /**
     * Choose, which LabMaterial to update.
     */
    where: LabMaterialWhereUniqueInput
  }

  /**
   * LabMaterial updateMany
   */
  export type LabMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabMaterials.
     */
    data: XOR<LabMaterialUpdateManyMutationInput, LabMaterialUncheckedUpdateManyInput>
    /**
     * Filter which LabMaterials to update
     */
    where?: LabMaterialWhereInput
    /**
     * Limit how many LabMaterials to update.
     */
    limit?: number
  }

  /**
   * LabMaterial upsert
   */
  export type LabMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabMaterial
     */
    select?: LabMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabMaterial
     */
    omit?: LabMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the LabMaterial to update in case it exists.
     */
    where: LabMaterialWhereUniqueInput
    /**
     * In case the LabMaterial found by the `where` argument doesn't exist, create a new LabMaterial with this data.
     */
    create: XOR<LabMaterialCreateInput, LabMaterialUncheckedCreateInput>
    /**
     * In case the LabMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabMaterialUpdateInput, LabMaterialUncheckedUpdateInput>
  }

  /**
   * LabMaterial delete
   */
  export type LabMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabMaterial
     */
    select?: LabMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabMaterial
     */
    omit?: LabMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabMaterialInclude<ExtArgs> | null
    /**
     * Filter which LabMaterial to delete.
     */
    where: LabMaterialWhereUniqueInput
  }

  /**
   * LabMaterial deleteMany
   */
  export type LabMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabMaterials to delete
     */
    where?: LabMaterialWhereInput
    /**
     * Limit how many LabMaterials to delete.
     */
    limit?: number
  }

  /**
   * LabMaterial.createdBy
   */
  export type LabMaterial$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LabMaterial.transactions
   */
  export type LabMaterial$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialTransaction
     */
    select?: MaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialTransaction
     */
    omit?: MaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialTransactionInclude<ExtArgs> | null
    where?: MaterialTransactionWhereInput
    orderBy?: MaterialTransactionOrderByWithRelationInput | MaterialTransactionOrderByWithRelationInput[]
    cursor?: MaterialTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialTransactionScalarFieldEnum | MaterialTransactionScalarFieldEnum[]
  }

  /**
   * LabMaterial without action
   */
  export type LabMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabMaterial
     */
    select?: LabMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabMaterial
     */
    omit?: LabMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabMaterialInclude<ExtArgs> | null
  }


  /**
   * Model MaterialTransaction
   */

  export type AggregateMaterialTransaction = {
    _count: MaterialTransactionCountAggregateOutputType | null
    _avg: MaterialTransactionAvgAggregateOutputType | null
    _sum: MaterialTransactionSumAggregateOutputType | null
    _min: MaterialTransactionMinAggregateOutputType | null
    _max: MaterialTransactionMaxAggregateOutputType | null
  }

  export type MaterialTransactionAvgAggregateOutputType = {
    quantity: number | null
    previousQuantity: number | null
    newQuantity: number | null
  }

  export type MaterialTransactionSumAggregateOutputType = {
    quantity: number | null
    previousQuantity: number | null
    newQuantity: number | null
  }

  export type MaterialTransactionMinAggregateOutputType = {
    id: string | null
    materialId: string | null
    type: $Enums.TransactionType | null
    quantity: number | null
    previousQuantity: number | null
    newQuantity: number | null
    reason: string | null
    batchNumber: string | null
    invoiceNumber: string | null
    createdAt: Date | null
    createdById: string | null
  }

  export type MaterialTransactionMaxAggregateOutputType = {
    id: string | null
    materialId: string | null
    type: $Enums.TransactionType | null
    quantity: number | null
    previousQuantity: number | null
    newQuantity: number | null
    reason: string | null
    batchNumber: string | null
    invoiceNumber: string | null
    createdAt: Date | null
    createdById: string | null
  }

  export type MaterialTransactionCountAggregateOutputType = {
    id: number
    materialId: number
    type: number
    quantity: number
    previousQuantity: number
    newQuantity: number
    reason: number
    batchNumber: number
    invoiceNumber: number
    createdAt: number
    createdById: number
    _all: number
  }


  export type MaterialTransactionAvgAggregateInputType = {
    quantity?: true
    previousQuantity?: true
    newQuantity?: true
  }

  export type MaterialTransactionSumAggregateInputType = {
    quantity?: true
    previousQuantity?: true
    newQuantity?: true
  }

  export type MaterialTransactionMinAggregateInputType = {
    id?: true
    materialId?: true
    type?: true
    quantity?: true
    previousQuantity?: true
    newQuantity?: true
    reason?: true
    batchNumber?: true
    invoiceNumber?: true
    createdAt?: true
    createdById?: true
  }

  export type MaterialTransactionMaxAggregateInputType = {
    id?: true
    materialId?: true
    type?: true
    quantity?: true
    previousQuantity?: true
    newQuantity?: true
    reason?: true
    batchNumber?: true
    invoiceNumber?: true
    createdAt?: true
    createdById?: true
  }

  export type MaterialTransactionCountAggregateInputType = {
    id?: true
    materialId?: true
    type?: true
    quantity?: true
    previousQuantity?: true
    newQuantity?: true
    reason?: true
    batchNumber?: true
    invoiceNumber?: true
    createdAt?: true
    createdById?: true
    _all?: true
  }

  export type MaterialTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialTransaction to aggregate.
     */
    where?: MaterialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialTransactions to fetch.
     */
    orderBy?: MaterialTransactionOrderByWithRelationInput | MaterialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialTransactions
    **/
    _count?: true | MaterialTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialTransactionMaxAggregateInputType
  }

  export type GetMaterialTransactionAggregateType<T extends MaterialTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialTransaction[P]>
      : GetScalarType<T[P], AggregateMaterialTransaction[P]>
  }




  export type MaterialTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialTransactionWhereInput
    orderBy?: MaterialTransactionOrderByWithAggregationInput | MaterialTransactionOrderByWithAggregationInput[]
    by: MaterialTransactionScalarFieldEnum[] | MaterialTransactionScalarFieldEnum
    having?: MaterialTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialTransactionCountAggregateInputType | true
    _avg?: MaterialTransactionAvgAggregateInputType
    _sum?: MaterialTransactionSumAggregateInputType
    _min?: MaterialTransactionMinAggregateInputType
    _max?: MaterialTransactionMaxAggregateInputType
  }

  export type MaterialTransactionGroupByOutputType = {
    id: string
    materialId: string
    type: $Enums.TransactionType
    quantity: number
    previousQuantity: number
    newQuantity: number
    reason: string | null
    batchNumber: string | null
    invoiceNumber: string | null
    createdAt: Date
    createdById: string
    _count: MaterialTransactionCountAggregateOutputType | null
    _avg: MaterialTransactionAvgAggregateOutputType | null
    _sum: MaterialTransactionSumAggregateOutputType | null
    _min: MaterialTransactionMinAggregateOutputType | null
    _max: MaterialTransactionMaxAggregateOutputType | null
  }

  type GetMaterialTransactionGroupByPayload<T extends MaterialTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialTransactionGroupByOutputType[P]>
        }
      >
    >


  export type MaterialTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    type?: boolean
    quantity?: boolean
    previousQuantity?: boolean
    newQuantity?: boolean
    reason?: boolean
    batchNumber?: boolean
    invoiceNumber?: boolean
    createdAt?: boolean
    createdById?: boolean
    material?: boolean | LabMaterialDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialTransaction"]>



  export type MaterialTransactionSelectScalar = {
    id?: boolean
    materialId?: boolean
    type?: boolean
    quantity?: boolean
    previousQuantity?: boolean
    newQuantity?: boolean
    reason?: boolean
    batchNumber?: boolean
    invoiceNumber?: boolean
    createdAt?: boolean
    createdById?: boolean
  }

  export type MaterialTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "materialId" | "type" | "quantity" | "previousQuantity" | "newQuantity" | "reason" | "batchNumber" | "invoiceNumber" | "createdAt" | "createdById", ExtArgs["result"]["materialTransaction"]>
  export type MaterialTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | LabMaterialDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MaterialTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialTransaction"
    objects: {
      material: Prisma.$LabMaterialPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      materialId: string
      type: $Enums.TransactionType
      quantity: number
      previousQuantity: number
      newQuantity: number
      reason: string | null
      batchNumber: string | null
      invoiceNumber: string | null
      createdAt: Date
      createdById: string
    }, ExtArgs["result"]["materialTransaction"]>
    composites: {}
  }

  type MaterialTransactionGetPayload<S extends boolean | null | undefined | MaterialTransactionDefaultArgs> = $Result.GetResult<Prisma.$MaterialTransactionPayload, S>

  type MaterialTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialTransactionCountAggregateInputType | true
    }

  export interface MaterialTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialTransaction'], meta: { name: 'MaterialTransaction' } }
    /**
     * Find zero or one MaterialTransaction that matches the filter.
     * @param {MaterialTransactionFindUniqueArgs} args - Arguments to find a MaterialTransaction
     * @example
     * // Get one MaterialTransaction
     * const materialTransaction = await prisma.materialTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialTransactionFindUniqueArgs>(args: SelectSubset<T, MaterialTransactionFindUniqueArgs<ExtArgs>>): Prisma__MaterialTransactionClient<$Result.GetResult<Prisma.$MaterialTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaterialTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialTransactionFindUniqueOrThrowArgs} args - Arguments to find a MaterialTransaction
     * @example
     * // Get one MaterialTransaction
     * const materialTransaction = await prisma.materialTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialTransactionClient<$Result.GetResult<Prisma.$MaterialTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialTransactionFindFirstArgs} args - Arguments to find a MaterialTransaction
     * @example
     * // Get one MaterialTransaction
     * const materialTransaction = await prisma.materialTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialTransactionFindFirstArgs>(args?: SelectSubset<T, MaterialTransactionFindFirstArgs<ExtArgs>>): Prisma__MaterialTransactionClient<$Result.GetResult<Prisma.$MaterialTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialTransactionFindFirstOrThrowArgs} args - Arguments to find a MaterialTransaction
     * @example
     * // Get one MaterialTransaction
     * const materialTransaction = await prisma.materialTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialTransactionClient<$Result.GetResult<Prisma.$MaterialTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaterialTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialTransactions
     * const materialTransactions = await prisma.materialTransaction.findMany()
     * 
     * // Get first 10 MaterialTransactions
     * const materialTransactions = await prisma.materialTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialTransactionWithIdOnly = await prisma.materialTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialTransactionFindManyArgs>(args?: SelectSubset<T, MaterialTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaterialTransaction.
     * @param {MaterialTransactionCreateArgs} args - Arguments to create a MaterialTransaction.
     * @example
     * // Create one MaterialTransaction
     * const MaterialTransaction = await prisma.materialTransaction.create({
     *   data: {
     *     // ... data to create a MaterialTransaction
     *   }
     * })
     * 
     */
    create<T extends MaterialTransactionCreateArgs>(args: SelectSubset<T, MaterialTransactionCreateArgs<ExtArgs>>): Prisma__MaterialTransactionClient<$Result.GetResult<Prisma.$MaterialTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaterialTransactions.
     * @param {MaterialTransactionCreateManyArgs} args - Arguments to create many MaterialTransactions.
     * @example
     * // Create many MaterialTransactions
     * const materialTransaction = await prisma.materialTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialTransactionCreateManyArgs>(args?: SelectSubset<T, MaterialTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaterialTransaction.
     * @param {MaterialTransactionDeleteArgs} args - Arguments to delete one MaterialTransaction.
     * @example
     * // Delete one MaterialTransaction
     * const MaterialTransaction = await prisma.materialTransaction.delete({
     *   where: {
     *     // ... filter to delete one MaterialTransaction
     *   }
     * })
     * 
     */
    delete<T extends MaterialTransactionDeleteArgs>(args: SelectSubset<T, MaterialTransactionDeleteArgs<ExtArgs>>): Prisma__MaterialTransactionClient<$Result.GetResult<Prisma.$MaterialTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaterialTransaction.
     * @param {MaterialTransactionUpdateArgs} args - Arguments to update one MaterialTransaction.
     * @example
     * // Update one MaterialTransaction
     * const materialTransaction = await prisma.materialTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialTransactionUpdateArgs>(args: SelectSubset<T, MaterialTransactionUpdateArgs<ExtArgs>>): Prisma__MaterialTransactionClient<$Result.GetResult<Prisma.$MaterialTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaterialTransactions.
     * @param {MaterialTransactionDeleteManyArgs} args - Arguments to filter MaterialTransactions to delete.
     * @example
     * // Delete a few MaterialTransactions
     * const { count } = await prisma.materialTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialTransactionDeleteManyArgs>(args?: SelectSubset<T, MaterialTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialTransactions
     * const materialTransaction = await prisma.materialTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialTransactionUpdateManyArgs>(args: SelectSubset<T, MaterialTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaterialTransaction.
     * @param {MaterialTransactionUpsertArgs} args - Arguments to update or create a MaterialTransaction.
     * @example
     * // Update or create a MaterialTransaction
     * const materialTransaction = await prisma.materialTransaction.upsert({
     *   create: {
     *     // ... data to create a MaterialTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialTransaction we want to update
     *   }
     * })
     */
    upsert<T extends MaterialTransactionUpsertArgs>(args: SelectSubset<T, MaterialTransactionUpsertArgs<ExtArgs>>): Prisma__MaterialTransactionClient<$Result.GetResult<Prisma.$MaterialTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaterialTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialTransactionCountArgs} args - Arguments to filter MaterialTransactions to count.
     * @example
     * // Count the number of MaterialTransactions
     * const count = await prisma.materialTransaction.count({
     *   where: {
     *     // ... the filter for the MaterialTransactions we want to count
     *   }
     * })
    **/
    count<T extends MaterialTransactionCountArgs>(
      args?: Subset<T, MaterialTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialTransactionAggregateArgs>(args: Subset<T, MaterialTransactionAggregateArgs>): Prisma.PrismaPromise<GetMaterialTransactionAggregateType<T>>

    /**
     * Group by MaterialTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialTransactionGroupByArgs['orderBy'] }
        : { orderBy?: MaterialTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialTransaction model
   */
  readonly fields: MaterialTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    material<T extends LabMaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabMaterialDefaultArgs<ExtArgs>>): Prisma__LabMaterialClient<$Result.GetResult<Prisma.$LabMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialTransaction model
   */
  interface MaterialTransactionFieldRefs {
    readonly id: FieldRef<"MaterialTransaction", 'String'>
    readonly materialId: FieldRef<"MaterialTransaction", 'String'>
    readonly type: FieldRef<"MaterialTransaction", 'TransactionType'>
    readonly quantity: FieldRef<"MaterialTransaction", 'Float'>
    readonly previousQuantity: FieldRef<"MaterialTransaction", 'Float'>
    readonly newQuantity: FieldRef<"MaterialTransaction", 'Float'>
    readonly reason: FieldRef<"MaterialTransaction", 'String'>
    readonly batchNumber: FieldRef<"MaterialTransaction", 'String'>
    readonly invoiceNumber: FieldRef<"MaterialTransaction", 'String'>
    readonly createdAt: FieldRef<"MaterialTransaction", 'DateTime'>
    readonly createdById: FieldRef<"MaterialTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaterialTransaction findUnique
   */
  export type MaterialTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialTransaction
     */
    select?: MaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialTransaction
     */
    omit?: MaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which MaterialTransaction to fetch.
     */
    where: MaterialTransactionWhereUniqueInput
  }

  /**
   * MaterialTransaction findUniqueOrThrow
   */
  export type MaterialTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialTransaction
     */
    select?: MaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialTransaction
     */
    omit?: MaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which MaterialTransaction to fetch.
     */
    where: MaterialTransactionWhereUniqueInput
  }

  /**
   * MaterialTransaction findFirst
   */
  export type MaterialTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialTransaction
     */
    select?: MaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialTransaction
     */
    omit?: MaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which MaterialTransaction to fetch.
     */
    where?: MaterialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialTransactions to fetch.
     */
    orderBy?: MaterialTransactionOrderByWithRelationInput | MaterialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialTransactions.
     */
    cursor?: MaterialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialTransactions.
     */
    distinct?: MaterialTransactionScalarFieldEnum | MaterialTransactionScalarFieldEnum[]
  }

  /**
   * MaterialTransaction findFirstOrThrow
   */
  export type MaterialTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialTransaction
     */
    select?: MaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialTransaction
     */
    omit?: MaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which MaterialTransaction to fetch.
     */
    where?: MaterialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialTransactions to fetch.
     */
    orderBy?: MaterialTransactionOrderByWithRelationInput | MaterialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialTransactions.
     */
    cursor?: MaterialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialTransactions.
     */
    distinct?: MaterialTransactionScalarFieldEnum | MaterialTransactionScalarFieldEnum[]
  }

  /**
   * MaterialTransaction findMany
   */
  export type MaterialTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialTransaction
     */
    select?: MaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialTransaction
     */
    omit?: MaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which MaterialTransactions to fetch.
     */
    where?: MaterialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialTransactions to fetch.
     */
    orderBy?: MaterialTransactionOrderByWithRelationInput | MaterialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialTransactions.
     */
    cursor?: MaterialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialTransactions.
     */
    skip?: number
    distinct?: MaterialTransactionScalarFieldEnum | MaterialTransactionScalarFieldEnum[]
  }

  /**
   * MaterialTransaction create
   */
  export type MaterialTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialTransaction
     */
    select?: MaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialTransaction
     */
    omit?: MaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialTransaction.
     */
    data: XOR<MaterialTransactionCreateInput, MaterialTransactionUncheckedCreateInput>
  }

  /**
   * MaterialTransaction createMany
   */
  export type MaterialTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialTransactions.
     */
    data: MaterialTransactionCreateManyInput | MaterialTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialTransaction update
   */
  export type MaterialTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialTransaction
     */
    select?: MaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialTransaction
     */
    omit?: MaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialTransaction.
     */
    data: XOR<MaterialTransactionUpdateInput, MaterialTransactionUncheckedUpdateInput>
    /**
     * Choose, which MaterialTransaction to update.
     */
    where: MaterialTransactionWhereUniqueInput
  }

  /**
   * MaterialTransaction updateMany
   */
  export type MaterialTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialTransactions.
     */
    data: XOR<MaterialTransactionUpdateManyMutationInput, MaterialTransactionUncheckedUpdateManyInput>
    /**
     * Filter which MaterialTransactions to update
     */
    where?: MaterialTransactionWhereInput
    /**
     * Limit how many MaterialTransactions to update.
     */
    limit?: number
  }

  /**
   * MaterialTransaction upsert
   */
  export type MaterialTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialTransaction
     */
    select?: MaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialTransaction
     */
    omit?: MaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialTransaction to update in case it exists.
     */
    where: MaterialTransactionWhereUniqueInput
    /**
     * In case the MaterialTransaction found by the `where` argument doesn't exist, create a new MaterialTransaction with this data.
     */
    create: XOR<MaterialTransactionCreateInput, MaterialTransactionUncheckedCreateInput>
    /**
     * In case the MaterialTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialTransactionUpdateInput, MaterialTransactionUncheckedUpdateInput>
  }

  /**
   * MaterialTransaction delete
   */
  export type MaterialTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialTransaction
     */
    select?: MaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialTransaction
     */
    omit?: MaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialTransactionInclude<ExtArgs> | null
    /**
     * Filter which MaterialTransaction to delete.
     */
    where: MaterialTransactionWhereUniqueInput
  }

  /**
   * MaterialTransaction deleteMany
   */
  export type MaterialTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialTransactions to delete
     */
    where?: MaterialTransactionWhereInput
    /**
     * Limit how many MaterialTransactions to delete.
     */
    limit?: number
  }

  /**
   * MaterialTransaction without action
   */
  export type MaterialTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialTransaction
     */
    select?: MaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialTransaction
     */
    omit?: MaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialTransactionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    approved: 'approved',
    sessionVersion: 'sessionVersion'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    fileNumber: 'fileNumber',
    name: 'name',
    phone: 'phone',
    address: 'address',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const TestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    price: 'price',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestScalarFieldEnum = (typeof TestScalarFieldEnum)[keyof typeof TestScalarFieldEnum]


  export const TestAssignmentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    testId: 'testId',
    status: 'status',
    assignedById: 'assignedById',
    assignedAt: 'assignedAt',
    updatedAt: 'updatedAt'
  };

  export type TestAssignmentScalarFieldEnum = (typeof TestAssignmentScalarFieldEnum)[keyof typeof TestAssignmentScalarFieldEnum]


  export const SampleScalarFieldEnum: {
    id: 'id',
    testAssignmentId: 'testAssignmentId',
    sampleCode: 'sampleCode',
    collectedAt: 'collectedAt',
    collectedById: 'collectedById',
    notes: 'notes',
    results: 'results',
    reportPdfUrl: 'reportPdfUrl'
  };

  export type SampleScalarFieldEnum = (typeof SampleScalarFieldEnum)[keyof typeof SampleScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    isPaid: 'isPaid',
    invoiceDate: 'invoiceDate',
    dueDate: 'dueDate',
    createdById: 'createdById'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    testAssignmentId: 'testAssignmentId',
    price: 'price',
    quantity: 'quantity',
    subtotal: 'subtotal'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const QueueNumberScalarFieldEnum: {
    id: 'id',
    number: 'number',
    patientId: 'patientId',
    date: 'date',
    status: 'status'
  };

  export type QueueNumberScalarFieldEnum = (typeof QueueNumberScalarFieldEnum)[keyof typeof QueueNumberScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    description: 'description',
    createdAt: 'createdAt',
    startDate: 'startDate',
    endDate: 'endDate',
    pdfUrl: 'pdfUrl',
    createdById: 'createdById'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const PurchaseInvoiceScalarFieldEnum: {
    id: 'id',
    supplierName: 'supplierName',
    invoiceNumber: 'invoiceNumber',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    isPaid: 'isPaid',
    invoiceDate: 'invoiceDate',
    dueDate: 'dueDate',
    notes: 'notes',
    createdById: 'createdById'
  };

  export type PurchaseInvoiceScalarFieldEnum = (typeof PurchaseInvoiceScalarFieldEnum)[keyof typeof PurchaseInvoiceScalarFieldEnum]


  export const PurchaseInvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    itemName: 'itemName',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    subtotal: 'subtotal'
  };

  export type PurchaseInvoiceItemScalarFieldEnum = (typeof PurchaseInvoiceItemScalarFieldEnum)[keyof typeof PurchaseInvoiceItemScalarFieldEnum]


  export const RadiationResultScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    resultDetails: 'resultDetails',
    reportText: 'reportText',
    imageUrl: 'imageUrl',
    pdfUrl: 'pdfUrl',
    patientId: 'patientId',
    testAssignmentId: 'testAssignmentId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RadiationResultScalarFieldEnum = (typeof RadiationResultScalarFieldEnum)[keyof typeof RadiationResultScalarFieldEnum]


  export const LabMaterialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    category: 'category',
    description: 'description',
    unit: 'unit',
    currentQuantity: 'currentQuantity',
    minimumQuantity: 'minimumQuantity',
    price: 'price',
    supplier: 'supplier',
    expiryDate: 'expiryDate',
    location: 'location',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type LabMaterialScalarFieldEnum = (typeof LabMaterialScalarFieldEnum)[keyof typeof LabMaterialScalarFieldEnum]


  export const MaterialTransactionScalarFieldEnum: {
    id: 'id',
    materialId: 'materialId',
    type: 'type',
    quantity: 'quantity',
    previousQuantity: 'previousQuantity',
    newQuantity: 'newQuantity',
    reason: 'reason',
    batchNumber: 'batchNumber',
    invoiceNumber: 'invoiceNumber',
    createdAt: 'createdAt',
    createdById: 'createdById'
  };

  export type MaterialTransactionScalarFieldEnum = (typeof MaterialTransactionScalarFieldEnum)[keyof typeof MaterialTransactionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const PatientOrderByRelevanceFieldEnum: {
    id: 'id',
    fileNumber: 'fileNumber',
    name: 'name',
    phone: 'phone',
    address: 'address',
    createdById: 'createdById'
  };

  export type PatientOrderByRelevanceFieldEnum = (typeof PatientOrderByRelevanceFieldEnum)[keyof typeof PatientOrderByRelevanceFieldEnum]


  export const TestOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    description: 'description'
  };

  export type TestOrderByRelevanceFieldEnum = (typeof TestOrderByRelevanceFieldEnum)[keyof typeof TestOrderByRelevanceFieldEnum]


  export const TestAssignmentOrderByRelevanceFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    testId: 'testId',
    assignedById: 'assignedById'
  };

  export type TestAssignmentOrderByRelevanceFieldEnum = (typeof TestAssignmentOrderByRelevanceFieldEnum)[keyof typeof TestAssignmentOrderByRelevanceFieldEnum]


  export const SampleOrderByRelevanceFieldEnum: {
    id: 'id',
    testAssignmentId: 'testAssignmentId',
    sampleCode: 'sampleCode',
    collectedById: 'collectedById',
    notes: 'notes',
    results: 'results',
    reportPdfUrl: 'reportPdfUrl'
  };

  export type SampleOrderByRelevanceFieldEnum = (typeof SampleOrderByRelevanceFieldEnum)[keyof typeof SampleOrderByRelevanceFieldEnum]


  export const InvoiceOrderByRelevanceFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    createdById: 'createdById'
  };

  export type InvoiceOrderByRelevanceFieldEnum = (typeof InvoiceOrderByRelevanceFieldEnum)[keyof typeof InvoiceOrderByRelevanceFieldEnum]


  export const InvoiceItemOrderByRelevanceFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    testAssignmentId: 'testAssignmentId'
  };

  export type InvoiceItemOrderByRelevanceFieldEnum = (typeof InvoiceItemOrderByRelevanceFieldEnum)[keyof typeof InvoiceItemOrderByRelevanceFieldEnum]


  export const QueueNumberOrderByRelevanceFieldEnum: {
    id: 'id',
    patientId: 'patientId'
  };

  export type QueueNumberOrderByRelevanceFieldEnum = (typeof QueueNumberOrderByRelevanceFieldEnum)[keyof typeof QueueNumberOrderByRelevanceFieldEnum]


  export const ReportOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    pdfUrl: 'pdfUrl',
    createdById: 'createdById'
  };

  export type ReportOrderByRelevanceFieldEnum = (typeof ReportOrderByRelevanceFieldEnum)[keyof typeof ReportOrderByRelevanceFieldEnum]


  export const PurchaseInvoiceOrderByRelevanceFieldEnum: {
    id: 'id',
    supplierName: 'supplierName',
    invoiceNumber: 'invoiceNumber',
    notes: 'notes',
    createdById: 'createdById'
  };

  export type PurchaseInvoiceOrderByRelevanceFieldEnum = (typeof PurchaseInvoiceOrderByRelevanceFieldEnum)[keyof typeof PurchaseInvoiceOrderByRelevanceFieldEnum]


  export const PurchaseInvoiceItemOrderByRelevanceFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    itemName: 'itemName',
    description: 'description'
  };

  export type PurchaseInvoiceItemOrderByRelevanceFieldEnum = (typeof PurchaseInvoiceItemOrderByRelevanceFieldEnum)[keyof typeof PurchaseInvoiceItemOrderByRelevanceFieldEnum]


  export const RadiationResultOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    resultDetails: 'resultDetails',
    reportText: 'reportText',
    imageUrl: 'imageUrl',
    pdfUrl: 'pdfUrl',
    patientId: 'patientId',
    testAssignmentId: 'testAssignmentId',
    createdById: 'createdById'
  };

  export type RadiationResultOrderByRelevanceFieldEnum = (typeof RadiationResultOrderByRelevanceFieldEnum)[keyof typeof RadiationResultOrderByRelevanceFieldEnum]


  export const LabMaterialOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    unit: 'unit',
    supplier: 'supplier',
    location: 'location',
    notes: 'notes',
    createdById: 'createdById'
  };

  export type LabMaterialOrderByRelevanceFieldEnum = (typeof LabMaterialOrderByRelevanceFieldEnum)[keyof typeof LabMaterialOrderByRelevanceFieldEnum]


  export const MaterialTransactionOrderByRelevanceFieldEnum: {
    id: 'id',
    materialId: 'materialId',
    reason: 'reason',
    batchNumber: 'batchNumber',
    invoiceNumber: 'invoiceNumber',
    createdById: 'createdById'
  };

  export type MaterialTransactionOrderByRelevanceFieldEnum = (typeof MaterialTransactionOrderByRelevanceFieldEnum)[keyof typeof MaterialTransactionOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'TestStatus'
   */
  export type EnumTestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestStatus'>
    


  /**
   * Reference to a field of type 'QueueStatus'
   */
  export type EnumQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueueStatus'>
    


  /**
   * Reference to a field of type 'ReportType'
   */
  export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType'>
    


  /**
   * Reference to a field of type 'MaterialCategory'
   */
  export type EnumMaterialCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialCategory'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    approved?: BoolFilter<"User"> | boolean
    sessionVersion?: IntFilter<"User"> | number
    invoices?: InvoiceListRelationFilter
    patients?: PatientListRelationFilter
    purchaseInvoices?: PurchaseInvoiceListRelationFilter
    radiationResults?: RadiationResultListRelationFilter
    reports?: ReportListRelationFilter
    samples?: SampleListRelationFilter
    testAssignments?: TestAssignmentListRelationFilter
    materialTransactions?: MaterialTransactionListRelationFilter
    labMaterials?: LabMaterialListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approved?: SortOrder
    sessionVersion?: SortOrder
    invoices?: InvoiceOrderByRelationAggregateInput
    patients?: PatientOrderByRelationAggregateInput
    purchaseInvoices?: PurchaseInvoiceOrderByRelationAggregateInput
    radiationResults?: RadiationResultOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    samples?: SampleOrderByRelationAggregateInput
    testAssignments?: TestAssignmentOrderByRelationAggregateInput
    materialTransactions?: MaterialTransactionOrderByRelationAggregateInput
    labMaterials?: LabMaterialOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    approved?: BoolFilter<"User"> | boolean
    sessionVersion?: IntFilter<"User"> | number
    invoices?: InvoiceListRelationFilter
    patients?: PatientListRelationFilter
    purchaseInvoices?: PurchaseInvoiceListRelationFilter
    radiationResults?: RadiationResultListRelationFilter
    reports?: ReportListRelationFilter
    samples?: SampleListRelationFilter
    testAssignments?: TestAssignmentListRelationFilter
    materialTransactions?: MaterialTransactionListRelationFilter
    labMaterials?: LabMaterialListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approved?: SortOrder
    sessionVersion?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    approved?: BoolWithAggregatesFilter<"User"> | boolean
    sessionVersion?: IntWithAggregatesFilter<"User"> | number
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    fileNumber?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    phone?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    gender?: EnumGenderFilter<"Patient"> | $Enums.Gender
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    createdById?: StringFilter<"Patient"> | string
    invoices?: InvoiceListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    queueNumbers?: QueueNumberListRelationFilter
    radiationResults?: RadiationResultListRelationFilter
    testAssignments?: TestAssignmentListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    fileNumber?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    invoices?: InvoiceOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    queueNumbers?: QueueNumberOrderByRelationAggregateInput
    radiationResults?: RadiationResultOrderByRelationAggregateInput
    testAssignments?: TestAssignmentOrderByRelationAggregateInput
    _relevance?: PatientOrderByRelevanceInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fileNumber?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    name?: StringFilter<"Patient"> | string
    phone?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    gender?: EnumGenderFilter<"Patient"> | $Enums.Gender
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    createdById?: StringFilter<"Patient"> | string
    invoices?: InvoiceListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    queueNumbers?: QueueNumberListRelationFilter
    radiationResults?: RadiationResultListRelationFilter
    testAssignments?: TestAssignmentListRelationFilter
  }, "id" | "fileNumber">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    fileNumber?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    fileNumber?: StringWithAggregatesFilter<"Patient"> | string
    name?: StringWithAggregatesFilter<"Patient"> | string
    phone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    address?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    gender?: EnumGenderWithAggregatesFilter<"Patient"> | $Enums.Gender
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    createdById?: StringWithAggregatesFilter<"Patient"> | string
  }

  export type TestWhereInput = {
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    id?: StringFilter<"Test"> | string
    name?: StringFilter<"Test"> | string
    category?: StringFilter<"Test"> | string
    price?: FloatFilter<"Test"> | number
    description?: StringNullableFilter<"Test"> | string | null
    createdAt?: DateTimeFilter<"Test"> | Date | string
    updatedAt?: DateTimeFilter<"Test"> | Date | string
    testAssignments?: TestAssignmentListRelationFilter
  }

  export type TestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    testAssignments?: TestAssignmentOrderByRelationAggregateInput
    _relevance?: TestOrderByRelevanceInput
  }

  export type TestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    name?: StringFilter<"Test"> | string
    category?: StringFilter<"Test"> | string
    price?: FloatFilter<"Test"> | number
    description?: StringNullableFilter<"Test"> | string | null
    createdAt?: DateTimeFilter<"Test"> | Date | string
    updatedAt?: DateTimeFilter<"Test"> | Date | string
    testAssignments?: TestAssignmentListRelationFilter
  }, "id">

  export type TestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestCountOrderByAggregateInput
    _avg?: TestAvgOrderByAggregateInput
    _max?: TestMaxOrderByAggregateInput
    _min?: TestMinOrderByAggregateInput
    _sum?: TestSumOrderByAggregateInput
  }

  export type TestScalarWhereWithAggregatesInput = {
    AND?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    OR?: TestScalarWhereWithAggregatesInput[]
    NOT?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Test"> | string
    name?: StringWithAggregatesFilter<"Test"> | string
    category?: StringWithAggregatesFilter<"Test"> | string
    price?: FloatWithAggregatesFilter<"Test"> | number
    description?: StringNullableWithAggregatesFilter<"Test"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Test"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Test"> | Date | string
  }

  export type TestAssignmentWhereInput = {
    AND?: TestAssignmentWhereInput | TestAssignmentWhereInput[]
    OR?: TestAssignmentWhereInput[]
    NOT?: TestAssignmentWhereInput | TestAssignmentWhereInput[]
    id?: StringFilter<"TestAssignment"> | string
    patientId?: StringFilter<"TestAssignment"> | string
    testId?: StringFilter<"TestAssignment"> | string
    status?: EnumTestStatusFilter<"TestAssignment"> | $Enums.TestStatus
    assignedById?: StringFilter<"TestAssignment"> | string
    assignedAt?: DateTimeFilter<"TestAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TestAssignment"> | Date | string
    invoiceItems?: InvoiceItemListRelationFilter
    radiationResults?: RadiationResultListRelationFilter
    samples?: SampleListRelationFilter
    assignedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    test?: XOR<TestScalarRelationFilter, TestWhereInput>
  }

  export type TestAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    updatedAt?: SortOrder
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
    radiationResults?: RadiationResultOrderByRelationAggregateInput
    samples?: SampleOrderByRelationAggregateInput
    assignedBy?: UserOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    test?: TestOrderByWithRelationInput
    _relevance?: TestAssignmentOrderByRelevanceInput
  }

  export type TestAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    patientId_testId?: TestAssignmentPatientIdTestIdCompoundUniqueInput
    AND?: TestAssignmentWhereInput | TestAssignmentWhereInput[]
    OR?: TestAssignmentWhereInput[]
    NOT?: TestAssignmentWhereInput | TestAssignmentWhereInput[]
    patientId?: StringFilter<"TestAssignment"> | string
    testId?: StringFilter<"TestAssignment"> | string
    status?: EnumTestStatusFilter<"TestAssignment"> | $Enums.TestStatus
    assignedById?: StringFilter<"TestAssignment"> | string
    assignedAt?: DateTimeFilter<"TestAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TestAssignment"> | Date | string
    invoiceItems?: InvoiceItemListRelationFilter
    radiationResults?: RadiationResultListRelationFilter
    samples?: SampleListRelationFilter
    assignedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    test?: XOR<TestScalarRelationFilter, TestWhereInput>
  }, "id" | "patientId_testId">

  export type TestAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestAssignmentCountOrderByAggregateInput
    _max?: TestAssignmentMaxOrderByAggregateInput
    _min?: TestAssignmentMinOrderByAggregateInput
  }

  export type TestAssignmentScalarWhereWithAggregatesInput = {
    AND?: TestAssignmentScalarWhereWithAggregatesInput | TestAssignmentScalarWhereWithAggregatesInput[]
    OR?: TestAssignmentScalarWhereWithAggregatesInput[]
    NOT?: TestAssignmentScalarWhereWithAggregatesInput | TestAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestAssignment"> | string
    patientId?: StringWithAggregatesFilter<"TestAssignment"> | string
    testId?: StringWithAggregatesFilter<"TestAssignment"> | string
    status?: EnumTestStatusWithAggregatesFilter<"TestAssignment"> | $Enums.TestStatus
    assignedById?: StringWithAggregatesFilter<"TestAssignment"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"TestAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestAssignment"> | Date | string
  }

  export type SampleWhereInput = {
    AND?: SampleWhereInput | SampleWhereInput[]
    OR?: SampleWhereInput[]
    NOT?: SampleWhereInput | SampleWhereInput[]
    id?: StringFilter<"Sample"> | string
    testAssignmentId?: StringFilter<"Sample"> | string
    sampleCode?: StringFilter<"Sample"> | string
    collectedAt?: DateTimeFilter<"Sample"> | Date | string
    collectedById?: StringFilter<"Sample"> | string
    notes?: StringNullableFilter<"Sample"> | string | null
    results?: StringNullableFilter<"Sample"> | string | null
    reportPdfUrl?: StringNullableFilter<"Sample"> | string | null
    collectedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    testAssignment?: XOR<TestAssignmentScalarRelationFilter, TestAssignmentWhereInput>
  }

  export type SampleOrderByWithRelationInput = {
    id?: SortOrder
    testAssignmentId?: SortOrder
    sampleCode?: SortOrder
    collectedAt?: SortOrder
    collectedById?: SortOrder
    notes?: SortOrderInput | SortOrder
    results?: SortOrderInput | SortOrder
    reportPdfUrl?: SortOrderInput | SortOrder
    collectedBy?: UserOrderByWithRelationInput
    testAssignment?: TestAssignmentOrderByWithRelationInput
    _relevance?: SampleOrderByRelevanceInput
  }

  export type SampleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sampleCode?: string
    AND?: SampleWhereInput | SampleWhereInput[]
    OR?: SampleWhereInput[]
    NOT?: SampleWhereInput | SampleWhereInput[]
    testAssignmentId?: StringFilter<"Sample"> | string
    collectedAt?: DateTimeFilter<"Sample"> | Date | string
    collectedById?: StringFilter<"Sample"> | string
    notes?: StringNullableFilter<"Sample"> | string | null
    results?: StringNullableFilter<"Sample"> | string | null
    reportPdfUrl?: StringNullableFilter<"Sample"> | string | null
    collectedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    testAssignment?: XOR<TestAssignmentScalarRelationFilter, TestAssignmentWhereInput>
  }, "id" | "sampleCode">

  export type SampleOrderByWithAggregationInput = {
    id?: SortOrder
    testAssignmentId?: SortOrder
    sampleCode?: SortOrder
    collectedAt?: SortOrder
    collectedById?: SortOrder
    notes?: SortOrderInput | SortOrder
    results?: SortOrderInput | SortOrder
    reportPdfUrl?: SortOrderInput | SortOrder
    _count?: SampleCountOrderByAggregateInput
    _max?: SampleMaxOrderByAggregateInput
    _min?: SampleMinOrderByAggregateInput
  }

  export type SampleScalarWhereWithAggregatesInput = {
    AND?: SampleScalarWhereWithAggregatesInput | SampleScalarWhereWithAggregatesInput[]
    OR?: SampleScalarWhereWithAggregatesInput[]
    NOT?: SampleScalarWhereWithAggregatesInput | SampleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sample"> | string
    testAssignmentId?: StringWithAggregatesFilter<"Sample"> | string
    sampleCode?: StringWithAggregatesFilter<"Sample"> | string
    collectedAt?: DateTimeWithAggregatesFilter<"Sample"> | Date | string
    collectedById?: StringWithAggregatesFilter<"Sample"> | string
    notes?: StringNullableWithAggregatesFilter<"Sample"> | string | null
    results?: StringNullableWithAggregatesFilter<"Sample"> | string | null
    reportPdfUrl?: StringNullableWithAggregatesFilter<"Sample"> | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    patientId?: StringFilter<"Invoice"> | string
    totalAmount?: FloatFilter<"Invoice"> | number
    paidAmount?: FloatFilter<"Invoice"> | number
    isPaid?: BoolFilter<"Invoice"> | boolean
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdById?: StringFilter<"Invoice"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    items?: InvoiceItemListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    isPaid?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
    _relevance?: InvoiceOrderByRelevanceInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    patientId?: StringFilter<"Invoice"> | string
    totalAmount?: FloatFilter<"Invoice"> | number
    paidAmount?: FloatFilter<"Invoice"> | number
    isPaid?: BoolFilter<"Invoice"> | boolean
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdById?: StringFilter<"Invoice"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    items?: InvoiceItemListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    isPaid?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdById?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    patientId?: StringWithAggregatesFilter<"Invoice"> | string
    totalAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    paidAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    isPaid?: BoolWithAggregatesFilter<"Invoice"> | boolean
    invoiceDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    createdById?: StringWithAggregatesFilter<"Invoice"> | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    testAssignmentId?: StringFilter<"InvoiceItem"> | string
    price?: FloatFilter<"InvoiceItem"> | number
    quantity?: IntFilter<"InvoiceItem"> | number
    subtotal?: FloatFilter<"InvoiceItem"> | number
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    testAssignment?: XOR<TestAssignmentScalarRelationFilter, TestAssignmentWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    testAssignmentId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    subtotal?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    testAssignment?: TestAssignmentOrderByWithRelationInput
    _relevance?: InvoiceItemOrderByRelevanceInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: StringFilter<"InvoiceItem"> | string
    testAssignmentId?: StringFilter<"InvoiceItem"> | string
    price?: FloatFilter<"InvoiceItem"> | number
    quantity?: IntFilter<"InvoiceItem"> | number
    subtotal?: FloatFilter<"InvoiceItem"> | number
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    testAssignment?: XOR<TestAssignmentScalarRelationFilter, TestAssignmentWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    testAssignmentId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    subtotal?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceItem"> | string
    testAssignmentId?: StringWithAggregatesFilter<"InvoiceItem"> | string
    price?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    quantity?: IntWithAggregatesFilter<"InvoiceItem"> | number
    subtotal?: FloatWithAggregatesFilter<"InvoiceItem"> | number
  }

  export type QueueNumberWhereInput = {
    AND?: QueueNumberWhereInput | QueueNumberWhereInput[]
    OR?: QueueNumberWhereInput[]
    NOT?: QueueNumberWhereInput | QueueNumberWhereInput[]
    id?: StringFilter<"QueueNumber"> | string
    number?: IntFilter<"QueueNumber"> | number
    patientId?: StringFilter<"QueueNumber"> | string
    date?: DateTimeFilter<"QueueNumber"> | Date | string
    status?: EnumQueueStatusFilter<"QueueNumber"> | $Enums.QueueStatus
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type QueueNumberOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    patient?: PatientOrderByWithRelationInput
    _relevance?: QueueNumberOrderByRelevanceInput
  }

  export type QueueNumberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    date_number?: QueueNumberDateNumberCompoundUniqueInput
    AND?: QueueNumberWhereInput | QueueNumberWhereInput[]
    OR?: QueueNumberWhereInput[]
    NOT?: QueueNumberWhereInput | QueueNumberWhereInput[]
    number?: IntFilter<"QueueNumber"> | number
    patientId?: StringFilter<"QueueNumber"> | string
    date?: DateTimeFilter<"QueueNumber"> | Date | string
    status?: EnumQueueStatusFilter<"QueueNumber"> | $Enums.QueueStatus
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id" | "date_number">

  export type QueueNumberOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    _count?: QueueNumberCountOrderByAggregateInput
    _avg?: QueueNumberAvgOrderByAggregateInput
    _max?: QueueNumberMaxOrderByAggregateInput
    _min?: QueueNumberMinOrderByAggregateInput
    _sum?: QueueNumberSumOrderByAggregateInput
  }

  export type QueueNumberScalarWhereWithAggregatesInput = {
    AND?: QueueNumberScalarWhereWithAggregatesInput | QueueNumberScalarWhereWithAggregatesInput[]
    OR?: QueueNumberScalarWhereWithAggregatesInput[]
    NOT?: QueueNumberScalarWhereWithAggregatesInput | QueueNumberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QueueNumber"> | string
    number?: IntWithAggregatesFilter<"QueueNumber"> | number
    patientId?: StringWithAggregatesFilter<"QueueNumber"> | string
    date?: DateTimeWithAggregatesFilter<"QueueNumber"> | Date | string
    status?: EnumQueueStatusWithAggregatesFilter<"QueueNumber"> | $Enums.QueueStatus
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    title?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    description?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    startDate?: DateTimeFilter<"Report"> | Date | string
    endDate?: DateTimeFilter<"Report"> | Date | string
    pdfUrl?: StringNullableFilter<"Report"> | string | null
    createdById?: StringFilter<"Report"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    _relevance?: ReportOrderByRelevanceInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    title?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    description?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    startDate?: DateTimeFilter<"Report"> | Date | string
    endDate?: DateTimeFilter<"Report"> | Date | string
    pdfUrl?: StringNullableFilter<"Report"> | string | null
    createdById?: StringFilter<"Report"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdById?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    title?: StringWithAggregatesFilter<"Report"> | string
    type?: EnumReportTypeWithAggregatesFilter<"Report"> | $Enums.ReportType
    description?: StringNullableWithAggregatesFilter<"Report"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    startDate?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    pdfUrl?: StringNullableWithAggregatesFilter<"Report"> | string | null
    createdById?: StringWithAggregatesFilter<"Report"> | string
  }

  export type PurchaseInvoiceWhereInput = {
    AND?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    OR?: PurchaseInvoiceWhereInput[]
    NOT?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    id?: StringFilter<"PurchaseInvoice"> | string
    supplierName?: StringFilter<"PurchaseInvoice"> | string
    invoiceNumber?: StringNullableFilter<"PurchaseInvoice"> | string | null
    totalAmount?: FloatFilter<"PurchaseInvoice"> | number
    paidAmount?: FloatFilter<"PurchaseInvoice"> | number
    isPaid?: BoolFilter<"PurchaseInvoice"> | boolean
    invoiceDate?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"PurchaseInvoice"> | Date | string | null
    notes?: StringNullableFilter<"PurchaseInvoice"> | string | null
    createdById?: StringFilter<"PurchaseInvoice"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: PurchaseInvoiceItemListRelationFilter
  }

  export type PurchaseInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    supplierName?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    isPaid?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    items?: PurchaseInvoiceItemOrderByRelationAggregateInput
    _relevance?: PurchaseInvoiceOrderByRelevanceInput
  }

  export type PurchaseInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    OR?: PurchaseInvoiceWhereInput[]
    NOT?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    supplierName?: StringFilter<"PurchaseInvoice"> | string
    invoiceNumber?: StringNullableFilter<"PurchaseInvoice"> | string | null
    totalAmount?: FloatFilter<"PurchaseInvoice"> | number
    paidAmount?: FloatFilter<"PurchaseInvoice"> | number
    isPaid?: BoolFilter<"PurchaseInvoice"> | boolean
    invoiceDate?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"PurchaseInvoice"> | Date | string | null
    notes?: StringNullableFilter<"PurchaseInvoice"> | string | null
    createdById?: StringFilter<"PurchaseInvoice"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: PurchaseInvoiceItemListRelationFilter
  }, "id">

  export type PurchaseInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    supplierName?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    isPaid?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrder
    _count?: PurchaseInvoiceCountOrderByAggregateInput
    _avg?: PurchaseInvoiceAvgOrderByAggregateInput
    _max?: PurchaseInvoiceMaxOrderByAggregateInput
    _min?: PurchaseInvoiceMinOrderByAggregateInput
    _sum?: PurchaseInvoiceSumOrderByAggregateInput
  }

  export type PurchaseInvoiceScalarWhereWithAggregatesInput = {
    AND?: PurchaseInvoiceScalarWhereWithAggregatesInput | PurchaseInvoiceScalarWhereWithAggregatesInput[]
    OR?: PurchaseInvoiceScalarWhereWithAggregatesInput[]
    NOT?: PurchaseInvoiceScalarWhereWithAggregatesInput | PurchaseInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
    supplierName?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
    invoiceNumber?: StringNullableWithAggregatesFilter<"PurchaseInvoice"> | string | null
    totalAmount?: FloatWithAggregatesFilter<"PurchaseInvoice"> | number
    paidAmount?: FloatWithAggregatesFilter<"PurchaseInvoice"> | number
    isPaid?: BoolWithAggregatesFilter<"PurchaseInvoice"> | boolean
    invoiceDate?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"PurchaseInvoice"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"PurchaseInvoice"> | string | null
    createdById?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
  }

  export type PurchaseInvoiceItemWhereInput = {
    AND?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    OR?: PurchaseInvoiceItemWhereInput[]
    NOT?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    id?: StringFilter<"PurchaseInvoiceItem"> | string
    invoiceId?: StringFilter<"PurchaseInvoiceItem"> | string
    itemName?: StringFilter<"PurchaseInvoiceItem"> | string
    description?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    quantity?: IntFilter<"PurchaseInvoiceItem"> | number
    unitPrice?: FloatFilter<"PurchaseInvoiceItem"> | number
    subtotal?: FloatFilter<"PurchaseInvoiceItem"> | number
    invoice?: XOR<PurchaseInvoiceScalarRelationFilter, PurchaseInvoiceWhereInput>
  }

  export type PurchaseInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemName?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    invoice?: PurchaseInvoiceOrderByWithRelationInput
    _relevance?: PurchaseInvoiceItemOrderByRelevanceInput
  }

  export type PurchaseInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    OR?: PurchaseInvoiceItemWhereInput[]
    NOT?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    invoiceId?: StringFilter<"PurchaseInvoiceItem"> | string
    itemName?: StringFilter<"PurchaseInvoiceItem"> | string
    description?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    quantity?: IntFilter<"PurchaseInvoiceItem"> | number
    unitPrice?: FloatFilter<"PurchaseInvoiceItem"> | number
    subtotal?: FloatFilter<"PurchaseInvoiceItem"> | number
    invoice?: XOR<PurchaseInvoiceScalarRelationFilter, PurchaseInvoiceWhereInput>
  }, "id">

  export type PurchaseInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemName?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    _count?: PurchaseInvoiceItemCountOrderByAggregateInput
    _avg?: PurchaseInvoiceItemAvgOrderByAggregateInput
    _max?: PurchaseInvoiceItemMaxOrderByAggregateInput
    _min?: PurchaseInvoiceItemMinOrderByAggregateInput
    _sum?: PurchaseInvoiceItemSumOrderByAggregateInput
  }

  export type PurchaseInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseInvoiceItemScalarWhereWithAggregatesInput | PurchaseInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseInvoiceItemScalarWhereWithAggregatesInput | PurchaseInvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseInvoiceItem"> | string
    invoiceId?: StringWithAggregatesFilter<"PurchaseInvoiceItem"> | string
    itemName?: StringWithAggregatesFilter<"PurchaseInvoiceItem"> | string
    description?: StringNullableWithAggregatesFilter<"PurchaseInvoiceItem"> | string | null
    quantity?: IntWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    subtotal?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
  }

  export type RadiationResultWhereInput = {
    AND?: RadiationResultWhereInput | RadiationResultWhereInput[]
    OR?: RadiationResultWhereInput[]
    NOT?: RadiationResultWhereInput | RadiationResultWhereInput[]
    id?: StringFilter<"RadiationResult"> | string
    title?: StringFilter<"RadiationResult"> | string
    description?: StringNullableFilter<"RadiationResult"> | string | null
    resultDetails?: StringFilter<"RadiationResult"> | string
    reportText?: StringNullableFilter<"RadiationResult"> | string | null
    imageUrl?: StringNullableFilter<"RadiationResult"> | string | null
    pdfUrl?: StringNullableFilter<"RadiationResult"> | string | null
    patientId?: StringFilter<"RadiationResult"> | string
    testAssignmentId?: StringFilter<"RadiationResult"> | string
    createdById?: StringFilter<"RadiationResult"> | string
    createdAt?: DateTimeFilter<"RadiationResult"> | Date | string
    updatedAt?: DateTimeFilter<"RadiationResult"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    testAssignment?: XOR<TestAssignmentScalarRelationFilter, TestAssignmentWhereInput>
  }

  export type RadiationResultOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    resultDetails?: SortOrder
    reportText?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    patientId?: SortOrder
    testAssignmentId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    testAssignment?: TestAssignmentOrderByWithRelationInput
    _relevance?: RadiationResultOrderByRelevanceInput
  }

  export type RadiationResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RadiationResultWhereInput | RadiationResultWhereInput[]
    OR?: RadiationResultWhereInput[]
    NOT?: RadiationResultWhereInput | RadiationResultWhereInput[]
    title?: StringFilter<"RadiationResult"> | string
    description?: StringNullableFilter<"RadiationResult"> | string | null
    resultDetails?: StringFilter<"RadiationResult"> | string
    reportText?: StringNullableFilter<"RadiationResult"> | string | null
    imageUrl?: StringNullableFilter<"RadiationResult"> | string | null
    pdfUrl?: StringNullableFilter<"RadiationResult"> | string | null
    patientId?: StringFilter<"RadiationResult"> | string
    testAssignmentId?: StringFilter<"RadiationResult"> | string
    createdById?: StringFilter<"RadiationResult"> | string
    createdAt?: DateTimeFilter<"RadiationResult"> | Date | string
    updatedAt?: DateTimeFilter<"RadiationResult"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    testAssignment?: XOR<TestAssignmentScalarRelationFilter, TestAssignmentWhereInput>
  }, "id">

  export type RadiationResultOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    resultDetails?: SortOrder
    reportText?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    patientId?: SortOrder
    testAssignmentId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RadiationResultCountOrderByAggregateInput
    _max?: RadiationResultMaxOrderByAggregateInput
    _min?: RadiationResultMinOrderByAggregateInput
  }

  export type RadiationResultScalarWhereWithAggregatesInput = {
    AND?: RadiationResultScalarWhereWithAggregatesInput | RadiationResultScalarWhereWithAggregatesInput[]
    OR?: RadiationResultScalarWhereWithAggregatesInput[]
    NOT?: RadiationResultScalarWhereWithAggregatesInput | RadiationResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RadiationResult"> | string
    title?: StringWithAggregatesFilter<"RadiationResult"> | string
    description?: StringNullableWithAggregatesFilter<"RadiationResult"> | string | null
    resultDetails?: StringWithAggregatesFilter<"RadiationResult"> | string
    reportText?: StringNullableWithAggregatesFilter<"RadiationResult"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"RadiationResult"> | string | null
    pdfUrl?: StringNullableWithAggregatesFilter<"RadiationResult"> | string | null
    patientId?: StringWithAggregatesFilter<"RadiationResult"> | string
    testAssignmentId?: StringWithAggregatesFilter<"RadiationResult"> | string
    createdById?: StringWithAggregatesFilter<"RadiationResult"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RadiationResult"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RadiationResult"> | Date | string
  }

  export type LabMaterialWhereInput = {
    AND?: LabMaterialWhereInput | LabMaterialWhereInput[]
    OR?: LabMaterialWhereInput[]
    NOT?: LabMaterialWhereInput | LabMaterialWhereInput[]
    id?: StringFilter<"LabMaterial"> | string
    name?: StringFilter<"LabMaterial"> | string
    code?: StringNullableFilter<"LabMaterial"> | string | null
    category?: EnumMaterialCategoryFilter<"LabMaterial"> | $Enums.MaterialCategory
    description?: StringNullableFilter<"LabMaterial"> | string | null
    unit?: StringFilter<"LabMaterial"> | string
    currentQuantity?: FloatFilter<"LabMaterial"> | number
    minimumQuantity?: FloatFilter<"LabMaterial"> | number
    price?: FloatNullableFilter<"LabMaterial"> | number | null
    supplier?: StringNullableFilter<"LabMaterial"> | string | null
    expiryDate?: DateTimeNullableFilter<"LabMaterial"> | Date | string | null
    location?: StringNullableFilter<"LabMaterial"> | string | null
    notes?: StringNullableFilter<"LabMaterial"> | string | null
    createdAt?: DateTimeFilter<"LabMaterial"> | Date | string
    updatedAt?: DateTimeFilter<"LabMaterial"> | Date | string
    createdById?: StringNullableFilter<"LabMaterial"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    transactions?: MaterialTransactionListRelationFilter
  }

  export type LabMaterialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    currentQuantity?: SortOrder
    minimumQuantity?: SortOrder
    price?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    transactions?: MaterialTransactionOrderByRelationAggregateInput
    _relevance?: LabMaterialOrderByRelevanceInput
  }

  export type LabMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabMaterialWhereInput | LabMaterialWhereInput[]
    OR?: LabMaterialWhereInput[]
    NOT?: LabMaterialWhereInput | LabMaterialWhereInput[]
    name?: StringFilter<"LabMaterial"> | string
    code?: StringNullableFilter<"LabMaterial"> | string | null
    category?: EnumMaterialCategoryFilter<"LabMaterial"> | $Enums.MaterialCategory
    description?: StringNullableFilter<"LabMaterial"> | string | null
    unit?: StringFilter<"LabMaterial"> | string
    currentQuantity?: FloatFilter<"LabMaterial"> | number
    minimumQuantity?: FloatFilter<"LabMaterial"> | number
    price?: FloatNullableFilter<"LabMaterial"> | number | null
    supplier?: StringNullableFilter<"LabMaterial"> | string | null
    expiryDate?: DateTimeNullableFilter<"LabMaterial"> | Date | string | null
    location?: StringNullableFilter<"LabMaterial"> | string | null
    notes?: StringNullableFilter<"LabMaterial"> | string | null
    createdAt?: DateTimeFilter<"LabMaterial"> | Date | string
    updatedAt?: DateTimeFilter<"LabMaterial"> | Date | string
    createdById?: StringNullableFilter<"LabMaterial"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    transactions?: MaterialTransactionListRelationFilter
  }, "id">

  export type LabMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    currentQuantity?: SortOrder
    minimumQuantity?: SortOrder
    price?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: LabMaterialCountOrderByAggregateInput
    _avg?: LabMaterialAvgOrderByAggregateInput
    _max?: LabMaterialMaxOrderByAggregateInput
    _min?: LabMaterialMinOrderByAggregateInput
    _sum?: LabMaterialSumOrderByAggregateInput
  }

  export type LabMaterialScalarWhereWithAggregatesInput = {
    AND?: LabMaterialScalarWhereWithAggregatesInput | LabMaterialScalarWhereWithAggregatesInput[]
    OR?: LabMaterialScalarWhereWithAggregatesInput[]
    NOT?: LabMaterialScalarWhereWithAggregatesInput | LabMaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LabMaterial"> | string
    name?: StringWithAggregatesFilter<"LabMaterial"> | string
    code?: StringNullableWithAggregatesFilter<"LabMaterial"> | string | null
    category?: EnumMaterialCategoryWithAggregatesFilter<"LabMaterial"> | $Enums.MaterialCategory
    description?: StringNullableWithAggregatesFilter<"LabMaterial"> | string | null
    unit?: StringWithAggregatesFilter<"LabMaterial"> | string
    currentQuantity?: FloatWithAggregatesFilter<"LabMaterial"> | number
    minimumQuantity?: FloatWithAggregatesFilter<"LabMaterial"> | number
    price?: FloatNullableWithAggregatesFilter<"LabMaterial"> | number | null
    supplier?: StringNullableWithAggregatesFilter<"LabMaterial"> | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"LabMaterial"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"LabMaterial"> | string | null
    notes?: StringNullableWithAggregatesFilter<"LabMaterial"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LabMaterial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LabMaterial"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"LabMaterial"> | string | null
  }

  export type MaterialTransactionWhereInput = {
    AND?: MaterialTransactionWhereInput | MaterialTransactionWhereInput[]
    OR?: MaterialTransactionWhereInput[]
    NOT?: MaterialTransactionWhereInput | MaterialTransactionWhereInput[]
    id?: StringFilter<"MaterialTransaction"> | string
    materialId?: StringFilter<"MaterialTransaction"> | string
    type?: EnumTransactionTypeFilter<"MaterialTransaction"> | $Enums.TransactionType
    quantity?: FloatFilter<"MaterialTransaction"> | number
    previousQuantity?: FloatFilter<"MaterialTransaction"> | number
    newQuantity?: FloatFilter<"MaterialTransaction"> | number
    reason?: StringNullableFilter<"MaterialTransaction"> | string | null
    batchNumber?: StringNullableFilter<"MaterialTransaction"> | string | null
    invoiceNumber?: StringNullableFilter<"MaterialTransaction"> | string | null
    createdAt?: DateTimeFilter<"MaterialTransaction"> | Date | string
    createdById?: StringFilter<"MaterialTransaction"> | string
    material?: XOR<LabMaterialScalarRelationFilter, LabMaterialWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MaterialTransactionOrderByWithRelationInput = {
    id?: SortOrder
    materialId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousQuantity?: SortOrder
    newQuantity?: SortOrder
    reason?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    material?: LabMaterialOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    _relevance?: MaterialTransactionOrderByRelevanceInput
  }

  export type MaterialTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaterialTransactionWhereInput | MaterialTransactionWhereInput[]
    OR?: MaterialTransactionWhereInput[]
    NOT?: MaterialTransactionWhereInput | MaterialTransactionWhereInput[]
    materialId?: StringFilter<"MaterialTransaction"> | string
    type?: EnumTransactionTypeFilter<"MaterialTransaction"> | $Enums.TransactionType
    quantity?: FloatFilter<"MaterialTransaction"> | number
    previousQuantity?: FloatFilter<"MaterialTransaction"> | number
    newQuantity?: FloatFilter<"MaterialTransaction"> | number
    reason?: StringNullableFilter<"MaterialTransaction"> | string | null
    batchNumber?: StringNullableFilter<"MaterialTransaction"> | string | null
    invoiceNumber?: StringNullableFilter<"MaterialTransaction"> | string | null
    createdAt?: DateTimeFilter<"MaterialTransaction"> | Date | string
    createdById?: StringFilter<"MaterialTransaction"> | string
    material?: XOR<LabMaterialScalarRelationFilter, LabMaterialWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MaterialTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    materialId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousQuantity?: SortOrder
    newQuantity?: SortOrder
    reason?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    _count?: MaterialTransactionCountOrderByAggregateInput
    _avg?: MaterialTransactionAvgOrderByAggregateInput
    _max?: MaterialTransactionMaxOrderByAggregateInput
    _min?: MaterialTransactionMinOrderByAggregateInput
    _sum?: MaterialTransactionSumOrderByAggregateInput
  }

  export type MaterialTransactionScalarWhereWithAggregatesInput = {
    AND?: MaterialTransactionScalarWhereWithAggregatesInput | MaterialTransactionScalarWhereWithAggregatesInput[]
    OR?: MaterialTransactionScalarWhereWithAggregatesInput[]
    NOT?: MaterialTransactionScalarWhereWithAggregatesInput | MaterialTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaterialTransaction"> | string
    materialId?: StringWithAggregatesFilter<"MaterialTransaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"MaterialTransaction"> | $Enums.TransactionType
    quantity?: FloatWithAggregatesFilter<"MaterialTransaction"> | number
    previousQuantity?: FloatWithAggregatesFilter<"MaterialTransaction"> | number
    newQuantity?: FloatWithAggregatesFilter<"MaterialTransaction"> | number
    reason?: StringNullableWithAggregatesFilter<"MaterialTransaction"> | string | null
    batchNumber?: StringNullableWithAggregatesFilter<"MaterialTransaction"> | string | null
    invoiceNumber?: StringNullableWithAggregatesFilter<"MaterialTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MaterialTransaction"> | Date | string
    createdById?: StringWithAggregatesFilter<"MaterialTransaction"> | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    patients?: PatientCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultCreateNestedManyWithoutCreatedByInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    samples?: SampleCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    patients?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutCreatedByInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    samples?: SampleUncheckedCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUncheckedUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
  }

  export type PatientCreateInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    createdBy: UserCreateNestedOneWithoutPatientsInput
    queueNumbers?: QueueNumberCreateNestedManyWithoutPatientInput
    radiationResults?: RadiationResultCreateNestedManyWithoutPatientInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    queueNumbers?: QueueNumberUncheckedCreateNestedManyWithoutPatientInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutPatientInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPatientsNestedInput
    queueNumbers?: QueueNumberUpdateManyWithoutPatientNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutPatientNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    queueNumbers?: QueueNumberUncheckedUpdateManyWithoutPatientNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutPatientNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type TestCreateInput = {
    id?: string
    name: string
    category: string
    price: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testAssignments?: TestAssignmentCreateNestedManyWithoutTestInput
  }

  export type TestUncheckedCreateInput = {
    id?: string
    name: string
    category: string
    price: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testAssignments?: TestAssignmentUpdateManyWithoutTestNestedInput
  }

  export type TestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestCreateManyInput = {
    id?: string
    name: string
    category: string
    price: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestAssignmentCreateInput = {
    id?: string
    status?: $Enums.TestStatus
    assignedAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTestAssignmentInput
    radiationResults?: RadiationResultCreateNestedManyWithoutTestAssignmentInput
    samples?: SampleCreateNestedManyWithoutTestAssignmentInput
    assignedBy: UserCreateNestedOneWithoutTestAssignmentsInput
    patient: PatientCreateNestedOneWithoutTestAssignmentsInput
    test: TestCreateNestedOneWithoutTestAssignmentsInput
  }

  export type TestAssignmentUncheckedCreateInput = {
    id?: string
    patientId: string
    testId: string
    status?: $Enums.TestStatus
    assignedById: string
    assignedAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTestAssignmentInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutTestAssignmentInput
    samples?: SampleUncheckedCreateNestedManyWithoutTestAssignmentInput
  }

  export type TestAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUpdateManyWithoutTestAssignmentNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutTestAssignmentNestedInput
    samples?: SampleUpdateManyWithoutTestAssignmentNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutTestAssignmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutTestAssignmentsNestedInput
    test?: TestUpdateOneRequiredWithoutTestAssignmentsNestedInput
  }

  export type TestAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTestAssignmentNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutTestAssignmentNestedInput
    samples?: SampleUncheckedUpdateManyWithoutTestAssignmentNestedInput
  }

  export type TestAssignmentCreateManyInput = {
    id?: string
    patientId: string
    testId: string
    status?: $Enums.TestStatus
    assignedById: string
    assignedAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleCreateInput = {
    id?: string
    sampleCode: string
    collectedAt?: Date | string
    notes?: string | null
    results?: string | null
    reportPdfUrl?: string | null
    collectedBy: UserCreateNestedOneWithoutSamplesInput
    testAssignment: TestAssignmentCreateNestedOneWithoutSamplesInput
  }

  export type SampleUncheckedCreateInput = {
    id?: string
    testAssignmentId: string
    sampleCode: string
    collectedAt?: Date | string
    collectedById: string
    notes?: string | null
    results?: string | null
    reportPdfUrl?: string | null
  }

  export type SampleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: UserUpdateOneRequiredWithoutSamplesNestedInput
    testAssignment?: TestAssignmentUpdateOneRequiredWithoutSamplesNestedInput
  }

  export type SampleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SampleCreateManyInput = {
    id?: string
    testAssignmentId: string
    sampleCode: string
    collectedAt?: Date | string
    collectedById: string
    notes?: string | null
    results?: string | null
    reportPdfUrl?: string | null
  }

  export type SampleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SampleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateInput = {
    id?: string
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    createdBy: UserCreateNestedOneWithoutInvoicesInput
    patient: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    patientId: string
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    createdById: string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    patientId: string
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    createdById: string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceItemCreateInput = {
    id?: string
    price: number
    quantity?: number
    subtotal: number
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    testAssignment: TestAssignmentCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    testAssignmentId: string
    price: number
    quantity?: number
    subtotal: number
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    testAssignment?: TestAssignmentUpdateOneRequiredWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    testAssignmentId: string
    price: number
    quantity?: number
    subtotal: number
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
  }

  export type QueueNumberCreateInput = {
    id?: string
    number: number
    date?: Date | string
    status?: $Enums.QueueStatus
    patient: PatientCreateNestedOneWithoutQueueNumbersInput
  }

  export type QueueNumberUncheckedCreateInput = {
    id?: string
    number: number
    patientId: string
    date?: Date | string
    status?: $Enums.QueueStatus
  }

  export type QueueNumberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    patient?: PatientUpdateOneRequiredWithoutQueueNumbersNestedInput
  }

  export type QueueNumberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
  }

  export type QueueNumberCreateManyInput = {
    id?: string
    number: number
    patientId: string
    date?: Date | string
    status?: $Enums.QueueStatus
  }

  export type QueueNumberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
  }

  export type QueueNumberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
  }

  export type ReportCreateInput = {
    id?: string
    title: string
    type: $Enums.ReportType
    description?: string | null
    createdAt?: Date | string
    startDate: Date | string
    endDate: Date | string
    pdfUrl?: string | null
    createdBy: UserCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    title: string
    type: $Enums.ReportType
    description?: string | null
    createdAt?: Date | string
    startDate: Date | string
    endDate: Date | string
    pdfUrl?: string | null
    createdById: string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ReportCreateManyInput = {
    id?: string
    title: string
    type: $Enums.ReportType
    description?: string | null
    createdAt?: Date | string
    startDate: Date | string
    endDate: Date | string
    pdfUrl?: string | null
    createdById: string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseInvoiceCreateInput = {
    id?: string
    supplierName: string
    invoiceNumber?: string | null
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    createdBy: UserCreateNestedOneWithoutPurchaseInvoicesInput
    items?: PurchaseInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateInput = {
    id?: string
    supplierName: string
    invoiceNumber?: string | null
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    createdById: string
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type PurchaseInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
    items?: PurchaseInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type PurchaseInvoiceCreateManyInput = {
    id?: string
    supplierName: string
    invoiceNumber?: string | null
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    createdById: string
  }

  export type PurchaseInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseInvoiceItemCreateInput = {
    id?: string
    itemName: string
    description?: string | null
    quantity: number
    unitPrice: number
    subtotal: number
    invoice: PurchaseInvoiceCreateNestedOneWithoutItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    itemName: string
    description?: string | null
    quantity: number
    unitPrice: number
    subtotal: number
  }

  export type PurchaseInvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    invoice?: PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseInvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    itemName: string
    description?: string | null
    quantity: number
    unitPrice: number
    subtotal: number
  }

  export type PurchaseInvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
  }

  export type RadiationResultCreateInput = {
    id?: string
    title: string
    description?: string | null
    resultDetails: string
    reportText?: string | null
    imageUrl?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutRadiationResultsInput
    patient: PatientCreateNestedOneWithoutRadiationResultsInput
    testAssignment: TestAssignmentCreateNestedOneWithoutRadiationResultsInput
  }

  export type RadiationResultUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    resultDetails: string
    reportText?: string | null
    imageUrl?: string | null
    pdfUrl?: string | null
    patientId: string
    testAssignmentId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiationResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resultDetails?: StringFieldUpdateOperationsInput | string
    reportText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutRadiationResultsNestedInput
    patient?: PatientUpdateOneRequiredWithoutRadiationResultsNestedInput
    testAssignment?: TestAssignmentUpdateOneRequiredWithoutRadiationResultsNestedInput
  }

  export type RadiationResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resultDetails?: StringFieldUpdateOperationsInput | string
    reportText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiationResultCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    resultDetails: string
    reportText?: string | null
    imageUrl?: string | null
    pdfUrl?: string | null
    patientId: string
    testAssignmentId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiationResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resultDetails?: StringFieldUpdateOperationsInput | string
    reportText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiationResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resultDetails?: StringFieldUpdateOperationsInput | string
    reportText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabMaterialCreateInput = {
    id?: string
    name: string
    code?: string | null
    category: $Enums.MaterialCategory
    description?: string | null
    unit: string
    currentQuantity: number
    minimumQuantity: number
    price?: number | null
    supplier?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutLabMaterialsInput
    transactions?: MaterialTransactionCreateNestedManyWithoutMaterialInput
  }

  export type LabMaterialUncheckedCreateInput = {
    id?: string
    name: string
    code?: string | null
    category: $Enums.MaterialCategory
    description?: string | null
    unit: string
    currentQuantity: number
    minimumQuantity: number
    price?: number | null
    supplier?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    transactions?: MaterialTransactionUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type LabMaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: FloatFieldUpdateOperationsInput | number
    minimumQuantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutLabMaterialsNestedInput
    transactions?: MaterialTransactionUpdateManyWithoutMaterialNestedInput
  }

  export type LabMaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: FloatFieldUpdateOperationsInput | number
    minimumQuantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: MaterialTransactionUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type LabMaterialCreateManyInput = {
    id?: string
    name: string
    code?: string | null
    category: $Enums.MaterialCategory
    description?: string | null
    unit: string
    currentQuantity: number
    minimumQuantity: number
    price?: number | null
    supplier?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type LabMaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: FloatFieldUpdateOperationsInput | number
    minimumQuantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabMaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: FloatFieldUpdateOperationsInput | number
    minimumQuantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialTransactionCreateInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    previousQuantity: number
    newQuantity: number
    reason?: string | null
    batchNumber?: string | null
    invoiceNumber?: string | null
    createdAt?: Date | string
    material: LabMaterialCreateNestedOneWithoutTransactionsInput
    createdBy: UserCreateNestedOneWithoutMaterialTransactionsInput
  }

  export type MaterialTransactionUncheckedCreateInput = {
    id?: string
    materialId: string
    type: $Enums.TransactionType
    quantity: number
    previousQuantity: number
    newQuantity: number
    reason?: string | null
    batchNumber?: string | null
    invoiceNumber?: string | null
    createdAt?: Date | string
    createdById: string
  }

  export type MaterialTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    previousQuantity?: FloatFieldUpdateOperationsInput | number
    newQuantity?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: LabMaterialUpdateOneRequiredWithoutTransactionsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutMaterialTransactionsNestedInput
  }

  export type MaterialTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    previousQuantity?: FloatFieldUpdateOperationsInput | number
    newQuantity?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialTransactionCreateManyInput = {
    id?: string
    materialId: string
    type: $Enums.TransactionType
    quantity: number
    previousQuantity: number
    newQuantity: number
    reason?: string | null
    batchNumber?: string | null
    invoiceNumber?: string | null
    createdAt?: Date | string
    createdById: string
  }

  export type MaterialTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    previousQuantity?: FloatFieldUpdateOperationsInput | number
    newQuantity?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    previousQuantity?: FloatFieldUpdateOperationsInput | number
    newQuantity?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type PurchaseInvoiceListRelationFilter = {
    every?: PurchaseInvoiceWhereInput
    some?: PurchaseInvoiceWhereInput
    none?: PurchaseInvoiceWhereInput
  }

  export type RadiationResultListRelationFilter = {
    every?: RadiationResultWhereInput
    some?: RadiationResultWhereInput
    none?: RadiationResultWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type SampleListRelationFilter = {
    every?: SampleWhereInput
    some?: SampleWhereInput
    none?: SampleWhereInput
  }

  export type TestAssignmentListRelationFilter = {
    every?: TestAssignmentWhereInput
    some?: TestAssignmentWhereInput
    none?: TestAssignmentWhereInput
  }

  export type MaterialTransactionListRelationFilter = {
    every?: MaterialTransactionWhereInput
    some?: MaterialTransactionWhereInput
    none?: MaterialTransactionWhereInput
  }

  export type LabMaterialListRelationFilter = {
    every?: LabMaterialWhereInput
    some?: LabMaterialWhereInput
    none?: LabMaterialWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RadiationResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SampleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabMaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approved?: SortOrder
    sessionVersion?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    sessionVersion?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approved?: SortOrder
    sessionVersion?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approved?: SortOrder
    sessionVersion?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    sessionVersion?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[]
    notIn?: $Enums.Gender[]
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type QueueNumberListRelationFilter = {
    every?: QueueNumberWhereInput
    some?: QueueNumberWhereInput
    none?: QueueNumberWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type QueueNumberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelevanceInput = {
    fields: PatientOrderByRelevanceFieldEnum | PatientOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    fileNumber?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    fileNumber?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    fileNumber?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[]
    notIn?: $Enums.Gender[]
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TestOrderByRelevanceInput = {
    fields: TestOrderByRelevanceFieldEnum | TestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type TestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumTestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TestStatus | EnumTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestStatus[]
    notIn?: $Enums.TestStatus[]
    not?: NestedEnumTestStatusFilter<$PrismaModel> | $Enums.TestStatus
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type TestScalarRelationFilter = {
    is?: TestWhereInput
    isNot?: TestWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestAssignmentOrderByRelevanceInput = {
    fields: TestAssignmentOrderByRelevanceFieldEnum | TestAssignmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TestAssignmentPatientIdTestIdCompoundUniqueInput = {
    patientId: string
    testId: string
  }

  export type TestAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestStatus | EnumTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestStatus[]
    notIn?: $Enums.TestStatus[]
    not?: NestedEnumTestStatusWithAggregatesFilter<$PrismaModel> | $Enums.TestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestStatusFilter<$PrismaModel>
    _max?: NestedEnumTestStatusFilter<$PrismaModel>
  }

  export type TestAssignmentScalarRelationFilter = {
    is?: TestAssignmentWhereInput
    isNot?: TestAssignmentWhereInput
  }

  export type SampleOrderByRelevanceInput = {
    fields: SampleOrderByRelevanceFieldEnum | SampleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SampleCountOrderByAggregateInput = {
    id?: SortOrder
    testAssignmentId?: SortOrder
    sampleCode?: SortOrder
    collectedAt?: SortOrder
    collectedById?: SortOrder
    notes?: SortOrder
    results?: SortOrder
    reportPdfUrl?: SortOrder
  }

  export type SampleMaxOrderByAggregateInput = {
    id?: SortOrder
    testAssignmentId?: SortOrder
    sampleCode?: SortOrder
    collectedAt?: SortOrder
    collectedById?: SortOrder
    notes?: SortOrder
    results?: SortOrder
    reportPdfUrl?: SortOrder
  }

  export type SampleMinOrderByAggregateInput = {
    id?: SortOrder
    testAssignmentId?: SortOrder
    sampleCode?: SortOrder
    collectedAt?: SortOrder
    collectedById?: SortOrder
    notes?: SortOrder
    results?: SortOrder
    reportPdfUrl?: SortOrder
  }

  export type InvoiceOrderByRelevanceInput = {
    fields: InvoiceOrderByRelevanceFieldEnum | InvoiceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    isPaid?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    createdById?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    isPaid?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    createdById?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    isPaid?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    createdById?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemOrderByRelevanceInput = {
    fields: InvoiceItemOrderByRelevanceFieldEnum | InvoiceItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    testAssignmentId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    subtotal?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
    subtotal?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    testAssignmentId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    subtotal?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    testAssignmentId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    subtotal?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
    subtotal?: SortOrder
  }

  export type EnumQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[]
    notIn?: $Enums.QueueStatus[]
    not?: NestedEnumQueueStatusFilter<$PrismaModel> | $Enums.QueueStatus
  }

  export type QueueNumberOrderByRelevanceInput = {
    fields: QueueNumberOrderByRelevanceFieldEnum | QueueNumberOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QueueNumberDateNumberCompoundUniqueInput = {
    date: Date | string
    number: number
  }

  export type QueueNumberCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type QueueNumberAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type QueueNumberMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type QueueNumberMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type QueueNumberSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type EnumQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[]
    notIn?: $Enums.QueueStatus[]
    not?: NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumQueueStatusFilter<$PrismaModel>
  }

  export type EnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type ReportOrderByRelevanceInput = {
    fields: ReportOrderByRelevanceFieldEnum | ReportOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    pdfUrl?: SortOrder
    createdById?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    pdfUrl?: SortOrder
    createdById?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    pdfUrl?: SortOrder
    createdById?: SortOrder
  }

  export type EnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type PurchaseInvoiceItemListRelationFilter = {
    every?: PurchaseInvoiceItemWhereInput
    some?: PurchaseInvoiceItemWhereInput
    none?: PurchaseInvoiceItemWhereInput
  }

  export type PurchaseInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseInvoiceOrderByRelevanceInput = {
    fields: PurchaseInvoiceOrderByRelevanceFieldEnum | PurchaseInvoiceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PurchaseInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    supplierName?: SortOrder
    invoiceNumber?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    isPaid?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
  }

  export type PurchaseInvoiceAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type PurchaseInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierName?: SortOrder
    invoiceNumber?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    isPaid?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
  }

  export type PurchaseInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    supplierName?: SortOrder
    invoiceNumber?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    isPaid?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
  }

  export type PurchaseInvoiceSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type PurchaseInvoiceScalarRelationFilter = {
    is?: PurchaseInvoiceWhereInput
    isNot?: PurchaseInvoiceWhereInput
  }

  export type PurchaseInvoiceItemOrderByRelevanceInput = {
    fields: PurchaseInvoiceItemOrderByRelevanceFieldEnum | PurchaseInvoiceItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PurchaseInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemName?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type PurchaseInvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type PurchaseInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemName?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type PurchaseInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemName?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type PurchaseInvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type RadiationResultOrderByRelevanceInput = {
    fields: RadiationResultOrderByRelevanceFieldEnum | RadiationResultOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RadiationResultCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resultDetails?: SortOrder
    reportText?: SortOrder
    imageUrl?: SortOrder
    pdfUrl?: SortOrder
    patientId?: SortOrder
    testAssignmentId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RadiationResultMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resultDetails?: SortOrder
    reportText?: SortOrder
    imageUrl?: SortOrder
    pdfUrl?: SortOrder
    patientId?: SortOrder
    testAssignmentId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RadiationResultMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resultDetails?: SortOrder
    reportText?: SortOrder
    imageUrl?: SortOrder
    pdfUrl?: SortOrder
    patientId?: SortOrder
    testAssignmentId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMaterialCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialCategory | EnumMaterialCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialCategory[]
    notIn?: $Enums.MaterialCategory[]
    not?: NestedEnumMaterialCategoryFilter<$PrismaModel> | $Enums.MaterialCategory
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LabMaterialOrderByRelevanceInput = {
    fields: LabMaterialOrderByRelevanceFieldEnum | LabMaterialOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LabMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    category?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    currentQuantity?: SortOrder
    minimumQuantity?: SortOrder
    price?: SortOrder
    supplier?: SortOrder
    expiryDate?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type LabMaterialAvgOrderByAggregateInput = {
    currentQuantity?: SortOrder
    minimumQuantity?: SortOrder
    price?: SortOrder
  }

  export type LabMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    category?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    currentQuantity?: SortOrder
    minimumQuantity?: SortOrder
    price?: SortOrder
    supplier?: SortOrder
    expiryDate?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type LabMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    category?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    currentQuantity?: SortOrder
    minimumQuantity?: SortOrder
    price?: SortOrder
    supplier?: SortOrder
    expiryDate?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type LabMaterialSumOrderByAggregateInput = {
    currentQuantity?: SortOrder
    minimumQuantity?: SortOrder
    price?: SortOrder
  }

  export type EnumMaterialCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialCategory | EnumMaterialCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialCategory[]
    notIn?: $Enums.MaterialCategory[]
    not?: NestedEnumMaterialCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MaterialCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialCategoryFilter<$PrismaModel>
    _max?: NestedEnumMaterialCategoryFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type LabMaterialScalarRelationFilter = {
    is?: LabMaterialWhereInput
    isNot?: LabMaterialWhereInput
  }

  export type MaterialTransactionOrderByRelevanceInput = {
    fields: MaterialTransactionOrderByRelevanceFieldEnum | MaterialTransactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MaterialTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousQuantity?: SortOrder
    newQuantity?: SortOrder
    reason?: SortOrder
    batchNumber?: SortOrder
    invoiceNumber?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type MaterialTransactionAvgOrderByAggregateInput = {
    quantity?: SortOrder
    previousQuantity?: SortOrder
    newQuantity?: SortOrder
  }

  export type MaterialTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousQuantity?: SortOrder
    newQuantity?: SortOrder
    reason?: SortOrder
    batchNumber?: SortOrder
    invoiceNumber?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type MaterialTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousQuantity?: SortOrder
    newQuantity?: SortOrder
    reason?: SortOrder
    batchNumber?: SortOrder
    invoiceNumber?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type MaterialTransactionSumOrderByAggregateInput = {
    quantity?: SortOrder
    previousQuantity?: SortOrder
    newQuantity?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type InvoiceCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PatientCreateWithoutCreatedByInput, PatientUncheckedCreateWithoutCreatedByInput> | PatientCreateWithoutCreatedByInput[] | PatientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutCreatedByInput | PatientCreateOrConnectWithoutCreatedByInput[]
    createMany?: PatientCreateManyCreatedByInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type PurchaseInvoiceCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutCreatedByInput, PurchaseInvoiceUncheckedCreateWithoutCreatedByInput> | PurchaseInvoiceCreateWithoutCreatedByInput[] | PurchaseInvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutCreatedByInput | PurchaseInvoiceCreateOrConnectWithoutCreatedByInput[]
    createMany?: PurchaseInvoiceCreateManyCreatedByInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type RadiationResultCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RadiationResultCreateWithoutCreatedByInput, RadiationResultUncheckedCreateWithoutCreatedByInput> | RadiationResultCreateWithoutCreatedByInput[] | RadiationResultUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RadiationResultCreateOrConnectWithoutCreatedByInput | RadiationResultCreateOrConnectWithoutCreatedByInput[]
    createMany?: RadiationResultCreateManyCreatedByInputEnvelope
    connect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput> | ReportCreateWithoutCreatedByInput[] | ReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatedByInput | ReportCreateOrConnectWithoutCreatedByInput[]
    createMany?: ReportCreateManyCreatedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type SampleCreateNestedManyWithoutCollectedByInput = {
    create?: XOR<SampleCreateWithoutCollectedByInput, SampleUncheckedCreateWithoutCollectedByInput> | SampleCreateWithoutCollectedByInput[] | SampleUncheckedCreateWithoutCollectedByInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutCollectedByInput | SampleCreateOrConnectWithoutCollectedByInput[]
    createMany?: SampleCreateManyCollectedByInputEnvelope
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
  }

  export type TestAssignmentCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<TestAssignmentCreateWithoutAssignedByInput, TestAssignmentUncheckedCreateWithoutAssignedByInput> | TestAssignmentCreateWithoutAssignedByInput[] | TestAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutAssignedByInput | TestAssignmentCreateOrConnectWithoutAssignedByInput[]
    createMany?: TestAssignmentCreateManyAssignedByInputEnvelope
    connect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
  }

  export type MaterialTransactionCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<MaterialTransactionCreateWithoutCreatedByInput, MaterialTransactionUncheckedCreateWithoutCreatedByInput> | MaterialTransactionCreateWithoutCreatedByInput[] | MaterialTransactionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MaterialTransactionCreateOrConnectWithoutCreatedByInput | MaterialTransactionCreateOrConnectWithoutCreatedByInput[]
    createMany?: MaterialTransactionCreateManyCreatedByInputEnvelope
    connect?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
  }

  export type LabMaterialCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LabMaterialCreateWithoutCreatedByInput, LabMaterialUncheckedCreateWithoutCreatedByInput> | LabMaterialCreateWithoutCreatedByInput[] | LabMaterialUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LabMaterialCreateOrConnectWithoutCreatedByInput | LabMaterialCreateOrConnectWithoutCreatedByInput[]
    createMany?: LabMaterialCreateManyCreatedByInputEnvelope
    connect?: LabMaterialWhereUniqueInput | LabMaterialWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PatientCreateWithoutCreatedByInput, PatientUncheckedCreateWithoutCreatedByInput> | PatientCreateWithoutCreatedByInput[] | PatientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutCreatedByInput | PatientCreateOrConnectWithoutCreatedByInput[]
    createMany?: PatientCreateManyCreatedByInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type PurchaseInvoiceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutCreatedByInput, PurchaseInvoiceUncheckedCreateWithoutCreatedByInput> | PurchaseInvoiceCreateWithoutCreatedByInput[] | PurchaseInvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutCreatedByInput | PurchaseInvoiceCreateOrConnectWithoutCreatedByInput[]
    createMany?: PurchaseInvoiceCreateManyCreatedByInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type RadiationResultUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RadiationResultCreateWithoutCreatedByInput, RadiationResultUncheckedCreateWithoutCreatedByInput> | RadiationResultCreateWithoutCreatedByInput[] | RadiationResultUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RadiationResultCreateOrConnectWithoutCreatedByInput | RadiationResultCreateOrConnectWithoutCreatedByInput[]
    createMany?: RadiationResultCreateManyCreatedByInputEnvelope
    connect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput> | ReportCreateWithoutCreatedByInput[] | ReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatedByInput | ReportCreateOrConnectWithoutCreatedByInput[]
    createMany?: ReportCreateManyCreatedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type SampleUncheckedCreateNestedManyWithoutCollectedByInput = {
    create?: XOR<SampleCreateWithoutCollectedByInput, SampleUncheckedCreateWithoutCollectedByInput> | SampleCreateWithoutCollectedByInput[] | SampleUncheckedCreateWithoutCollectedByInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutCollectedByInput | SampleCreateOrConnectWithoutCollectedByInput[]
    createMany?: SampleCreateManyCollectedByInputEnvelope
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
  }

  export type TestAssignmentUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<TestAssignmentCreateWithoutAssignedByInput, TestAssignmentUncheckedCreateWithoutAssignedByInput> | TestAssignmentCreateWithoutAssignedByInput[] | TestAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutAssignedByInput | TestAssignmentCreateOrConnectWithoutAssignedByInput[]
    createMany?: TestAssignmentCreateManyAssignedByInputEnvelope
    connect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
  }

  export type MaterialTransactionUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<MaterialTransactionCreateWithoutCreatedByInput, MaterialTransactionUncheckedCreateWithoutCreatedByInput> | MaterialTransactionCreateWithoutCreatedByInput[] | MaterialTransactionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MaterialTransactionCreateOrConnectWithoutCreatedByInput | MaterialTransactionCreateOrConnectWithoutCreatedByInput[]
    createMany?: MaterialTransactionCreateManyCreatedByInputEnvelope
    connect?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
  }

  export type LabMaterialUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LabMaterialCreateWithoutCreatedByInput, LabMaterialUncheckedCreateWithoutCreatedByInput> | LabMaterialCreateWithoutCreatedByInput[] | LabMaterialUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LabMaterialCreateOrConnectWithoutCreatedByInput | LabMaterialCreateOrConnectWithoutCreatedByInput[]
    createMany?: LabMaterialCreateManyCreatedByInputEnvelope
    connect?: LabMaterialWhereUniqueInput | LabMaterialWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InvoiceUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCreatedByInput | InvoiceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCreatedByInput | InvoiceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCreatedByInput | InvoiceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PatientCreateWithoutCreatedByInput, PatientUncheckedCreateWithoutCreatedByInput> | PatientCreateWithoutCreatedByInput[] | PatientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutCreatedByInput | PatientCreateOrConnectWithoutCreatedByInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutCreatedByInput | PatientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PatientCreateManyCreatedByInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutCreatedByInput | PatientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutCreatedByInput | PatientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type PurchaseInvoiceUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutCreatedByInput, PurchaseInvoiceUncheckedCreateWithoutCreatedByInput> | PurchaseInvoiceCreateWithoutCreatedByInput[] | PurchaseInvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutCreatedByInput | PurchaseInvoiceCreateOrConnectWithoutCreatedByInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutCreatedByInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PurchaseInvoiceCreateManyCreatedByInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutCreatedByInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutCreatedByInput | PurchaseInvoiceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type RadiationResultUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RadiationResultCreateWithoutCreatedByInput, RadiationResultUncheckedCreateWithoutCreatedByInput> | RadiationResultCreateWithoutCreatedByInput[] | RadiationResultUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RadiationResultCreateOrConnectWithoutCreatedByInput | RadiationResultCreateOrConnectWithoutCreatedByInput[]
    upsert?: RadiationResultUpsertWithWhereUniqueWithoutCreatedByInput | RadiationResultUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RadiationResultCreateManyCreatedByInputEnvelope
    set?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    disconnect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    delete?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    connect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    update?: RadiationResultUpdateWithWhereUniqueWithoutCreatedByInput | RadiationResultUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RadiationResultUpdateManyWithWhereWithoutCreatedByInput | RadiationResultUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RadiationResultScalarWhereInput | RadiationResultScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput> | ReportCreateWithoutCreatedByInput[] | ReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatedByInput | ReportCreateOrConnectWithoutCreatedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCreatedByInput | ReportUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ReportCreateManyCreatedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCreatedByInput | ReportUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCreatedByInput | ReportUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type SampleUpdateManyWithoutCollectedByNestedInput = {
    create?: XOR<SampleCreateWithoutCollectedByInput, SampleUncheckedCreateWithoutCollectedByInput> | SampleCreateWithoutCollectedByInput[] | SampleUncheckedCreateWithoutCollectedByInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutCollectedByInput | SampleCreateOrConnectWithoutCollectedByInput[]
    upsert?: SampleUpsertWithWhereUniqueWithoutCollectedByInput | SampleUpsertWithWhereUniqueWithoutCollectedByInput[]
    createMany?: SampleCreateManyCollectedByInputEnvelope
    set?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    disconnect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    delete?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    update?: SampleUpdateWithWhereUniqueWithoutCollectedByInput | SampleUpdateWithWhereUniqueWithoutCollectedByInput[]
    updateMany?: SampleUpdateManyWithWhereWithoutCollectedByInput | SampleUpdateManyWithWhereWithoutCollectedByInput[]
    deleteMany?: SampleScalarWhereInput | SampleScalarWhereInput[]
  }

  export type TestAssignmentUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<TestAssignmentCreateWithoutAssignedByInput, TestAssignmentUncheckedCreateWithoutAssignedByInput> | TestAssignmentCreateWithoutAssignedByInput[] | TestAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutAssignedByInput | TestAssignmentCreateOrConnectWithoutAssignedByInput[]
    upsert?: TestAssignmentUpsertWithWhereUniqueWithoutAssignedByInput | TestAssignmentUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: TestAssignmentCreateManyAssignedByInputEnvelope
    set?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    disconnect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    delete?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    connect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    update?: TestAssignmentUpdateWithWhereUniqueWithoutAssignedByInput | TestAssignmentUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: TestAssignmentUpdateManyWithWhereWithoutAssignedByInput | TestAssignmentUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: TestAssignmentScalarWhereInput | TestAssignmentScalarWhereInput[]
  }

  export type MaterialTransactionUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<MaterialTransactionCreateWithoutCreatedByInput, MaterialTransactionUncheckedCreateWithoutCreatedByInput> | MaterialTransactionCreateWithoutCreatedByInput[] | MaterialTransactionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MaterialTransactionCreateOrConnectWithoutCreatedByInput | MaterialTransactionCreateOrConnectWithoutCreatedByInput[]
    upsert?: MaterialTransactionUpsertWithWhereUniqueWithoutCreatedByInput | MaterialTransactionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: MaterialTransactionCreateManyCreatedByInputEnvelope
    set?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    disconnect?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    delete?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    connect?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    update?: MaterialTransactionUpdateWithWhereUniqueWithoutCreatedByInput | MaterialTransactionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: MaterialTransactionUpdateManyWithWhereWithoutCreatedByInput | MaterialTransactionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: MaterialTransactionScalarWhereInput | MaterialTransactionScalarWhereInput[]
  }

  export type LabMaterialUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LabMaterialCreateWithoutCreatedByInput, LabMaterialUncheckedCreateWithoutCreatedByInput> | LabMaterialCreateWithoutCreatedByInput[] | LabMaterialUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LabMaterialCreateOrConnectWithoutCreatedByInput | LabMaterialCreateOrConnectWithoutCreatedByInput[]
    upsert?: LabMaterialUpsertWithWhereUniqueWithoutCreatedByInput | LabMaterialUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LabMaterialCreateManyCreatedByInputEnvelope
    set?: LabMaterialWhereUniqueInput | LabMaterialWhereUniqueInput[]
    disconnect?: LabMaterialWhereUniqueInput | LabMaterialWhereUniqueInput[]
    delete?: LabMaterialWhereUniqueInput | LabMaterialWhereUniqueInput[]
    connect?: LabMaterialWhereUniqueInput | LabMaterialWhereUniqueInput[]
    update?: LabMaterialUpdateWithWhereUniqueWithoutCreatedByInput | LabMaterialUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LabMaterialUpdateManyWithWhereWithoutCreatedByInput | LabMaterialUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LabMaterialScalarWhereInput | LabMaterialScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCreatedByInput | InvoiceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCreatedByInput | InvoiceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCreatedByInput | InvoiceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PatientCreateWithoutCreatedByInput, PatientUncheckedCreateWithoutCreatedByInput> | PatientCreateWithoutCreatedByInput[] | PatientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutCreatedByInput | PatientCreateOrConnectWithoutCreatedByInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutCreatedByInput | PatientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PatientCreateManyCreatedByInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutCreatedByInput | PatientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutCreatedByInput | PatientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutCreatedByInput, PurchaseInvoiceUncheckedCreateWithoutCreatedByInput> | PurchaseInvoiceCreateWithoutCreatedByInput[] | PurchaseInvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutCreatedByInput | PurchaseInvoiceCreateOrConnectWithoutCreatedByInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutCreatedByInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PurchaseInvoiceCreateManyCreatedByInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutCreatedByInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutCreatedByInput | PurchaseInvoiceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type RadiationResultUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RadiationResultCreateWithoutCreatedByInput, RadiationResultUncheckedCreateWithoutCreatedByInput> | RadiationResultCreateWithoutCreatedByInput[] | RadiationResultUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RadiationResultCreateOrConnectWithoutCreatedByInput | RadiationResultCreateOrConnectWithoutCreatedByInput[]
    upsert?: RadiationResultUpsertWithWhereUniqueWithoutCreatedByInput | RadiationResultUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RadiationResultCreateManyCreatedByInputEnvelope
    set?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    disconnect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    delete?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    connect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    update?: RadiationResultUpdateWithWhereUniqueWithoutCreatedByInput | RadiationResultUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RadiationResultUpdateManyWithWhereWithoutCreatedByInput | RadiationResultUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RadiationResultScalarWhereInput | RadiationResultScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput> | ReportCreateWithoutCreatedByInput[] | ReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatedByInput | ReportCreateOrConnectWithoutCreatedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCreatedByInput | ReportUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ReportCreateManyCreatedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCreatedByInput | ReportUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCreatedByInput | ReportUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type SampleUncheckedUpdateManyWithoutCollectedByNestedInput = {
    create?: XOR<SampleCreateWithoutCollectedByInput, SampleUncheckedCreateWithoutCollectedByInput> | SampleCreateWithoutCollectedByInput[] | SampleUncheckedCreateWithoutCollectedByInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutCollectedByInput | SampleCreateOrConnectWithoutCollectedByInput[]
    upsert?: SampleUpsertWithWhereUniqueWithoutCollectedByInput | SampleUpsertWithWhereUniqueWithoutCollectedByInput[]
    createMany?: SampleCreateManyCollectedByInputEnvelope
    set?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    disconnect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    delete?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    update?: SampleUpdateWithWhereUniqueWithoutCollectedByInput | SampleUpdateWithWhereUniqueWithoutCollectedByInput[]
    updateMany?: SampleUpdateManyWithWhereWithoutCollectedByInput | SampleUpdateManyWithWhereWithoutCollectedByInput[]
    deleteMany?: SampleScalarWhereInput | SampleScalarWhereInput[]
  }

  export type TestAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<TestAssignmentCreateWithoutAssignedByInput, TestAssignmentUncheckedCreateWithoutAssignedByInput> | TestAssignmentCreateWithoutAssignedByInput[] | TestAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutAssignedByInput | TestAssignmentCreateOrConnectWithoutAssignedByInput[]
    upsert?: TestAssignmentUpsertWithWhereUniqueWithoutAssignedByInput | TestAssignmentUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: TestAssignmentCreateManyAssignedByInputEnvelope
    set?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    disconnect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    delete?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    connect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    update?: TestAssignmentUpdateWithWhereUniqueWithoutAssignedByInput | TestAssignmentUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: TestAssignmentUpdateManyWithWhereWithoutAssignedByInput | TestAssignmentUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: TestAssignmentScalarWhereInput | TestAssignmentScalarWhereInput[]
  }

  export type MaterialTransactionUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<MaterialTransactionCreateWithoutCreatedByInput, MaterialTransactionUncheckedCreateWithoutCreatedByInput> | MaterialTransactionCreateWithoutCreatedByInput[] | MaterialTransactionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MaterialTransactionCreateOrConnectWithoutCreatedByInput | MaterialTransactionCreateOrConnectWithoutCreatedByInput[]
    upsert?: MaterialTransactionUpsertWithWhereUniqueWithoutCreatedByInput | MaterialTransactionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: MaterialTransactionCreateManyCreatedByInputEnvelope
    set?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    disconnect?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    delete?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    connect?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    update?: MaterialTransactionUpdateWithWhereUniqueWithoutCreatedByInput | MaterialTransactionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: MaterialTransactionUpdateManyWithWhereWithoutCreatedByInput | MaterialTransactionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: MaterialTransactionScalarWhereInput | MaterialTransactionScalarWhereInput[]
  }

  export type LabMaterialUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LabMaterialCreateWithoutCreatedByInput, LabMaterialUncheckedCreateWithoutCreatedByInput> | LabMaterialCreateWithoutCreatedByInput[] | LabMaterialUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LabMaterialCreateOrConnectWithoutCreatedByInput | LabMaterialCreateOrConnectWithoutCreatedByInput[]
    upsert?: LabMaterialUpsertWithWhereUniqueWithoutCreatedByInput | LabMaterialUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LabMaterialCreateManyCreatedByInputEnvelope
    set?: LabMaterialWhereUniqueInput | LabMaterialWhereUniqueInput[]
    disconnect?: LabMaterialWhereUniqueInput | LabMaterialWhereUniqueInput[]
    delete?: LabMaterialWhereUniqueInput | LabMaterialWhereUniqueInput[]
    connect?: LabMaterialWhereUniqueInput | LabMaterialWhereUniqueInput[]
    update?: LabMaterialUpdateWithWhereUniqueWithoutCreatedByInput | LabMaterialUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LabMaterialUpdateManyWithWhereWithoutCreatedByInput | LabMaterialUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LabMaterialScalarWhereInput | LabMaterialScalarWhereInput[]
  }

  export type InvoiceCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPatientsInput = {
    create?: XOR<UserCreateWithoutPatientsInput, UserUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientsInput
    connect?: UserWhereUniqueInput
  }

  export type QueueNumberCreateNestedManyWithoutPatientInput = {
    create?: XOR<QueueNumberCreateWithoutPatientInput, QueueNumberUncheckedCreateWithoutPatientInput> | QueueNumberCreateWithoutPatientInput[] | QueueNumberUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: QueueNumberCreateOrConnectWithoutPatientInput | QueueNumberCreateOrConnectWithoutPatientInput[]
    createMany?: QueueNumberCreateManyPatientInputEnvelope
    connect?: QueueNumberWhereUniqueInput | QueueNumberWhereUniqueInput[]
  }

  export type RadiationResultCreateNestedManyWithoutPatientInput = {
    create?: XOR<RadiationResultCreateWithoutPatientInput, RadiationResultUncheckedCreateWithoutPatientInput> | RadiationResultCreateWithoutPatientInput[] | RadiationResultUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadiationResultCreateOrConnectWithoutPatientInput | RadiationResultCreateOrConnectWithoutPatientInput[]
    createMany?: RadiationResultCreateManyPatientInputEnvelope
    connect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
  }

  export type TestAssignmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<TestAssignmentCreateWithoutPatientInput, TestAssignmentUncheckedCreateWithoutPatientInput> | TestAssignmentCreateWithoutPatientInput[] | TestAssignmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutPatientInput | TestAssignmentCreateOrConnectWithoutPatientInput[]
    createMany?: TestAssignmentCreateManyPatientInputEnvelope
    connect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type QueueNumberUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<QueueNumberCreateWithoutPatientInput, QueueNumberUncheckedCreateWithoutPatientInput> | QueueNumberCreateWithoutPatientInput[] | QueueNumberUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: QueueNumberCreateOrConnectWithoutPatientInput | QueueNumberCreateOrConnectWithoutPatientInput[]
    createMany?: QueueNumberCreateManyPatientInputEnvelope
    connect?: QueueNumberWhereUniqueInput | QueueNumberWhereUniqueInput[]
  }

  export type RadiationResultUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<RadiationResultCreateWithoutPatientInput, RadiationResultUncheckedCreateWithoutPatientInput> | RadiationResultCreateWithoutPatientInput[] | RadiationResultUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadiationResultCreateOrConnectWithoutPatientInput | RadiationResultCreateOrConnectWithoutPatientInput[]
    createMany?: RadiationResultCreateManyPatientInputEnvelope
    connect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
  }

  export type TestAssignmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<TestAssignmentCreateWithoutPatientInput, TestAssignmentUncheckedCreateWithoutPatientInput> | TestAssignmentCreateWithoutPatientInput[] | TestAssignmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutPatientInput | TestAssignmentCreateOrConnectWithoutPatientInput[]
    createMany?: TestAssignmentCreateManyPatientInputEnvelope
    connect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type InvoiceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<UserCreateWithoutPatientsInput, UserUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientsInput
    upsert?: UserUpsertWithoutPatientsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPatientsInput, UserUpdateWithoutPatientsInput>, UserUncheckedUpdateWithoutPatientsInput>
  }

  export type QueueNumberUpdateManyWithoutPatientNestedInput = {
    create?: XOR<QueueNumberCreateWithoutPatientInput, QueueNumberUncheckedCreateWithoutPatientInput> | QueueNumberCreateWithoutPatientInput[] | QueueNumberUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: QueueNumberCreateOrConnectWithoutPatientInput | QueueNumberCreateOrConnectWithoutPatientInput[]
    upsert?: QueueNumberUpsertWithWhereUniqueWithoutPatientInput | QueueNumberUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: QueueNumberCreateManyPatientInputEnvelope
    set?: QueueNumberWhereUniqueInput | QueueNumberWhereUniqueInput[]
    disconnect?: QueueNumberWhereUniqueInput | QueueNumberWhereUniqueInput[]
    delete?: QueueNumberWhereUniqueInput | QueueNumberWhereUniqueInput[]
    connect?: QueueNumberWhereUniqueInput | QueueNumberWhereUniqueInput[]
    update?: QueueNumberUpdateWithWhereUniqueWithoutPatientInput | QueueNumberUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: QueueNumberUpdateManyWithWhereWithoutPatientInput | QueueNumberUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: QueueNumberScalarWhereInput | QueueNumberScalarWhereInput[]
  }

  export type RadiationResultUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RadiationResultCreateWithoutPatientInput, RadiationResultUncheckedCreateWithoutPatientInput> | RadiationResultCreateWithoutPatientInput[] | RadiationResultUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadiationResultCreateOrConnectWithoutPatientInput | RadiationResultCreateOrConnectWithoutPatientInput[]
    upsert?: RadiationResultUpsertWithWhereUniqueWithoutPatientInput | RadiationResultUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RadiationResultCreateManyPatientInputEnvelope
    set?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    disconnect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    delete?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    connect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    update?: RadiationResultUpdateWithWhereUniqueWithoutPatientInput | RadiationResultUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RadiationResultUpdateManyWithWhereWithoutPatientInput | RadiationResultUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RadiationResultScalarWhereInput | RadiationResultScalarWhereInput[]
  }

  export type TestAssignmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TestAssignmentCreateWithoutPatientInput, TestAssignmentUncheckedCreateWithoutPatientInput> | TestAssignmentCreateWithoutPatientInput[] | TestAssignmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutPatientInput | TestAssignmentCreateOrConnectWithoutPatientInput[]
    upsert?: TestAssignmentUpsertWithWhereUniqueWithoutPatientInput | TestAssignmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TestAssignmentCreateManyPatientInputEnvelope
    set?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    disconnect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    delete?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    connect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    update?: TestAssignmentUpdateWithWhereUniqueWithoutPatientInput | TestAssignmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TestAssignmentUpdateManyWithWhereWithoutPatientInput | TestAssignmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TestAssignmentScalarWhereInput | TestAssignmentScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type QueueNumberUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<QueueNumberCreateWithoutPatientInput, QueueNumberUncheckedCreateWithoutPatientInput> | QueueNumberCreateWithoutPatientInput[] | QueueNumberUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: QueueNumberCreateOrConnectWithoutPatientInput | QueueNumberCreateOrConnectWithoutPatientInput[]
    upsert?: QueueNumberUpsertWithWhereUniqueWithoutPatientInput | QueueNumberUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: QueueNumberCreateManyPatientInputEnvelope
    set?: QueueNumberWhereUniqueInput | QueueNumberWhereUniqueInput[]
    disconnect?: QueueNumberWhereUniqueInput | QueueNumberWhereUniqueInput[]
    delete?: QueueNumberWhereUniqueInput | QueueNumberWhereUniqueInput[]
    connect?: QueueNumberWhereUniqueInput | QueueNumberWhereUniqueInput[]
    update?: QueueNumberUpdateWithWhereUniqueWithoutPatientInput | QueueNumberUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: QueueNumberUpdateManyWithWhereWithoutPatientInput | QueueNumberUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: QueueNumberScalarWhereInput | QueueNumberScalarWhereInput[]
  }

  export type RadiationResultUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RadiationResultCreateWithoutPatientInput, RadiationResultUncheckedCreateWithoutPatientInput> | RadiationResultCreateWithoutPatientInput[] | RadiationResultUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadiationResultCreateOrConnectWithoutPatientInput | RadiationResultCreateOrConnectWithoutPatientInput[]
    upsert?: RadiationResultUpsertWithWhereUniqueWithoutPatientInput | RadiationResultUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RadiationResultCreateManyPatientInputEnvelope
    set?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    disconnect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    delete?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    connect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    update?: RadiationResultUpdateWithWhereUniqueWithoutPatientInput | RadiationResultUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RadiationResultUpdateManyWithWhereWithoutPatientInput | RadiationResultUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RadiationResultScalarWhereInput | RadiationResultScalarWhereInput[]
  }

  export type TestAssignmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TestAssignmentCreateWithoutPatientInput, TestAssignmentUncheckedCreateWithoutPatientInput> | TestAssignmentCreateWithoutPatientInput[] | TestAssignmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutPatientInput | TestAssignmentCreateOrConnectWithoutPatientInput[]
    upsert?: TestAssignmentUpsertWithWhereUniqueWithoutPatientInput | TestAssignmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TestAssignmentCreateManyPatientInputEnvelope
    set?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    disconnect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    delete?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    connect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    update?: TestAssignmentUpdateWithWhereUniqueWithoutPatientInput | TestAssignmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TestAssignmentUpdateManyWithWhereWithoutPatientInput | TestAssignmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TestAssignmentScalarWhereInput | TestAssignmentScalarWhereInput[]
  }

  export type TestAssignmentCreateNestedManyWithoutTestInput = {
    create?: XOR<TestAssignmentCreateWithoutTestInput, TestAssignmentUncheckedCreateWithoutTestInput> | TestAssignmentCreateWithoutTestInput[] | TestAssignmentUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutTestInput | TestAssignmentCreateOrConnectWithoutTestInput[]
    createMany?: TestAssignmentCreateManyTestInputEnvelope
    connect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
  }

  export type TestAssignmentUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<TestAssignmentCreateWithoutTestInput, TestAssignmentUncheckedCreateWithoutTestInput> | TestAssignmentCreateWithoutTestInput[] | TestAssignmentUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutTestInput | TestAssignmentCreateOrConnectWithoutTestInput[]
    createMany?: TestAssignmentCreateManyTestInputEnvelope
    connect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TestAssignmentUpdateManyWithoutTestNestedInput = {
    create?: XOR<TestAssignmentCreateWithoutTestInput, TestAssignmentUncheckedCreateWithoutTestInput> | TestAssignmentCreateWithoutTestInput[] | TestAssignmentUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutTestInput | TestAssignmentCreateOrConnectWithoutTestInput[]
    upsert?: TestAssignmentUpsertWithWhereUniqueWithoutTestInput | TestAssignmentUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: TestAssignmentCreateManyTestInputEnvelope
    set?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    disconnect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    delete?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    connect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    update?: TestAssignmentUpdateWithWhereUniqueWithoutTestInput | TestAssignmentUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: TestAssignmentUpdateManyWithWhereWithoutTestInput | TestAssignmentUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: TestAssignmentScalarWhereInput | TestAssignmentScalarWhereInput[]
  }

  export type TestAssignmentUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<TestAssignmentCreateWithoutTestInput, TestAssignmentUncheckedCreateWithoutTestInput> | TestAssignmentCreateWithoutTestInput[] | TestAssignmentUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutTestInput | TestAssignmentCreateOrConnectWithoutTestInput[]
    upsert?: TestAssignmentUpsertWithWhereUniqueWithoutTestInput | TestAssignmentUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: TestAssignmentCreateManyTestInputEnvelope
    set?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    disconnect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    delete?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    connect?: TestAssignmentWhereUniqueInput | TestAssignmentWhereUniqueInput[]
    update?: TestAssignmentUpdateWithWhereUniqueWithoutTestInput | TestAssignmentUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: TestAssignmentUpdateManyWithWhereWithoutTestInput | TestAssignmentUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: TestAssignmentScalarWhereInput | TestAssignmentScalarWhereInput[]
  }

  export type InvoiceItemCreateNestedManyWithoutTestAssignmentInput = {
    create?: XOR<InvoiceItemCreateWithoutTestAssignmentInput, InvoiceItemUncheckedCreateWithoutTestAssignmentInput> | InvoiceItemCreateWithoutTestAssignmentInput[] | InvoiceItemUncheckedCreateWithoutTestAssignmentInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutTestAssignmentInput | InvoiceItemCreateOrConnectWithoutTestAssignmentInput[]
    createMany?: InvoiceItemCreateManyTestAssignmentInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type RadiationResultCreateNestedManyWithoutTestAssignmentInput = {
    create?: XOR<RadiationResultCreateWithoutTestAssignmentInput, RadiationResultUncheckedCreateWithoutTestAssignmentInput> | RadiationResultCreateWithoutTestAssignmentInput[] | RadiationResultUncheckedCreateWithoutTestAssignmentInput[]
    connectOrCreate?: RadiationResultCreateOrConnectWithoutTestAssignmentInput | RadiationResultCreateOrConnectWithoutTestAssignmentInput[]
    createMany?: RadiationResultCreateManyTestAssignmentInputEnvelope
    connect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
  }

  export type SampleCreateNestedManyWithoutTestAssignmentInput = {
    create?: XOR<SampleCreateWithoutTestAssignmentInput, SampleUncheckedCreateWithoutTestAssignmentInput> | SampleCreateWithoutTestAssignmentInput[] | SampleUncheckedCreateWithoutTestAssignmentInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutTestAssignmentInput | SampleCreateOrConnectWithoutTestAssignmentInput[]
    createMany?: SampleCreateManyTestAssignmentInputEnvelope
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutTestAssignmentsInput = {
    create?: XOR<UserCreateWithoutTestAssignmentsInput, UserUncheckedCreateWithoutTestAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutTestAssignmentsInput = {
    create?: XOR<PatientCreateWithoutTestAssignmentsInput, PatientUncheckedCreateWithoutTestAssignmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTestAssignmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type TestCreateNestedOneWithoutTestAssignmentsInput = {
    create?: XOR<TestCreateWithoutTestAssignmentsInput, TestUncheckedCreateWithoutTestAssignmentsInput>
    connectOrCreate?: TestCreateOrConnectWithoutTestAssignmentsInput
    connect?: TestWhereUniqueInput
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutTestAssignmentInput = {
    create?: XOR<InvoiceItemCreateWithoutTestAssignmentInput, InvoiceItemUncheckedCreateWithoutTestAssignmentInput> | InvoiceItemCreateWithoutTestAssignmentInput[] | InvoiceItemUncheckedCreateWithoutTestAssignmentInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutTestAssignmentInput | InvoiceItemCreateOrConnectWithoutTestAssignmentInput[]
    createMany?: InvoiceItemCreateManyTestAssignmentInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type RadiationResultUncheckedCreateNestedManyWithoutTestAssignmentInput = {
    create?: XOR<RadiationResultCreateWithoutTestAssignmentInput, RadiationResultUncheckedCreateWithoutTestAssignmentInput> | RadiationResultCreateWithoutTestAssignmentInput[] | RadiationResultUncheckedCreateWithoutTestAssignmentInput[]
    connectOrCreate?: RadiationResultCreateOrConnectWithoutTestAssignmentInput | RadiationResultCreateOrConnectWithoutTestAssignmentInput[]
    createMany?: RadiationResultCreateManyTestAssignmentInputEnvelope
    connect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
  }

  export type SampleUncheckedCreateNestedManyWithoutTestAssignmentInput = {
    create?: XOR<SampleCreateWithoutTestAssignmentInput, SampleUncheckedCreateWithoutTestAssignmentInput> | SampleCreateWithoutTestAssignmentInput[] | SampleUncheckedCreateWithoutTestAssignmentInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutTestAssignmentInput | SampleCreateOrConnectWithoutTestAssignmentInput[]
    createMany?: SampleCreateManyTestAssignmentInputEnvelope
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
  }

  export type EnumTestStatusFieldUpdateOperationsInput = {
    set?: $Enums.TestStatus
  }

  export type InvoiceItemUpdateManyWithoutTestAssignmentNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutTestAssignmentInput, InvoiceItemUncheckedCreateWithoutTestAssignmentInput> | InvoiceItemCreateWithoutTestAssignmentInput[] | InvoiceItemUncheckedCreateWithoutTestAssignmentInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutTestAssignmentInput | InvoiceItemCreateOrConnectWithoutTestAssignmentInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutTestAssignmentInput | InvoiceItemUpsertWithWhereUniqueWithoutTestAssignmentInput[]
    createMany?: InvoiceItemCreateManyTestAssignmentInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutTestAssignmentInput | InvoiceItemUpdateWithWhereUniqueWithoutTestAssignmentInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutTestAssignmentInput | InvoiceItemUpdateManyWithWhereWithoutTestAssignmentInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type RadiationResultUpdateManyWithoutTestAssignmentNestedInput = {
    create?: XOR<RadiationResultCreateWithoutTestAssignmentInput, RadiationResultUncheckedCreateWithoutTestAssignmentInput> | RadiationResultCreateWithoutTestAssignmentInput[] | RadiationResultUncheckedCreateWithoutTestAssignmentInput[]
    connectOrCreate?: RadiationResultCreateOrConnectWithoutTestAssignmentInput | RadiationResultCreateOrConnectWithoutTestAssignmentInput[]
    upsert?: RadiationResultUpsertWithWhereUniqueWithoutTestAssignmentInput | RadiationResultUpsertWithWhereUniqueWithoutTestAssignmentInput[]
    createMany?: RadiationResultCreateManyTestAssignmentInputEnvelope
    set?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    disconnect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    delete?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    connect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    update?: RadiationResultUpdateWithWhereUniqueWithoutTestAssignmentInput | RadiationResultUpdateWithWhereUniqueWithoutTestAssignmentInput[]
    updateMany?: RadiationResultUpdateManyWithWhereWithoutTestAssignmentInput | RadiationResultUpdateManyWithWhereWithoutTestAssignmentInput[]
    deleteMany?: RadiationResultScalarWhereInput | RadiationResultScalarWhereInput[]
  }

  export type SampleUpdateManyWithoutTestAssignmentNestedInput = {
    create?: XOR<SampleCreateWithoutTestAssignmentInput, SampleUncheckedCreateWithoutTestAssignmentInput> | SampleCreateWithoutTestAssignmentInput[] | SampleUncheckedCreateWithoutTestAssignmentInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutTestAssignmentInput | SampleCreateOrConnectWithoutTestAssignmentInput[]
    upsert?: SampleUpsertWithWhereUniqueWithoutTestAssignmentInput | SampleUpsertWithWhereUniqueWithoutTestAssignmentInput[]
    createMany?: SampleCreateManyTestAssignmentInputEnvelope
    set?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    disconnect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    delete?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    update?: SampleUpdateWithWhereUniqueWithoutTestAssignmentInput | SampleUpdateWithWhereUniqueWithoutTestAssignmentInput[]
    updateMany?: SampleUpdateManyWithWhereWithoutTestAssignmentInput | SampleUpdateManyWithWhereWithoutTestAssignmentInput[]
    deleteMany?: SampleScalarWhereInput | SampleScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutTestAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutTestAssignmentsInput, UserUncheckedCreateWithoutTestAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestAssignmentsInput
    upsert?: UserUpsertWithoutTestAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestAssignmentsInput, UserUpdateWithoutTestAssignmentsInput>, UserUncheckedUpdateWithoutTestAssignmentsInput>
  }

  export type PatientUpdateOneRequiredWithoutTestAssignmentsNestedInput = {
    create?: XOR<PatientCreateWithoutTestAssignmentsInput, PatientUncheckedCreateWithoutTestAssignmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTestAssignmentsInput
    upsert?: PatientUpsertWithoutTestAssignmentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutTestAssignmentsInput, PatientUpdateWithoutTestAssignmentsInput>, PatientUncheckedUpdateWithoutTestAssignmentsInput>
  }

  export type TestUpdateOneRequiredWithoutTestAssignmentsNestedInput = {
    create?: XOR<TestCreateWithoutTestAssignmentsInput, TestUncheckedCreateWithoutTestAssignmentsInput>
    connectOrCreate?: TestCreateOrConnectWithoutTestAssignmentsInput
    upsert?: TestUpsertWithoutTestAssignmentsInput
    connect?: TestWhereUniqueInput
    update?: XOR<XOR<TestUpdateToOneWithWhereWithoutTestAssignmentsInput, TestUpdateWithoutTestAssignmentsInput>, TestUncheckedUpdateWithoutTestAssignmentsInput>
  }

  export type InvoiceItemUncheckedUpdateManyWithoutTestAssignmentNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutTestAssignmentInput, InvoiceItemUncheckedCreateWithoutTestAssignmentInput> | InvoiceItemCreateWithoutTestAssignmentInput[] | InvoiceItemUncheckedCreateWithoutTestAssignmentInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutTestAssignmentInput | InvoiceItemCreateOrConnectWithoutTestAssignmentInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutTestAssignmentInput | InvoiceItemUpsertWithWhereUniqueWithoutTestAssignmentInput[]
    createMany?: InvoiceItemCreateManyTestAssignmentInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutTestAssignmentInput | InvoiceItemUpdateWithWhereUniqueWithoutTestAssignmentInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutTestAssignmentInput | InvoiceItemUpdateManyWithWhereWithoutTestAssignmentInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type RadiationResultUncheckedUpdateManyWithoutTestAssignmentNestedInput = {
    create?: XOR<RadiationResultCreateWithoutTestAssignmentInput, RadiationResultUncheckedCreateWithoutTestAssignmentInput> | RadiationResultCreateWithoutTestAssignmentInput[] | RadiationResultUncheckedCreateWithoutTestAssignmentInput[]
    connectOrCreate?: RadiationResultCreateOrConnectWithoutTestAssignmentInput | RadiationResultCreateOrConnectWithoutTestAssignmentInput[]
    upsert?: RadiationResultUpsertWithWhereUniqueWithoutTestAssignmentInput | RadiationResultUpsertWithWhereUniqueWithoutTestAssignmentInput[]
    createMany?: RadiationResultCreateManyTestAssignmentInputEnvelope
    set?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    disconnect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    delete?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    connect?: RadiationResultWhereUniqueInput | RadiationResultWhereUniqueInput[]
    update?: RadiationResultUpdateWithWhereUniqueWithoutTestAssignmentInput | RadiationResultUpdateWithWhereUniqueWithoutTestAssignmentInput[]
    updateMany?: RadiationResultUpdateManyWithWhereWithoutTestAssignmentInput | RadiationResultUpdateManyWithWhereWithoutTestAssignmentInput[]
    deleteMany?: RadiationResultScalarWhereInput | RadiationResultScalarWhereInput[]
  }

  export type SampleUncheckedUpdateManyWithoutTestAssignmentNestedInput = {
    create?: XOR<SampleCreateWithoutTestAssignmentInput, SampleUncheckedCreateWithoutTestAssignmentInput> | SampleCreateWithoutTestAssignmentInput[] | SampleUncheckedCreateWithoutTestAssignmentInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutTestAssignmentInput | SampleCreateOrConnectWithoutTestAssignmentInput[]
    upsert?: SampleUpsertWithWhereUniqueWithoutTestAssignmentInput | SampleUpsertWithWhereUniqueWithoutTestAssignmentInput[]
    createMany?: SampleCreateManyTestAssignmentInputEnvelope
    set?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    disconnect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    delete?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    update?: SampleUpdateWithWhereUniqueWithoutTestAssignmentInput | SampleUpdateWithWhereUniqueWithoutTestAssignmentInput[]
    updateMany?: SampleUpdateManyWithWhereWithoutTestAssignmentInput | SampleUpdateManyWithWhereWithoutTestAssignmentInput[]
    deleteMany?: SampleScalarWhereInput | SampleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSamplesInput = {
    create?: XOR<UserCreateWithoutSamplesInput, UserUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSamplesInput
    connect?: UserWhereUniqueInput
  }

  export type TestAssignmentCreateNestedOneWithoutSamplesInput = {
    create?: XOR<TestAssignmentCreateWithoutSamplesInput, TestAssignmentUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutSamplesInput
    connect?: TestAssignmentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSamplesNestedInput = {
    create?: XOR<UserCreateWithoutSamplesInput, UserUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSamplesInput
    upsert?: UserUpsertWithoutSamplesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSamplesInput, UserUpdateWithoutSamplesInput>, UserUncheckedUpdateWithoutSamplesInput>
  }

  export type TestAssignmentUpdateOneRequiredWithoutSamplesNestedInput = {
    create?: XOR<TestAssignmentCreateWithoutSamplesInput, TestAssignmentUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutSamplesInput
    upsert?: TestAssignmentUpsertWithoutSamplesInput
    connect?: TestAssignmentWhereUniqueInput
    update?: XOR<XOR<TestAssignmentUpdateToOneWithWhereWithoutSamplesInput, TestAssignmentUpdateWithoutSamplesInput>, TestAssignmentUncheckedUpdateWithoutSamplesInput>
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    connect?: PatientWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type PatientUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    upsert?: PatientUpsertWithoutInvoicesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutInvoicesInput, PatientUpdateWithoutInvoicesInput>, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type TestAssignmentCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<TestAssignmentCreateWithoutInvoiceItemsInput, TestAssignmentUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutInvoiceItemsInput
    connect?: TestAssignmentWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type TestAssignmentUpdateOneRequiredWithoutInvoiceItemsNestedInput = {
    create?: XOR<TestAssignmentCreateWithoutInvoiceItemsInput, TestAssignmentUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutInvoiceItemsInput
    upsert?: TestAssignmentUpsertWithoutInvoiceItemsInput
    connect?: TestAssignmentWhereUniqueInput
    update?: XOR<XOR<TestAssignmentUpdateToOneWithWhereWithoutInvoiceItemsInput, TestAssignmentUpdateWithoutInvoiceItemsInput>, TestAssignmentUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type PatientCreateNestedOneWithoutQueueNumbersInput = {
    create?: XOR<PatientCreateWithoutQueueNumbersInput, PatientUncheckedCreateWithoutQueueNumbersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutQueueNumbersInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumQueueStatusFieldUpdateOperationsInput = {
    set?: $Enums.QueueStatus
  }

  export type PatientUpdateOneRequiredWithoutQueueNumbersNestedInput = {
    create?: XOR<PatientCreateWithoutQueueNumbersInput, PatientUncheckedCreateWithoutQueueNumbersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutQueueNumbersInput
    upsert?: PatientUpsertWithoutQueueNumbersInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutQueueNumbersInput, PatientUpdateWithoutQueueNumbersInput>, PatientUncheckedUpdateWithoutQueueNumbersInput>
  }

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportType
  }

  export type UserUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    upsert?: UserUpsertWithoutReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsInput, UserUpdateWithoutReportsInput>, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserCreateNestedOneWithoutPurchaseInvoicesInput = {
    create?: XOR<UserCreateWithoutPurchaseInvoicesInput, UserUncheckedCreateWithoutPurchaseInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type PurchaseInvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput> | PurchaseInvoiceItemCreateWithoutInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyInvoiceInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput> | PurchaseInvoiceItemCreateWithoutInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyInvoiceInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPurchaseInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutPurchaseInvoicesInput, UserUncheckedCreateWithoutPurchaseInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseInvoicesInput
    upsert?: UserUpsertWithoutPurchaseInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchaseInvoicesInput, UserUpdateWithoutPurchaseInvoicesInput>, UserUncheckedUpdateWithoutPurchaseInvoicesInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput> | PurchaseInvoiceItemCreateWithoutInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyInvoiceInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutInvoiceInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput> | PurchaseInvoiceItemCreateWithoutInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyInvoiceInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutInvoiceInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutItemsInput
    connect?: PurchaseInvoiceWhereUniqueInput
  }

  export type PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutItemsInput
    upsert?: PurchaseInvoiceUpsertWithoutItemsInput
    connect?: PurchaseInvoiceWhereUniqueInput
    update?: XOR<XOR<PurchaseInvoiceUpdateToOneWithWhereWithoutItemsInput, PurchaseInvoiceUpdateWithoutItemsInput>, PurchaseInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type UserCreateNestedOneWithoutRadiationResultsInput = {
    create?: XOR<UserCreateWithoutRadiationResultsInput, UserUncheckedCreateWithoutRadiationResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRadiationResultsInput
    connect?: UserWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutRadiationResultsInput = {
    create?: XOR<PatientCreateWithoutRadiationResultsInput, PatientUncheckedCreateWithoutRadiationResultsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRadiationResultsInput
    connect?: PatientWhereUniqueInput
  }

  export type TestAssignmentCreateNestedOneWithoutRadiationResultsInput = {
    create?: XOR<TestAssignmentCreateWithoutRadiationResultsInput, TestAssignmentUncheckedCreateWithoutRadiationResultsInput>
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutRadiationResultsInput
    connect?: TestAssignmentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRadiationResultsNestedInput = {
    create?: XOR<UserCreateWithoutRadiationResultsInput, UserUncheckedCreateWithoutRadiationResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRadiationResultsInput
    upsert?: UserUpsertWithoutRadiationResultsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRadiationResultsInput, UserUpdateWithoutRadiationResultsInput>, UserUncheckedUpdateWithoutRadiationResultsInput>
  }

  export type PatientUpdateOneRequiredWithoutRadiationResultsNestedInput = {
    create?: XOR<PatientCreateWithoutRadiationResultsInput, PatientUncheckedCreateWithoutRadiationResultsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRadiationResultsInput
    upsert?: PatientUpsertWithoutRadiationResultsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutRadiationResultsInput, PatientUpdateWithoutRadiationResultsInput>, PatientUncheckedUpdateWithoutRadiationResultsInput>
  }

  export type TestAssignmentUpdateOneRequiredWithoutRadiationResultsNestedInput = {
    create?: XOR<TestAssignmentCreateWithoutRadiationResultsInput, TestAssignmentUncheckedCreateWithoutRadiationResultsInput>
    connectOrCreate?: TestAssignmentCreateOrConnectWithoutRadiationResultsInput
    upsert?: TestAssignmentUpsertWithoutRadiationResultsInput
    connect?: TestAssignmentWhereUniqueInput
    update?: XOR<XOR<TestAssignmentUpdateToOneWithWhereWithoutRadiationResultsInput, TestAssignmentUpdateWithoutRadiationResultsInput>, TestAssignmentUncheckedUpdateWithoutRadiationResultsInput>
  }

  export type UserCreateNestedOneWithoutLabMaterialsInput = {
    create?: XOR<UserCreateWithoutLabMaterialsInput, UserUncheckedCreateWithoutLabMaterialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabMaterialsInput
    connect?: UserWhereUniqueInput
  }

  export type MaterialTransactionCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MaterialTransactionCreateWithoutMaterialInput, MaterialTransactionUncheckedCreateWithoutMaterialInput> | MaterialTransactionCreateWithoutMaterialInput[] | MaterialTransactionUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialTransactionCreateOrConnectWithoutMaterialInput | MaterialTransactionCreateOrConnectWithoutMaterialInput[]
    createMany?: MaterialTransactionCreateManyMaterialInputEnvelope
    connect?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
  }

  export type MaterialTransactionUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MaterialTransactionCreateWithoutMaterialInput, MaterialTransactionUncheckedCreateWithoutMaterialInput> | MaterialTransactionCreateWithoutMaterialInput[] | MaterialTransactionUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialTransactionCreateOrConnectWithoutMaterialInput | MaterialTransactionCreateOrConnectWithoutMaterialInput[]
    createMany?: MaterialTransactionCreateManyMaterialInputEnvelope
    connect?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
  }

  export type EnumMaterialCategoryFieldUpdateOperationsInput = {
    set?: $Enums.MaterialCategory
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutLabMaterialsNestedInput = {
    create?: XOR<UserCreateWithoutLabMaterialsInput, UserUncheckedCreateWithoutLabMaterialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabMaterialsInput
    upsert?: UserUpsertWithoutLabMaterialsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLabMaterialsInput, UserUpdateWithoutLabMaterialsInput>, UserUncheckedUpdateWithoutLabMaterialsInput>
  }

  export type MaterialTransactionUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MaterialTransactionCreateWithoutMaterialInput, MaterialTransactionUncheckedCreateWithoutMaterialInput> | MaterialTransactionCreateWithoutMaterialInput[] | MaterialTransactionUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialTransactionCreateOrConnectWithoutMaterialInput | MaterialTransactionCreateOrConnectWithoutMaterialInput[]
    upsert?: MaterialTransactionUpsertWithWhereUniqueWithoutMaterialInput | MaterialTransactionUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MaterialTransactionCreateManyMaterialInputEnvelope
    set?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    disconnect?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    delete?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    connect?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    update?: MaterialTransactionUpdateWithWhereUniqueWithoutMaterialInput | MaterialTransactionUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MaterialTransactionUpdateManyWithWhereWithoutMaterialInput | MaterialTransactionUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MaterialTransactionScalarWhereInput | MaterialTransactionScalarWhereInput[]
  }

  export type MaterialTransactionUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MaterialTransactionCreateWithoutMaterialInput, MaterialTransactionUncheckedCreateWithoutMaterialInput> | MaterialTransactionCreateWithoutMaterialInput[] | MaterialTransactionUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialTransactionCreateOrConnectWithoutMaterialInput | MaterialTransactionCreateOrConnectWithoutMaterialInput[]
    upsert?: MaterialTransactionUpsertWithWhereUniqueWithoutMaterialInput | MaterialTransactionUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MaterialTransactionCreateManyMaterialInputEnvelope
    set?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    disconnect?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    delete?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    connect?: MaterialTransactionWhereUniqueInput | MaterialTransactionWhereUniqueInput[]
    update?: MaterialTransactionUpdateWithWhereUniqueWithoutMaterialInput | MaterialTransactionUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MaterialTransactionUpdateManyWithWhereWithoutMaterialInput | MaterialTransactionUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MaterialTransactionScalarWhereInput | MaterialTransactionScalarWhereInput[]
  }

  export type LabMaterialCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<LabMaterialCreateWithoutTransactionsInput, LabMaterialUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LabMaterialCreateOrConnectWithoutTransactionsInput
    connect?: LabMaterialWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMaterialTransactionsInput = {
    create?: XOR<UserCreateWithoutMaterialTransactionsInput, UserUncheckedCreateWithoutMaterialTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaterialTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type LabMaterialUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<LabMaterialCreateWithoutTransactionsInput, LabMaterialUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LabMaterialCreateOrConnectWithoutTransactionsInput
    upsert?: LabMaterialUpsertWithoutTransactionsInput
    connect?: LabMaterialWhereUniqueInput
    update?: XOR<XOR<LabMaterialUpdateToOneWithWhereWithoutTransactionsInput, LabMaterialUpdateWithoutTransactionsInput>, LabMaterialUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateOneRequiredWithoutMaterialTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutMaterialTransactionsInput, UserUncheckedCreateWithoutMaterialTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaterialTransactionsInput
    upsert?: UserUpsertWithoutMaterialTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMaterialTransactionsInput, UserUpdateWithoutMaterialTransactionsInput>, UserUncheckedUpdateWithoutMaterialTransactionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[]
    notIn?: $Enums.Gender[]
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[]
    notIn?: $Enums.Gender[]
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumTestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TestStatus | EnumTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestStatus[]
    notIn?: $Enums.TestStatus[]
    not?: NestedEnumTestStatusFilter<$PrismaModel> | $Enums.TestStatus
  }

  export type NestedEnumTestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestStatus | EnumTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TestStatus[]
    notIn?: $Enums.TestStatus[]
    not?: NestedEnumTestStatusWithAggregatesFilter<$PrismaModel> | $Enums.TestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestStatusFilter<$PrismaModel>
    _max?: NestedEnumTestStatusFilter<$PrismaModel>
  }

  export type NestedEnumQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[]
    notIn?: $Enums.QueueStatus[]
    not?: NestedEnumQueueStatusFilter<$PrismaModel> | $Enums.QueueStatus
  }

  export type NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[]
    notIn?: $Enums.QueueStatus[]
    not?: NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumQueueStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type NestedEnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type NestedEnumMaterialCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialCategory | EnumMaterialCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialCategory[]
    notIn?: $Enums.MaterialCategory[]
    not?: NestedEnumMaterialCategoryFilter<$PrismaModel> | $Enums.MaterialCategory
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMaterialCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialCategory | EnumMaterialCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialCategory[]
    notIn?: $Enums.MaterialCategory[]
    not?: NestedEnumMaterialCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MaterialCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialCategoryFilter<$PrismaModel>
    _max?: NestedEnumMaterialCategoryFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type InvoiceCreateWithoutCreatedByInput = {
    id?: string
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    patient: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCreatedByInput = {
    id?: string
    patientId: string
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>
  }

  export type InvoiceCreateManyCreatedByInputEnvelope = {
    data: InvoiceCreateManyCreatedByInput | InvoiceCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutCreatedByInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    queueNumbers?: QueueNumberCreateNestedManyWithoutPatientInput
    radiationResults?: RadiationResultCreateNestedManyWithoutPatientInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutCreatedByInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    queueNumbers?: QueueNumberUncheckedCreateNestedManyWithoutPatientInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutPatientInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutCreatedByInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutCreatedByInput, PatientUncheckedCreateWithoutCreatedByInput>
  }

  export type PatientCreateManyCreatedByInputEnvelope = {
    data: PatientCreateManyCreatedByInput | PatientCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseInvoiceCreateWithoutCreatedByInput = {
    id?: string
    supplierName: string
    invoiceNumber?: string | null
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    items?: PurchaseInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutCreatedByInput = {
    id?: string
    supplierName: string
    invoiceNumber?: string | null
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type PurchaseInvoiceCreateOrConnectWithoutCreatedByInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutCreatedByInput, PurchaseInvoiceUncheckedCreateWithoutCreatedByInput>
  }

  export type PurchaseInvoiceCreateManyCreatedByInputEnvelope = {
    data: PurchaseInvoiceCreateManyCreatedByInput | PurchaseInvoiceCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type RadiationResultCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    resultDetails: string
    reportText?: string | null
    imageUrl?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutRadiationResultsInput
    testAssignment: TestAssignmentCreateNestedOneWithoutRadiationResultsInput
  }

  export type RadiationResultUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    resultDetails: string
    reportText?: string | null
    imageUrl?: string | null
    pdfUrl?: string | null
    patientId: string
    testAssignmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiationResultCreateOrConnectWithoutCreatedByInput = {
    where: RadiationResultWhereUniqueInput
    create: XOR<RadiationResultCreateWithoutCreatedByInput, RadiationResultUncheckedCreateWithoutCreatedByInput>
  }

  export type RadiationResultCreateManyCreatedByInputEnvelope = {
    data: RadiationResultCreateManyCreatedByInput | RadiationResultCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutCreatedByInput = {
    id?: string
    title: string
    type: $Enums.ReportType
    description?: string | null
    createdAt?: Date | string
    startDate: Date | string
    endDate: Date | string
    pdfUrl?: string | null
  }

  export type ReportUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    type: $Enums.ReportType
    description?: string | null
    createdAt?: Date | string
    startDate: Date | string
    endDate: Date | string
    pdfUrl?: string | null
  }

  export type ReportCreateOrConnectWithoutCreatedByInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput>
  }

  export type ReportCreateManyCreatedByInputEnvelope = {
    data: ReportCreateManyCreatedByInput | ReportCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SampleCreateWithoutCollectedByInput = {
    id?: string
    sampleCode: string
    collectedAt?: Date | string
    notes?: string | null
    results?: string | null
    reportPdfUrl?: string | null
    testAssignment: TestAssignmentCreateNestedOneWithoutSamplesInput
  }

  export type SampleUncheckedCreateWithoutCollectedByInput = {
    id?: string
    testAssignmentId: string
    sampleCode: string
    collectedAt?: Date | string
    notes?: string | null
    results?: string | null
    reportPdfUrl?: string | null
  }

  export type SampleCreateOrConnectWithoutCollectedByInput = {
    where: SampleWhereUniqueInput
    create: XOR<SampleCreateWithoutCollectedByInput, SampleUncheckedCreateWithoutCollectedByInput>
  }

  export type SampleCreateManyCollectedByInputEnvelope = {
    data: SampleCreateManyCollectedByInput | SampleCreateManyCollectedByInput[]
    skipDuplicates?: boolean
  }

  export type TestAssignmentCreateWithoutAssignedByInput = {
    id?: string
    status?: $Enums.TestStatus
    assignedAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTestAssignmentInput
    radiationResults?: RadiationResultCreateNestedManyWithoutTestAssignmentInput
    samples?: SampleCreateNestedManyWithoutTestAssignmentInput
    patient: PatientCreateNestedOneWithoutTestAssignmentsInput
    test: TestCreateNestedOneWithoutTestAssignmentsInput
  }

  export type TestAssignmentUncheckedCreateWithoutAssignedByInput = {
    id?: string
    patientId: string
    testId: string
    status?: $Enums.TestStatus
    assignedAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTestAssignmentInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutTestAssignmentInput
    samples?: SampleUncheckedCreateNestedManyWithoutTestAssignmentInput
  }

  export type TestAssignmentCreateOrConnectWithoutAssignedByInput = {
    where: TestAssignmentWhereUniqueInput
    create: XOR<TestAssignmentCreateWithoutAssignedByInput, TestAssignmentUncheckedCreateWithoutAssignedByInput>
  }

  export type TestAssignmentCreateManyAssignedByInputEnvelope = {
    data: TestAssignmentCreateManyAssignedByInput | TestAssignmentCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type MaterialTransactionCreateWithoutCreatedByInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    previousQuantity: number
    newQuantity: number
    reason?: string | null
    batchNumber?: string | null
    invoiceNumber?: string | null
    createdAt?: Date | string
    material: LabMaterialCreateNestedOneWithoutTransactionsInput
  }

  export type MaterialTransactionUncheckedCreateWithoutCreatedByInput = {
    id?: string
    materialId: string
    type: $Enums.TransactionType
    quantity: number
    previousQuantity: number
    newQuantity: number
    reason?: string | null
    batchNumber?: string | null
    invoiceNumber?: string | null
    createdAt?: Date | string
  }

  export type MaterialTransactionCreateOrConnectWithoutCreatedByInput = {
    where: MaterialTransactionWhereUniqueInput
    create: XOR<MaterialTransactionCreateWithoutCreatedByInput, MaterialTransactionUncheckedCreateWithoutCreatedByInput>
  }

  export type MaterialTransactionCreateManyCreatedByInputEnvelope = {
    data: MaterialTransactionCreateManyCreatedByInput | MaterialTransactionCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type LabMaterialCreateWithoutCreatedByInput = {
    id?: string
    name: string
    code?: string | null
    category: $Enums.MaterialCategory
    description?: string | null
    unit: string
    currentQuantity: number
    minimumQuantity: number
    price?: number | null
    supplier?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: MaterialTransactionCreateNestedManyWithoutMaterialInput
  }

  export type LabMaterialUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    code?: string | null
    category: $Enums.MaterialCategory
    description?: string | null
    unit: string
    currentQuantity: number
    minimumQuantity: number
    price?: number | null
    supplier?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: MaterialTransactionUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type LabMaterialCreateOrConnectWithoutCreatedByInput = {
    where: LabMaterialWhereUniqueInput
    create: XOR<LabMaterialCreateWithoutCreatedByInput, LabMaterialUncheckedCreateWithoutCreatedByInput>
  }

  export type LabMaterialCreateManyCreatedByInputEnvelope = {
    data: LabMaterialCreateManyCreatedByInput | LabMaterialCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCreatedByInput, InvoiceUncheckedUpdateWithoutCreatedByInput>
    create: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCreatedByInput, InvoiceUncheckedUpdateWithoutCreatedByInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCreatedByInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    patientId?: StringFilter<"Invoice"> | string
    totalAmount?: FloatFilter<"Invoice"> | number
    paidAmount?: FloatFilter<"Invoice"> | number
    isPaid?: BoolFilter<"Invoice"> | boolean
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdById?: StringFilter<"Invoice"> | string
  }

  export type PatientUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutCreatedByInput, PatientUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PatientCreateWithoutCreatedByInput, PatientUncheckedCreateWithoutCreatedByInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutCreatedByInput, PatientUncheckedUpdateWithoutCreatedByInput>
  }

  export type PatientUpdateManyWithWhereWithoutCreatedByInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: StringFilter<"Patient"> | string
    fileNumber?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    phone?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    gender?: EnumGenderFilter<"Patient"> | $Enums.Gender
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    createdById?: StringFilter<"Patient"> | string
  }

  export type PurchaseInvoiceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PurchaseInvoiceWhereUniqueInput
    update: XOR<PurchaseInvoiceUpdateWithoutCreatedByInput, PurchaseInvoiceUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PurchaseInvoiceCreateWithoutCreatedByInput, PurchaseInvoiceUncheckedCreateWithoutCreatedByInput>
  }

  export type PurchaseInvoiceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PurchaseInvoiceWhereUniqueInput
    data: XOR<PurchaseInvoiceUpdateWithoutCreatedByInput, PurchaseInvoiceUncheckedUpdateWithoutCreatedByInput>
  }

  export type PurchaseInvoiceUpdateManyWithWhereWithoutCreatedByInput = {
    where: PurchaseInvoiceScalarWhereInput
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PurchaseInvoiceScalarWhereInput = {
    AND?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
    OR?: PurchaseInvoiceScalarWhereInput[]
    NOT?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
    id?: StringFilter<"PurchaseInvoice"> | string
    supplierName?: StringFilter<"PurchaseInvoice"> | string
    invoiceNumber?: StringNullableFilter<"PurchaseInvoice"> | string | null
    totalAmount?: FloatFilter<"PurchaseInvoice"> | number
    paidAmount?: FloatFilter<"PurchaseInvoice"> | number
    isPaid?: BoolFilter<"PurchaseInvoice"> | boolean
    invoiceDate?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"PurchaseInvoice"> | Date | string | null
    notes?: StringNullableFilter<"PurchaseInvoice"> | string | null
    createdById?: StringFilter<"PurchaseInvoice"> | string
  }

  export type RadiationResultUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RadiationResultWhereUniqueInput
    update: XOR<RadiationResultUpdateWithoutCreatedByInput, RadiationResultUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RadiationResultCreateWithoutCreatedByInput, RadiationResultUncheckedCreateWithoutCreatedByInput>
  }

  export type RadiationResultUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RadiationResultWhereUniqueInput
    data: XOR<RadiationResultUpdateWithoutCreatedByInput, RadiationResultUncheckedUpdateWithoutCreatedByInput>
  }

  export type RadiationResultUpdateManyWithWhereWithoutCreatedByInput = {
    where: RadiationResultScalarWhereInput
    data: XOR<RadiationResultUpdateManyMutationInput, RadiationResultUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RadiationResultScalarWhereInput = {
    AND?: RadiationResultScalarWhereInput | RadiationResultScalarWhereInput[]
    OR?: RadiationResultScalarWhereInput[]
    NOT?: RadiationResultScalarWhereInput | RadiationResultScalarWhereInput[]
    id?: StringFilter<"RadiationResult"> | string
    title?: StringFilter<"RadiationResult"> | string
    description?: StringNullableFilter<"RadiationResult"> | string | null
    resultDetails?: StringFilter<"RadiationResult"> | string
    reportText?: StringNullableFilter<"RadiationResult"> | string | null
    imageUrl?: StringNullableFilter<"RadiationResult"> | string | null
    pdfUrl?: StringNullableFilter<"RadiationResult"> | string | null
    patientId?: StringFilter<"RadiationResult"> | string
    testAssignmentId?: StringFilter<"RadiationResult"> | string
    createdById?: StringFilter<"RadiationResult"> | string
    createdAt?: DateTimeFilter<"RadiationResult"> | Date | string
    updatedAt?: DateTimeFilter<"RadiationResult"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutCreatedByInput, ReportUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutCreatedByInput, ReportUncheckedUpdateWithoutCreatedByInput>
  }

  export type ReportUpdateManyWithWhereWithoutCreatedByInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    title?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    description?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    startDate?: DateTimeFilter<"Report"> | Date | string
    endDate?: DateTimeFilter<"Report"> | Date | string
    pdfUrl?: StringNullableFilter<"Report"> | string | null
    createdById?: StringFilter<"Report"> | string
  }

  export type SampleUpsertWithWhereUniqueWithoutCollectedByInput = {
    where: SampleWhereUniqueInput
    update: XOR<SampleUpdateWithoutCollectedByInput, SampleUncheckedUpdateWithoutCollectedByInput>
    create: XOR<SampleCreateWithoutCollectedByInput, SampleUncheckedCreateWithoutCollectedByInput>
  }

  export type SampleUpdateWithWhereUniqueWithoutCollectedByInput = {
    where: SampleWhereUniqueInput
    data: XOR<SampleUpdateWithoutCollectedByInput, SampleUncheckedUpdateWithoutCollectedByInput>
  }

  export type SampleUpdateManyWithWhereWithoutCollectedByInput = {
    where: SampleScalarWhereInput
    data: XOR<SampleUpdateManyMutationInput, SampleUncheckedUpdateManyWithoutCollectedByInput>
  }

  export type SampleScalarWhereInput = {
    AND?: SampleScalarWhereInput | SampleScalarWhereInput[]
    OR?: SampleScalarWhereInput[]
    NOT?: SampleScalarWhereInput | SampleScalarWhereInput[]
    id?: StringFilter<"Sample"> | string
    testAssignmentId?: StringFilter<"Sample"> | string
    sampleCode?: StringFilter<"Sample"> | string
    collectedAt?: DateTimeFilter<"Sample"> | Date | string
    collectedById?: StringFilter<"Sample"> | string
    notes?: StringNullableFilter<"Sample"> | string | null
    results?: StringNullableFilter<"Sample"> | string | null
    reportPdfUrl?: StringNullableFilter<"Sample"> | string | null
  }

  export type TestAssignmentUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: TestAssignmentWhereUniqueInput
    update: XOR<TestAssignmentUpdateWithoutAssignedByInput, TestAssignmentUncheckedUpdateWithoutAssignedByInput>
    create: XOR<TestAssignmentCreateWithoutAssignedByInput, TestAssignmentUncheckedCreateWithoutAssignedByInput>
  }

  export type TestAssignmentUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: TestAssignmentWhereUniqueInput
    data: XOR<TestAssignmentUpdateWithoutAssignedByInput, TestAssignmentUncheckedUpdateWithoutAssignedByInput>
  }

  export type TestAssignmentUpdateManyWithWhereWithoutAssignedByInput = {
    where: TestAssignmentScalarWhereInput
    data: XOR<TestAssignmentUpdateManyMutationInput, TestAssignmentUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type TestAssignmentScalarWhereInput = {
    AND?: TestAssignmentScalarWhereInput | TestAssignmentScalarWhereInput[]
    OR?: TestAssignmentScalarWhereInput[]
    NOT?: TestAssignmentScalarWhereInput | TestAssignmentScalarWhereInput[]
    id?: StringFilter<"TestAssignment"> | string
    patientId?: StringFilter<"TestAssignment"> | string
    testId?: StringFilter<"TestAssignment"> | string
    status?: EnumTestStatusFilter<"TestAssignment"> | $Enums.TestStatus
    assignedById?: StringFilter<"TestAssignment"> | string
    assignedAt?: DateTimeFilter<"TestAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TestAssignment"> | Date | string
  }

  export type MaterialTransactionUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: MaterialTransactionWhereUniqueInput
    update: XOR<MaterialTransactionUpdateWithoutCreatedByInput, MaterialTransactionUncheckedUpdateWithoutCreatedByInput>
    create: XOR<MaterialTransactionCreateWithoutCreatedByInput, MaterialTransactionUncheckedCreateWithoutCreatedByInput>
  }

  export type MaterialTransactionUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: MaterialTransactionWhereUniqueInput
    data: XOR<MaterialTransactionUpdateWithoutCreatedByInput, MaterialTransactionUncheckedUpdateWithoutCreatedByInput>
  }

  export type MaterialTransactionUpdateManyWithWhereWithoutCreatedByInput = {
    where: MaterialTransactionScalarWhereInput
    data: XOR<MaterialTransactionUpdateManyMutationInput, MaterialTransactionUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type MaterialTransactionScalarWhereInput = {
    AND?: MaterialTransactionScalarWhereInput | MaterialTransactionScalarWhereInput[]
    OR?: MaterialTransactionScalarWhereInput[]
    NOT?: MaterialTransactionScalarWhereInput | MaterialTransactionScalarWhereInput[]
    id?: StringFilter<"MaterialTransaction"> | string
    materialId?: StringFilter<"MaterialTransaction"> | string
    type?: EnumTransactionTypeFilter<"MaterialTransaction"> | $Enums.TransactionType
    quantity?: FloatFilter<"MaterialTransaction"> | number
    previousQuantity?: FloatFilter<"MaterialTransaction"> | number
    newQuantity?: FloatFilter<"MaterialTransaction"> | number
    reason?: StringNullableFilter<"MaterialTransaction"> | string | null
    batchNumber?: StringNullableFilter<"MaterialTransaction"> | string | null
    invoiceNumber?: StringNullableFilter<"MaterialTransaction"> | string | null
    createdAt?: DateTimeFilter<"MaterialTransaction"> | Date | string
    createdById?: StringFilter<"MaterialTransaction"> | string
  }

  export type LabMaterialUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: LabMaterialWhereUniqueInput
    update: XOR<LabMaterialUpdateWithoutCreatedByInput, LabMaterialUncheckedUpdateWithoutCreatedByInput>
    create: XOR<LabMaterialCreateWithoutCreatedByInput, LabMaterialUncheckedCreateWithoutCreatedByInput>
  }

  export type LabMaterialUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: LabMaterialWhereUniqueInput
    data: XOR<LabMaterialUpdateWithoutCreatedByInput, LabMaterialUncheckedUpdateWithoutCreatedByInput>
  }

  export type LabMaterialUpdateManyWithWhereWithoutCreatedByInput = {
    where: LabMaterialScalarWhereInput
    data: XOR<LabMaterialUpdateManyMutationInput, LabMaterialUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type LabMaterialScalarWhereInput = {
    AND?: LabMaterialScalarWhereInput | LabMaterialScalarWhereInput[]
    OR?: LabMaterialScalarWhereInput[]
    NOT?: LabMaterialScalarWhereInput | LabMaterialScalarWhereInput[]
    id?: StringFilter<"LabMaterial"> | string
    name?: StringFilter<"LabMaterial"> | string
    code?: StringNullableFilter<"LabMaterial"> | string | null
    category?: EnumMaterialCategoryFilter<"LabMaterial"> | $Enums.MaterialCategory
    description?: StringNullableFilter<"LabMaterial"> | string | null
    unit?: StringFilter<"LabMaterial"> | string
    currentQuantity?: FloatFilter<"LabMaterial"> | number
    minimumQuantity?: FloatFilter<"LabMaterial"> | number
    price?: FloatNullableFilter<"LabMaterial"> | number | null
    supplier?: StringNullableFilter<"LabMaterial"> | string | null
    expiryDate?: DateTimeNullableFilter<"LabMaterial"> | Date | string | null
    location?: StringNullableFilter<"LabMaterial"> | string | null
    notes?: StringNullableFilter<"LabMaterial"> | string | null
    createdAt?: DateTimeFilter<"LabMaterial"> | Date | string
    updatedAt?: DateTimeFilter<"LabMaterial"> | Date | string
    createdById?: StringNullableFilter<"LabMaterial"> | string | null
  }

  export type InvoiceCreateWithoutPatientInput = {
    id?: string
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    createdBy: UserCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPatientInput = {
    id?: string
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    createdById: string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceCreateManyPatientInputEnvelope = {
    data: InvoiceCreateManyPatientInput | InvoiceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPatientsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultCreateNestedManyWithoutCreatedByInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    samples?: SampleCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutPatientsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutCreatedByInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    samples?: SampleUncheckedCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutPatientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatientsInput, UserUncheckedCreateWithoutPatientsInput>
  }

  export type QueueNumberCreateWithoutPatientInput = {
    id?: string
    number: number
    date?: Date | string
    status?: $Enums.QueueStatus
  }

  export type QueueNumberUncheckedCreateWithoutPatientInput = {
    id?: string
    number: number
    date?: Date | string
    status?: $Enums.QueueStatus
  }

  export type QueueNumberCreateOrConnectWithoutPatientInput = {
    where: QueueNumberWhereUniqueInput
    create: XOR<QueueNumberCreateWithoutPatientInput, QueueNumberUncheckedCreateWithoutPatientInput>
  }

  export type QueueNumberCreateManyPatientInputEnvelope = {
    data: QueueNumberCreateManyPatientInput | QueueNumberCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type RadiationResultCreateWithoutPatientInput = {
    id?: string
    title: string
    description?: string | null
    resultDetails: string
    reportText?: string | null
    imageUrl?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutRadiationResultsInput
    testAssignment: TestAssignmentCreateNestedOneWithoutRadiationResultsInput
  }

  export type RadiationResultUncheckedCreateWithoutPatientInput = {
    id?: string
    title: string
    description?: string | null
    resultDetails: string
    reportText?: string | null
    imageUrl?: string | null
    pdfUrl?: string | null
    testAssignmentId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiationResultCreateOrConnectWithoutPatientInput = {
    where: RadiationResultWhereUniqueInput
    create: XOR<RadiationResultCreateWithoutPatientInput, RadiationResultUncheckedCreateWithoutPatientInput>
  }

  export type RadiationResultCreateManyPatientInputEnvelope = {
    data: RadiationResultCreateManyPatientInput | RadiationResultCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type TestAssignmentCreateWithoutPatientInput = {
    id?: string
    status?: $Enums.TestStatus
    assignedAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTestAssignmentInput
    radiationResults?: RadiationResultCreateNestedManyWithoutTestAssignmentInput
    samples?: SampleCreateNestedManyWithoutTestAssignmentInput
    assignedBy: UserCreateNestedOneWithoutTestAssignmentsInput
    test: TestCreateNestedOneWithoutTestAssignmentsInput
  }

  export type TestAssignmentUncheckedCreateWithoutPatientInput = {
    id?: string
    testId: string
    status?: $Enums.TestStatus
    assignedById: string
    assignedAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTestAssignmentInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutTestAssignmentInput
    samples?: SampleUncheckedCreateNestedManyWithoutTestAssignmentInput
  }

  export type TestAssignmentCreateOrConnectWithoutPatientInput = {
    where: TestAssignmentWhereUniqueInput
    create: XOR<TestAssignmentCreateWithoutPatientInput, TestAssignmentUncheckedCreateWithoutPatientInput>
  }

  export type TestAssignmentCreateManyPatientInputEnvelope = {
    data: TestAssignmentCreateManyPatientInput | TestAssignmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPatientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPatientInput>
  }

  export type UserUpsertWithoutPatientsInput = {
    update: XOR<UserUpdateWithoutPatientsInput, UserUncheckedUpdateWithoutPatientsInput>
    create: XOR<UserCreateWithoutPatientsInput, UserUncheckedCreateWithoutPatientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPatientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPatientsInput, UserUncheckedUpdateWithoutPatientsInput>
  }

  export type UserUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUncheckedUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type QueueNumberUpsertWithWhereUniqueWithoutPatientInput = {
    where: QueueNumberWhereUniqueInput
    update: XOR<QueueNumberUpdateWithoutPatientInput, QueueNumberUncheckedUpdateWithoutPatientInput>
    create: XOR<QueueNumberCreateWithoutPatientInput, QueueNumberUncheckedCreateWithoutPatientInput>
  }

  export type QueueNumberUpdateWithWhereUniqueWithoutPatientInput = {
    where: QueueNumberWhereUniqueInput
    data: XOR<QueueNumberUpdateWithoutPatientInput, QueueNumberUncheckedUpdateWithoutPatientInput>
  }

  export type QueueNumberUpdateManyWithWhereWithoutPatientInput = {
    where: QueueNumberScalarWhereInput
    data: XOR<QueueNumberUpdateManyMutationInput, QueueNumberUncheckedUpdateManyWithoutPatientInput>
  }

  export type QueueNumberScalarWhereInput = {
    AND?: QueueNumberScalarWhereInput | QueueNumberScalarWhereInput[]
    OR?: QueueNumberScalarWhereInput[]
    NOT?: QueueNumberScalarWhereInput | QueueNumberScalarWhereInput[]
    id?: StringFilter<"QueueNumber"> | string
    number?: IntFilter<"QueueNumber"> | number
    patientId?: StringFilter<"QueueNumber"> | string
    date?: DateTimeFilter<"QueueNumber"> | Date | string
    status?: EnumQueueStatusFilter<"QueueNumber"> | $Enums.QueueStatus
  }

  export type RadiationResultUpsertWithWhereUniqueWithoutPatientInput = {
    where: RadiationResultWhereUniqueInput
    update: XOR<RadiationResultUpdateWithoutPatientInput, RadiationResultUncheckedUpdateWithoutPatientInput>
    create: XOR<RadiationResultCreateWithoutPatientInput, RadiationResultUncheckedCreateWithoutPatientInput>
  }

  export type RadiationResultUpdateWithWhereUniqueWithoutPatientInput = {
    where: RadiationResultWhereUniqueInput
    data: XOR<RadiationResultUpdateWithoutPatientInput, RadiationResultUncheckedUpdateWithoutPatientInput>
  }

  export type RadiationResultUpdateManyWithWhereWithoutPatientInput = {
    where: RadiationResultScalarWhereInput
    data: XOR<RadiationResultUpdateManyMutationInput, RadiationResultUncheckedUpdateManyWithoutPatientInput>
  }

  export type TestAssignmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: TestAssignmentWhereUniqueInput
    update: XOR<TestAssignmentUpdateWithoutPatientInput, TestAssignmentUncheckedUpdateWithoutPatientInput>
    create: XOR<TestAssignmentCreateWithoutPatientInput, TestAssignmentUncheckedCreateWithoutPatientInput>
  }

  export type TestAssignmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: TestAssignmentWhereUniqueInput
    data: XOR<TestAssignmentUpdateWithoutPatientInput, TestAssignmentUncheckedUpdateWithoutPatientInput>
  }

  export type TestAssignmentUpdateManyWithWhereWithoutPatientInput = {
    where: TestAssignmentScalarWhereInput
    data: XOR<TestAssignmentUpdateManyMutationInput, TestAssignmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type TestAssignmentCreateWithoutTestInput = {
    id?: string
    status?: $Enums.TestStatus
    assignedAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTestAssignmentInput
    radiationResults?: RadiationResultCreateNestedManyWithoutTestAssignmentInput
    samples?: SampleCreateNestedManyWithoutTestAssignmentInput
    assignedBy: UserCreateNestedOneWithoutTestAssignmentsInput
    patient: PatientCreateNestedOneWithoutTestAssignmentsInput
  }

  export type TestAssignmentUncheckedCreateWithoutTestInput = {
    id?: string
    patientId: string
    status?: $Enums.TestStatus
    assignedById: string
    assignedAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTestAssignmentInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutTestAssignmentInput
    samples?: SampleUncheckedCreateNestedManyWithoutTestAssignmentInput
  }

  export type TestAssignmentCreateOrConnectWithoutTestInput = {
    where: TestAssignmentWhereUniqueInput
    create: XOR<TestAssignmentCreateWithoutTestInput, TestAssignmentUncheckedCreateWithoutTestInput>
  }

  export type TestAssignmentCreateManyTestInputEnvelope = {
    data: TestAssignmentCreateManyTestInput | TestAssignmentCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type TestAssignmentUpsertWithWhereUniqueWithoutTestInput = {
    where: TestAssignmentWhereUniqueInput
    update: XOR<TestAssignmentUpdateWithoutTestInput, TestAssignmentUncheckedUpdateWithoutTestInput>
    create: XOR<TestAssignmentCreateWithoutTestInput, TestAssignmentUncheckedCreateWithoutTestInput>
  }

  export type TestAssignmentUpdateWithWhereUniqueWithoutTestInput = {
    where: TestAssignmentWhereUniqueInput
    data: XOR<TestAssignmentUpdateWithoutTestInput, TestAssignmentUncheckedUpdateWithoutTestInput>
  }

  export type TestAssignmentUpdateManyWithWhereWithoutTestInput = {
    where: TestAssignmentScalarWhereInput
    data: XOR<TestAssignmentUpdateManyMutationInput, TestAssignmentUncheckedUpdateManyWithoutTestInput>
  }

  export type InvoiceItemCreateWithoutTestAssignmentInput = {
    id?: string
    price: number
    quantity?: number
    subtotal: number
    invoice: InvoiceCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutTestAssignmentInput = {
    id?: string
    invoiceId: string
    price: number
    quantity?: number
    subtotal: number
  }

  export type InvoiceItemCreateOrConnectWithoutTestAssignmentInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutTestAssignmentInput, InvoiceItemUncheckedCreateWithoutTestAssignmentInput>
  }

  export type InvoiceItemCreateManyTestAssignmentInputEnvelope = {
    data: InvoiceItemCreateManyTestAssignmentInput | InvoiceItemCreateManyTestAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type RadiationResultCreateWithoutTestAssignmentInput = {
    id?: string
    title: string
    description?: string | null
    resultDetails: string
    reportText?: string | null
    imageUrl?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutRadiationResultsInput
    patient: PatientCreateNestedOneWithoutRadiationResultsInput
  }

  export type RadiationResultUncheckedCreateWithoutTestAssignmentInput = {
    id?: string
    title: string
    description?: string | null
    resultDetails: string
    reportText?: string | null
    imageUrl?: string | null
    pdfUrl?: string | null
    patientId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiationResultCreateOrConnectWithoutTestAssignmentInput = {
    where: RadiationResultWhereUniqueInput
    create: XOR<RadiationResultCreateWithoutTestAssignmentInput, RadiationResultUncheckedCreateWithoutTestAssignmentInput>
  }

  export type RadiationResultCreateManyTestAssignmentInputEnvelope = {
    data: RadiationResultCreateManyTestAssignmentInput | RadiationResultCreateManyTestAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type SampleCreateWithoutTestAssignmentInput = {
    id?: string
    sampleCode: string
    collectedAt?: Date | string
    notes?: string | null
    results?: string | null
    reportPdfUrl?: string | null
    collectedBy: UserCreateNestedOneWithoutSamplesInput
  }

  export type SampleUncheckedCreateWithoutTestAssignmentInput = {
    id?: string
    sampleCode: string
    collectedAt?: Date | string
    collectedById: string
    notes?: string | null
    results?: string | null
    reportPdfUrl?: string | null
  }

  export type SampleCreateOrConnectWithoutTestAssignmentInput = {
    where: SampleWhereUniqueInput
    create: XOR<SampleCreateWithoutTestAssignmentInput, SampleUncheckedCreateWithoutTestAssignmentInput>
  }

  export type SampleCreateManyTestAssignmentInputEnvelope = {
    data: SampleCreateManyTestAssignmentInput | SampleCreateManyTestAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTestAssignmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    patients?: PatientCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultCreateNestedManyWithoutCreatedByInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    samples?: SampleCreateNestedManyWithoutCollectedByInput
    materialTransactions?: MaterialTransactionCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutTestAssignmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    patients?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutCreatedByInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    samples?: SampleUncheckedCreateNestedManyWithoutCollectedByInput
    materialTransactions?: MaterialTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutTestAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestAssignmentsInput, UserUncheckedCreateWithoutTestAssignmentsInput>
  }

  export type PatientCreateWithoutTestAssignmentsInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    createdBy: UserCreateNestedOneWithoutPatientsInput
    queueNumbers?: QueueNumberCreateNestedManyWithoutPatientInput
    radiationResults?: RadiationResultCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutTestAssignmentsInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    queueNumbers?: QueueNumberUncheckedCreateNestedManyWithoutPatientInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutTestAssignmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutTestAssignmentsInput, PatientUncheckedCreateWithoutTestAssignmentsInput>
  }

  export type TestCreateWithoutTestAssignmentsInput = {
    id?: string
    name: string
    category: string
    price: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestUncheckedCreateWithoutTestAssignmentsInput = {
    id?: string
    name: string
    category: string
    price: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestCreateOrConnectWithoutTestAssignmentsInput = {
    where: TestWhereUniqueInput
    create: XOR<TestCreateWithoutTestAssignmentsInput, TestUncheckedCreateWithoutTestAssignmentsInput>
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutTestAssignmentInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutTestAssignmentInput, InvoiceItemUncheckedUpdateWithoutTestAssignmentInput>
    create: XOR<InvoiceItemCreateWithoutTestAssignmentInput, InvoiceItemUncheckedCreateWithoutTestAssignmentInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutTestAssignmentInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutTestAssignmentInput, InvoiceItemUncheckedUpdateWithoutTestAssignmentInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutTestAssignmentInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutTestAssignmentInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    testAssignmentId?: StringFilter<"InvoiceItem"> | string
    price?: FloatFilter<"InvoiceItem"> | number
    quantity?: IntFilter<"InvoiceItem"> | number
    subtotal?: FloatFilter<"InvoiceItem"> | number
  }

  export type RadiationResultUpsertWithWhereUniqueWithoutTestAssignmentInput = {
    where: RadiationResultWhereUniqueInput
    update: XOR<RadiationResultUpdateWithoutTestAssignmentInput, RadiationResultUncheckedUpdateWithoutTestAssignmentInput>
    create: XOR<RadiationResultCreateWithoutTestAssignmentInput, RadiationResultUncheckedCreateWithoutTestAssignmentInput>
  }

  export type RadiationResultUpdateWithWhereUniqueWithoutTestAssignmentInput = {
    where: RadiationResultWhereUniqueInput
    data: XOR<RadiationResultUpdateWithoutTestAssignmentInput, RadiationResultUncheckedUpdateWithoutTestAssignmentInput>
  }

  export type RadiationResultUpdateManyWithWhereWithoutTestAssignmentInput = {
    where: RadiationResultScalarWhereInput
    data: XOR<RadiationResultUpdateManyMutationInput, RadiationResultUncheckedUpdateManyWithoutTestAssignmentInput>
  }

  export type SampleUpsertWithWhereUniqueWithoutTestAssignmentInput = {
    where: SampleWhereUniqueInput
    update: XOR<SampleUpdateWithoutTestAssignmentInput, SampleUncheckedUpdateWithoutTestAssignmentInput>
    create: XOR<SampleCreateWithoutTestAssignmentInput, SampleUncheckedCreateWithoutTestAssignmentInput>
  }

  export type SampleUpdateWithWhereUniqueWithoutTestAssignmentInput = {
    where: SampleWhereUniqueInput
    data: XOR<SampleUpdateWithoutTestAssignmentInput, SampleUncheckedUpdateWithoutTestAssignmentInput>
  }

  export type SampleUpdateManyWithWhereWithoutTestAssignmentInput = {
    where: SampleScalarWhereInput
    data: XOR<SampleUpdateManyMutationInput, SampleUncheckedUpdateManyWithoutTestAssignmentInput>
  }

  export type UserUpsertWithoutTestAssignmentsInput = {
    update: XOR<UserUpdateWithoutTestAssignmentsInput, UserUncheckedUpdateWithoutTestAssignmentsInput>
    create: XOR<UserCreateWithoutTestAssignmentsInput, UserUncheckedCreateWithoutTestAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestAssignmentsInput, UserUncheckedUpdateWithoutTestAssignmentsInput>
  }

  export type UserUpdateWithoutTestAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUpdateManyWithoutCollectedByNestedInput
    materialTransactions?: MaterialTransactionUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTestAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUncheckedUpdateManyWithoutCollectedByNestedInput
    materialTransactions?: MaterialTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type PatientUpsertWithoutTestAssignmentsInput = {
    update: XOR<PatientUpdateWithoutTestAssignmentsInput, PatientUncheckedUpdateWithoutTestAssignmentsInput>
    create: XOR<PatientCreateWithoutTestAssignmentsInput, PatientUncheckedCreateWithoutTestAssignmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutTestAssignmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutTestAssignmentsInput, PatientUncheckedUpdateWithoutTestAssignmentsInput>
  }

  export type PatientUpdateWithoutTestAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPatientsNestedInput
    queueNumbers?: QueueNumberUpdateManyWithoutPatientNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutTestAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    queueNumbers?: QueueNumberUncheckedUpdateManyWithoutPatientNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type TestUpsertWithoutTestAssignmentsInput = {
    update: XOR<TestUpdateWithoutTestAssignmentsInput, TestUncheckedUpdateWithoutTestAssignmentsInput>
    create: XOR<TestCreateWithoutTestAssignmentsInput, TestUncheckedCreateWithoutTestAssignmentsInput>
    where?: TestWhereInput
  }

  export type TestUpdateToOneWithWhereWithoutTestAssignmentsInput = {
    where?: TestWhereInput
    data: XOR<TestUpdateWithoutTestAssignmentsInput, TestUncheckedUpdateWithoutTestAssignmentsInput>
  }

  export type TestUpdateWithoutTestAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestUncheckedUpdateWithoutTestAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSamplesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    patients?: PatientCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultCreateNestedManyWithoutCreatedByInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutSamplesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    patients?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutCreatedByInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutSamplesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSamplesInput, UserUncheckedCreateWithoutSamplesInput>
  }

  export type TestAssignmentCreateWithoutSamplesInput = {
    id?: string
    status?: $Enums.TestStatus
    assignedAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTestAssignmentInput
    radiationResults?: RadiationResultCreateNestedManyWithoutTestAssignmentInput
    assignedBy: UserCreateNestedOneWithoutTestAssignmentsInput
    patient: PatientCreateNestedOneWithoutTestAssignmentsInput
    test: TestCreateNestedOneWithoutTestAssignmentsInput
  }

  export type TestAssignmentUncheckedCreateWithoutSamplesInput = {
    id?: string
    patientId: string
    testId: string
    status?: $Enums.TestStatus
    assignedById: string
    assignedAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTestAssignmentInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutTestAssignmentInput
  }

  export type TestAssignmentCreateOrConnectWithoutSamplesInput = {
    where: TestAssignmentWhereUniqueInput
    create: XOR<TestAssignmentCreateWithoutSamplesInput, TestAssignmentUncheckedCreateWithoutSamplesInput>
  }

  export type UserUpsertWithoutSamplesInput = {
    update: XOR<UserUpdateWithoutSamplesInput, UserUncheckedUpdateWithoutSamplesInput>
    create: XOR<UserCreateWithoutSamplesInput, UserUncheckedCreateWithoutSamplesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSamplesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSamplesInput, UserUncheckedUpdateWithoutSamplesInput>
  }

  export type UserUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type TestAssignmentUpsertWithoutSamplesInput = {
    update: XOR<TestAssignmentUpdateWithoutSamplesInput, TestAssignmentUncheckedUpdateWithoutSamplesInput>
    create: XOR<TestAssignmentCreateWithoutSamplesInput, TestAssignmentUncheckedCreateWithoutSamplesInput>
    where?: TestAssignmentWhereInput
  }

  export type TestAssignmentUpdateToOneWithWhereWithoutSamplesInput = {
    where?: TestAssignmentWhereInput
    data: XOR<TestAssignmentUpdateWithoutSamplesInput, TestAssignmentUncheckedUpdateWithoutSamplesInput>
  }

  export type TestAssignmentUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUpdateManyWithoutTestAssignmentNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutTestAssignmentNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutTestAssignmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutTestAssignmentsNestedInput
    test?: TestUpdateOneRequiredWithoutTestAssignmentsNestedInput
  }

  export type TestAssignmentUncheckedUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTestAssignmentNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutTestAssignmentNestedInput
  }

  export type UserCreateWithoutInvoicesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    patients?: PatientCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultCreateNestedManyWithoutCreatedByInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    samples?: SampleCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    patients?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutCreatedByInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    samples?: SampleUncheckedCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type PatientCreateWithoutInvoicesInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPatientsInput
    queueNumbers?: QueueNumberCreateNestedManyWithoutPatientInput
    radiationResults?: RadiationResultCreateNestedManyWithoutPatientInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutInvoicesInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    queueNumbers?: QueueNumberUncheckedCreateNestedManyWithoutPatientInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutPatientInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutInvoicesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    price: number
    quantity?: number
    subtotal: number
    testAssignment: TestAssignmentCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    testAssignmentId: string
    price: number
    quantity?: number
    subtotal: number
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    patients?: PatientUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    patients?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUncheckedUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type PatientUpsertWithoutInvoicesInput = {
    update: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type PatientUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPatientsNestedInput
    queueNumbers?: QueueNumberUpdateManyWithoutPatientNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutPatientNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    queueNumbers?: QueueNumberUncheckedUpdateManyWithoutPatientNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutPatientNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutItemsInput = {
    id?: string
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    createdBy: UserCreateNestedOneWithoutInvoicesInput
    patient: PatientCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    patientId: string
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    createdById: string
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type TestAssignmentCreateWithoutInvoiceItemsInput = {
    id?: string
    status?: $Enums.TestStatus
    assignedAt?: Date | string
    updatedAt?: Date | string
    radiationResults?: RadiationResultCreateNestedManyWithoutTestAssignmentInput
    samples?: SampleCreateNestedManyWithoutTestAssignmentInput
    assignedBy: UserCreateNestedOneWithoutTestAssignmentsInput
    patient: PatientCreateNestedOneWithoutTestAssignmentsInput
    test: TestCreateNestedOneWithoutTestAssignmentsInput
  }

  export type TestAssignmentUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string
    patientId: string
    testId: string
    status?: $Enums.TestStatus
    assignedById: string
    assignedAt?: Date | string
    updatedAt?: Date | string
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutTestAssignmentInput
    samples?: SampleUncheckedCreateNestedManyWithoutTestAssignmentInput
  }

  export type TestAssignmentCreateOrConnectWithoutInvoiceItemsInput = {
    where: TestAssignmentWhereUniqueInput
    create: XOR<TestAssignmentCreateWithoutInvoiceItemsInput, TestAssignmentUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type TestAssignmentUpsertWithoutInvoiceItemsInput = {
    update: XOR<TestAssignmentUpdateWithoutInvoiceItemsInput, TestAssignmentUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<TestAssignmentCreateWithoutInvoiceItemsInput, TestAssignmentUncheckedCreateWithoutInvoiceItemsInput>
    where?: TestAssignmentWhereInput
  }

  export type TestAssignmentUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: TestAssignmentWhereInput
    data: XOR<TestAssignmentUpdateWithoutInvoiceItemsInput, TestAssignmentUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type TestAssignmentUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    radiationResults?: RadiationResultUpdateManyWithoutTestAssignmentNestedInput
    samples?: SampleUpdateManyWithoutTestAssignmentNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutTestAssignmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutTestAssignmentsNestedInput
    test?: TestUpdateOneRequiredWithoutTestAssignmentsNestedInput
  }

  export type TestAssignmentUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutTestAssignmentNestedInput
    samples?: SampleUncheckedUpdateManyWithoutTestAssignmentNestedInput
  }

  export type PatientCreateWithoutQueueNumbersInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    createdBy: UserCreateNestedOneWithoutPatientsInput
    radiationResults?: RadiationResultCreateNestedManyWithoutPatientInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutQueueNumbersInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutPatientInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutQueueNumbersInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutQueueNumbersInput, PatientUncheckedCreateWithoutQueueNumbersInput>
  }

  export type PatientUpsertWithoutQueueNumbersInput = {
    update: XOR<PatientUpdateWithoutQueueNumbersInput, PatientUncheckedUpdateWithoutQueueNumbersInput>
    create: XOR<PatientCreateWithoutQueueNumbersInput, PatientUncheckedCreateWithoutQueueNumbersInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutQueueNumbersInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutQueueNumbersInput, PatientUncheckedUpdateWithoutQueueNumbersInput>
  }

  export type PatientUpdateWithoutQueueNumbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPatientsNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutPatientNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutQueueNumbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutPatientNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserCreateWithoutReportsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    patients?: PatientCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultCreateNestedManyWithoutCreatedByInput
    samples?: SampleCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    patients?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutCreatedByInput
    samples?: SampleUncheckedCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUncheckedUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutPurchaseInvoicesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    patients?: PatientCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultCreateNestedManyWithoutCreatedByInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    samples?: SampleCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutPurchaseInvoicesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    patients?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutCreatedByInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    samples?: SampleUncheckedCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutPurchaseInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchaseInvoicesInput, UserUncheckedCreateWithoutPurchaseInvoicesInput>
  }

  export type PurchaseInvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    itemName: string
    description?: string | null
    quantity: number
    unitPrice: number
    subtotal: number
  }

  export type PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    itemName: string
    description?: string | null
    quantity: number
    unitPrice: number
    subtotal: number
  }

  export type PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    create: XOR<PurchaseInvoiceItemCreateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type PurchaseInvoiceItemCreateManyInvoiceInputEnvelope = {
    data: PurchaseInvoiceItemCreateManyInvoiceInput | PurchaseInvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPurchaseInvoicesInput = {
    update: XOR<UserUpdateWithoutPurchaseInvoicesInput, UserUncheckedUpdateWithoutPurchaseInvoicesInput>
    create: XOR<UserCreateWithoutPurchaseInvoicesInput, UserUncheckedCreateWithoutPurchaseInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchaseInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchaseInvoicesInput, UserUncheckedUpdateWithoutPurchaseInvoicesInput>
  }

  export type UserUpdateWithoutPurchaseInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchaseInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUncheckedUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type PurchaseInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    update: XOR<PurchaseInvoiceItemUpdateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PurchaseInvoiceItemCreateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type PurchaseInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    data: XOR<PurchaseInvoiceItemUpdateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: PurchaseInvoiceItemScalarWhereInput
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PurchaseInvoiceItemScalarWhereInput = {
    AND?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
    OR?: PurchaseInvoiceItemScalarWhereInput[]
    NOT?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
    id?: StringFilter<"PurchaseInvoiceItem"> | string
    invoiceId?: StringFilter<"PurchaseInvoiceItem"> | string
    itemName?: StringFilter<"PurchaseInvoiceItem"> | string
    description?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    quantity?: IntFilter<"PurchaseInvoiceItem"> | number
    unitPrice?: FloatFilter<"PurchaseInvoiceItem"> | number
    subtotal?: FloatFilter<"PurchaseInvoiceItem"> | number
  }

  export type PurchaseInvoiceCreateWithoutItemsInput = {
    id?: string
    supplierName: string
    invoiceNumber?: string | null
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    createdBy: UserCreateNestedOneWithoutPurchaseInvoicesInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    supplierName: string
    invoiceNumber?: string | null
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    createdById: string
  }

  export type PurchaseInvoiceCreateOrConnectWithoutItemsInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type PurchaseInvoiceUpsertWithoutItemsInput = {
    update: XOR<PurchaseInvoiceUpdateWithoutItemsInput, PurchaseInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
    where?: PurchaseInvoiceWhereInput
  }

  export type PurchaseInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseInvoiceWhereInput
    data: XOR<PurchaseInvoiceUpdateWithoutItemsInput, PurchaseInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseInvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutRadiationResultsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    patients?: PatientCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCreatedByInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    samples?: SampleCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutRadiationResultsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    patients?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    samples?: SampleUncheckedCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    labMaterials?: LabMaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutRadiationResultsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRadiationResultsInput, UserUncheckedCreateWithoutRadiationResultsInput>
  }

  export type PatientCreateWithoutRadiationResultsInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    createdBy: UserCreateNestedOneWithoutPatientsInput
    queueNumbers?: QueueNumberCreateNestedManyWithoutPatientInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutRadiationResultsInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    queueNumbers?: QueueNumberUncheckedCreateNestedManyWithoutPatientInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutRadiationResultsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutRadiationResultsInput, PatientUncheckedCreateWithoutRadiationResultsInput>
  }

  export type TestAssignmentCreateWithoutRadiationResultsInput = {
    id?: string
    status?: $Enums.TestStatus
    assignedAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTestAssignmentInput
    samples?: SampleCreateNestedManyWithoutTestAssignmentInput
    assignedBy: UserCreateNestedOneWithoutTestAssignmentsInput
    patient: PatientCreateNestedOneWithoutTestAssignmentsInput
    test: TestCreateNestedOneWithoutTestAssignmentsInput
  }

  export type TestAssignmentUncheckedCreateWithoutRadiationResultsInput = {
    id?: string
    patientId: string
    testId: string
    status?: $Enums.TestStatus
    assignedById: string
    assignedAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTestAssignmentInput
    samples?: SampleUncheckedCreateNestedManyWithoutTestAssignmentInput
  }

  export type TestAssignmentCreateOrConnectWithoutRadiationResultsInput = {
    where: TestAssignmentWhereUniqueInput
    create: XOR<TestAssignmentCreateWithoutRadiationResultsInput, TestAssignmentUncheckedCreateWithoutRadiationResultsInput>
  }

  export type UserUpsertWithoutRadiationResultsInput = {
    update: XOR<UserUpdateWithoutRadiationResultsInput, UserUncheckedUpdateWithoutRadiationResultsInput>
    create: XOR<UserCreateWithoutRadiationResultsInput, UserUncheckedCreateWithoutRadiationResultsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRadiationResultsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRadiationResultsInput, UserUncheckedUpdateWithoutRadiationResultsInput>
  }

  export type UserUpdateWithoutRadiationResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRadiationResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUncheckedUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    labMaterials?: LabMaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type PatientUpsertWithoutRadiationResultsInput = {
    update: XOR<PatientUpdateWithoutRadiationResultsInput, PatientUncheckedUpdateWithoutRadiationResultsInput>
    create: XOR<PatientCreateWithoutRadiationResultsInput, PatientUncheckedCreateWithoutRadiationResultsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutRadiationResultsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutRadiationResultsInput, PatientUncheckedUpdateWithoutRadiationResultsInput>
  }

  export type PatientUpdateWithoutRadiationResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPatientsNestedInput
    queueNumbers?: QueueNumberUpdateManyWithoutPatientNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutRadiationResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    queueNumbers?: QueueNumberUncheckedUpdateManyWithoutPatientNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type TestAssignmentUpsertWithoutRadiationResultsInput = {
    update: XOR<TestAssignmentUpdateWithoutRadiationResultsInput, TestAssignmentUncheckedUpdateWithoutRadiationResultsInput>
    create: XOR<TestAssignmentCreateWithoutRadiationResultsInput, TestAssignmentUncheckedCreateWithoutRadiationResultsInput>
    where?: TestAssignmentWhereInput
  }

  export type TestAssignmentUpdateToOneWithWhereWithoutRadiationResultsInput = {
    where?: TestAssignmentWhereInput
    data: XOR<TestAssignmentUpdateWithoutRadiationResultsInput, TestAssignmentUncheckedUpdateWithoutRadiationResultsInput>
  }

  export type TestAssignmentUpdateWithoutRadiationResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUpdateManyWithoutTestAssignmentNestedInput
    samples?: SampleUpdateManyWithoutTestAssignmentNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutTestAssignmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutTestAssignmentsNestedInput
    test?: TestUpdateOneRequiredWithoutTestAssignmentsNestedInput
  }

  export type TestAssignmentUncheckedUpdateWithoutRadiationResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTestAssignmentNestedInput
    samples?: SampleUncheckedUpdateManyWithoutTestAssignmentNestedInput
  }

  export type UserCreateWithoutLabMaterialsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    patients?: PatientCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultCreateNestedManyWithoutCreatedByInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    samples?: SampleCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutLabMaterialsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    patients?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutCreatedByInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    samples?: SampleUncheckedCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    materialTransactions?: MaterialTransactionUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutLabMaterialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLabMaterialsInput, UserUncheckedCreateWithoutLabMaterialsInput>
  }

  export type MaterialTransactionCreateWithoutMaterialInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    previousQuantity: number
    newQuantity: number
    reason?: string | null
    batchNumber?: string | null
    invoiceNumber?: string | null
    createdAt?: Date | string
    createdBy: UserCreateNestedOneWithoutMaterialTransactionsInput
  }

  export type MaterialTransactionUncheckedCreateWithoutMaterialInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    previousQuantity: number
    newQuantity: number
    reason?: string | null
    batchNumber?: string | null
    invoiceNumber?: string | null
    createdAt?: Date | string
    createdById: string
  }

  export type MaterialTransactionCreateOrConnectWithoutMaterialInput = {
    where: MaterialTransactionWhereUniqueInput
    create: XOR<MaterialTransactionCreateWithoutMaterialInput, MaterialTransactionUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialTransactionCreateManyMaterialInputEnvelope = {
    data: MaterialTransactionCreateManyMaterialInput | MaterialTransactionCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLabMaterialsInput = {
    update: XOR<UserUpdateWithoutLabMaterialsInput, UserUncheckedUpdateWithoutLabMaterialsInput>
    create: XOR<UserCreateWithoutLabMaterialsInput, UserUncheckedCreateWithoutLabMaterialsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLabMaterialsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLabMaterialsInput, UserUncheckedUpdateWithoutLabMaterialsInput>
  }

  export type UserUpdateWithoutLabMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutLabMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUncheckedUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    materialTransactions?: MaterialTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type MaterialTransactionUpsertWithWhereUniqueWithoutMaterialInput = {
    where: MaterialTransactionWhereUniqueInput
    update: XOR<MaterialTransactionUpdateWithoutMaterialInput, MaterialTransactionUncheckedUpdateWithoutMaterialInput>
    create: XOR<MaterialTransactionCreateWithoutMaterialInput, MaterialTransactionUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialTransactionUpdateWithWhereUniqueWithoutMaterialInput = {
    where: MaterialTransactionWhereUniqueInput
    data: XOR<MaterialTransactionUpdateWithoutMaterialInput, MaterialTransactionUncheckedUpdateWithoutMaterialInput>
  }

  export type MaterialTransactionUpdateManyWithWhereWithoutMaterialInput = {
    where: MaterialTransactionScalarWhereInput
    data: XOR<MaterialTransactionUpdateManyMutationInput, MaterialTransactionUncheckedUpdateManyWithoutMaterialInput>
  }

  export type LabMaterialCreateWithoutTransactionsInput = {
    id?: string
    name: string
    code?: string | null
    category: $Enums.MaterialCategory
    description?: string | null
    unit: string
    currentQuantity: number
    minimumQuantity: number
    price?: number | null
    supplier?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutLabMaterialsInput
  }

  export type LabMaterialUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    code?: string | null
    category: $Enums.MaterialCategory
    description?: string | null
    unit: string
    currentQuantity: number
    minimumQuantity: number
    price?: number | null
    supplier?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type LabMaterialCreateOrConnectWithoutTransactionsInput = {
    where: LabMaterialWhereUniqueInput
    create: XOR<LabMaterialCreateWithoutTransactionsInput, LabMaterialUncheckedCreateWithoutTransactionsInput>
  }

  export type UserCreateWithoutMaterialTransactionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    patients?: PatientCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultCreateNestedManyWithoutCreatedByInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    samples?: SampleCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentCreateNestedManyWithoutAssignedByInput
    labMaterials?: LabMaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutMaterialTransactionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    approved?: boolean
    sessionVersion?: number
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    patients?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    radiationResults?: RadiationResultUncheckedCreateNestedManyWithoutCreatedByInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    samples?: SampleUncheckedCreateNestedManyWithoutCollectedByInput
    testAssignments?: TestAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    labMaterials?: LabMaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutMaterialTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMaterialTransactionsInput, UserUncheckedCreateWithoutMaterialTransactionsInput>
  }

  export type LabMaterialUpsertWithoutTransactionsInput = {
    update: XOR<LabMaterialUpdateWithoutTransactionsInput, LabMaterialUncheckedUpdateWithoutTransactionsInput>
    create: XOR<LabMaterialCreateWithoutTransactionsInput, LabMaterialUncheckedCreateWithoutTransactionsInput>
    where?: LabMaterialWhereInput
  }

  export type LabMaterialUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: LabMaterialWhereInput
    data: XOR<LabMaterialUpdateWithoutTransactionsInput, LabMaterialUncheckedUpdateWithoutTransactionsInput>
  }

  export type LabMaterialUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: FloatFieldUpdateOperationsInput | number
    minimumQuantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutLabMaterialsNestedInput
  }

  export type LabMaterialUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: FloatFieldUpdateOperationsInput | number
    minimumQuantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutMaterialTransactionsInput = {
    update: XOR<UserUpdateWithoutMaterialTransactionsInput, UserUncheckedUpdateWithoutMaterialTransactionsInput>
    create: XOR<UserCreateWithoutMaterialTransactionsInput, UserUncheckedCreateWithoutMaterialTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMaterialTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMaterialTransactionsInput, UserUncheckedUpdateWithoutMaterialTransactionsInput>
  }

  export type UserUpdateWithoutMaterialTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutAssignedByNestedInput
    labMaterials?: LabMaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMaterialTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    sessionVersion?: IntFieldUpdateOperationsInput | number
    invoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    patients?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutCreatedByNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    samples?: SampleUncheckedUpdateManyWithoutCollectedByNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    labMaterials?: LabMaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InvoiceCreateManyCreatedByInput = {
    id?: string
    patientId: string
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
  }

  export type PatientCreateManyCreatedByInput = {
    id?: string
    fileNumber: string
    name: string
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceCreateManyCreatedByInput = {
    id?: string
    supplierName: string
    invoiceNumber?: string | null
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
  }

  export type RadiationResultCreateManyCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    resultDetails: string
    reportText?: string | null
    imageUrl?: string | null
    pdfUrl?: string | null
    patientId: string
    testAssignmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateManyCreatedByInput = {
    id?: string
    title: string
    type: $Enums.ReportType
    description?: string | null
    createdAt?: Date | string
    startDate: Date | string
    endDate: Date | string
    pdfUrl?: string | null
  }

  export type SampleCreateManyCollectedByInput = {
    id?: string
    testAssignmentId: string
    sampleCode: string
    collectedAt?: Date | string
    notes?: string | null
    results?: string | null
    reportPdfUrl?: string | null
  }

  export type TestAssignmentCreateManyAssignedByInput = {
    id?: string
    patientId: string
    testId: string
    status?: $Enums.TestStatus
    assignedAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialTransactionCreateManyCreatedByInput = {
    id?: string
    materialId: string
    type: $Enums.TransactionType
    quantity: number
    previousQuantity: number
    newQuantity: number
    reason?: string | null
    batchNumber?: string | null
    invoiceNumber?: string | null
    createdAt?: Date | string
  }

  export type LabMaterialCreateManyCreatedByInput = {
    id?: string
    name: string
    code?: string | null
    category: $Enums.MaterialCategory
    description?: string | null
    unit: string
    currentQuantity: number
    minimumQuantity: number
    price?: number | null
    supplier?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    queueNumbers?: QueueNumberUpdateManyWithoutPatientNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutPatientNestedInput
    testAssignments?: TestAssignmentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    queueNumbers?: QueueNumberUncheckedUpdateManyWithoutPatientNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutPatientNestedInput
    testAssignments?: TestAssignmentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PurchaseInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RadiationResultUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resultDetails?: StringFieldUpdateOperationsInput | string
    reportText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutRadiationResultsNestedInput
    testAssignment?: TestAssignmentUpdateOneRequiredWithoutRadiationResultsNestedInput
  }

  export type RadiationResultUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resultDetails?: StringFieldUpdateOperationsInput | string
    reportText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiationResultUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resultDetails?: StringFieldUpdateOperationsInput | string
    reportText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SampleUpdateWithoutCollectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    testAssignment?: TestAssignmentUpdateOneRequiredWithoutSamplesNestedInput
  }

  export type SampleUncheckedUpdateWithoutCollectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SampleUncheckedUpdateManyWithoutCollectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestAssignmentUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUpdateManyWithoutTestAssignmentNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutTestAssignmentNestedInput
    samples?: SampleUpdateManyWithoutTestAssignmentNestedInput
    patient?: PatientUpdateOneRequiredWithoutTestAssignmentsNestedInput
    test?: TestUpdateOneRequiredWithoutTestAssignmentsNestedInput
  }

  export type TestAssignmentUncheckedUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTestAssignmentNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutTestAssignmentNestedInput
    samples?: SampleUncheckedUpdateManyWithoutTestAssignmentNestedInput
  }

  export type TestAssignmentUncheckedUpdateManyWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialTransactionUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    previousQuantity?: FloatFieldUpdateOperationsInput | number
    newQuantity?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: LabMaterialUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type MaterialTransactionUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    previousQuantity?: FloatFieldUpdateOperationsInput | number
    newQuantity?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialTransactionUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    previousQuantity?: FloatFieldUpdateOperationsInput | number
    newQuantity?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabMaterialUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: FloatFieldUpdateOperationsInput | number
    minimumQuantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: MaterialTransactionUpdateManyWithoutMaterialNestedInput
  }

  export type LabMaterialUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: FloatFieldUpdateOperationsInput | number
    minimumQuantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: MaterialTransactionUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type LabMaterialUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMaterialCategoryFieldUpdateOperationsInput | $Enums.MaterialCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: FloatFieldUpdateOperationsInput | number
    minimumQuantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyPatientInput = {
    id?: string
    totalAmount: number
    paidAmount?: number
    isPaid?: boolean
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    createdById: string
  }

  export type QueueNumberCreateManyPatientInput = {
    id?: string
    number: number
    date?: Date | string
    status?: $Enums.QueueStatus
  }

  export type RadiationResultCreateManyPatientInput = {
    id?: string
    title: string
    description?: string | null
    resultDetails: string
    reportText?: string | null
    imageUrl?: string | null
    pdfUrl?: string | null
    testAssignmentId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestAssignmentCreateManyPatientInput = {
    id?: string
    testId: string
    status?: $Enums.TestStatus
    assignedById: string
    assignedAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type QueueNumberUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
  }

  export type QueueNumberUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
  }

  export type QueueNumberUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
  }

  export type RadiationResultUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resultDetails?: StringFieldUpdateOperationsInput | string
    reportText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutRadiationResultsNestedInput
    testAssignment?: TestAssignmentUpdateOneRequiredWithoutRadiationResultsNestedInput
  }

  export type RadiationResultUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resultDetails?: StringFieldUpdateOperationsInput | string
    reportText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiationResultUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resultDetails?: StringFieldUpdateOperationsInput | string
    reportText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestAssignmentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUpdateManyWithoutTestAssignmentNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutTestAssignmentNestedInput
    samples?: SampleUpdateManyWithoutTestAssignmentNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutTestAssignmentsNestedInput
    test?: TestUpdateOneRequiredWithoutTestAssignmentsNestedInput
  }

  export type TestAssignmentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTestAssignmentNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutTestAssignmentNestedInput
    samples?: SampleUncheckedUpdateManyWithoutTestAssignmentNestedInput
  }

  export type TestAssignmentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestAssignmentCreateManyTestInput = {
    id?: string
    patientId: string
    status?: $Enums.TestStatus
    assignedById: string
    assignedAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestAssignmentUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUpdateManyWithoutTestAssignmentNestedInput
    radiationResults?: RadiationResultUpdateManyWithoutTestAssignmentNestedInput
    samples?: SampleUpdateManyWithoutTestAssignmentNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutTestAssignmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutTestAssignmentsNestedInput
  }

  export type TestAssignmentUncheckedUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTestAssignmentNestedInput
    radiationResults?: RadiationResultUncheckedUpdateManyWithoutTestAssignmentNestedInput
    samples?: SampleUncheckedUpdateManyWithoutTestAssignmentNestedInput
  }

  export type TestAssignmentUncheckedUpdateManyWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumTestStatusFieldUpdateOperationsInput | $Enums.TestStatus
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyTestAssignmentInput = {
    id?: string
    invoiceId: string
    price: number
    quantity?: number
    subtotal: number
  }

  export type RadiationResultCreateManyTestAssignmentInput = {
    id?: string
    title: string
    description?: string | null
    resultDetails: string
    reportText?: string | null
    imageUrl?: string | null
    pdfUrl?: string | null
    patientId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SampleCreateManyTestAssignmentInput = {
    id?: string
    sampleCode: string
    collectedAt?: Date | string
    collectedById: string
    notes?: string | null
    results?: string | null
    reportPdfUrl?: string | null
  }

  export type InvoiceItemUpdateWithoutTestAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutTestAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyWithoutTestAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
  }

  export type RadiationResultUpdateWithoutTestAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resultDetails?: StringFieldUpdateOperationsInput | string
    reportText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutRadiationResultsNestedInput
    patient?: PatientUpdateOneRequiredWithoutRadiationResultsNestedInput
  }

  export type RadiationResultUncheckedUpdateWithoutTestAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resultDetails?: StringFieldUpdateOperationsInput | string
    reportText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiationResultUncheckedUpdateManyWithoutTestAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resultDetails?: StringFieldUpdateOperationsInput | string
    reportText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleUpdateWithoutTestAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: UserUpdateOneRequiredWithoutSamplesNestedInput
  }

  export type SampleUncheckedUpdateWithoutTestAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SampleUncheckedUpdateManyWithoutTestAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectedById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    testAssignmentId: string
    price: number
    quantity?: number
    subtotal: number
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    testAssignment?: TestAssignmentUpdateOneRequiredWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    testAssignmentId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseInvoiceItemCreateManyInvoiceInput = {
    id?: string
    itemName: string
    description?: string | null
    quantity: number
    unitPrice: number
    subtotal: number
  }

  export type PurchaseInvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseInvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
  }

  export type MaterialTransactionCreateManyMaterialInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    previousQuantity: number
    newQuantity: number
    reason?: string | null
    batchNumber?: string | null
    invoiceNumber?: string | null
    createdAt?: Date | string
    createdById: string
  }

  export type MaterialTransactionUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    previousQuantity?: FloatFieldUpdateOperationsInput | number
    newQuantity?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutMaterialTransactionsNestedInput
  }

  export type MaterialTransactionUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    previousQuantity?: FloatFieldUpdateOperationsInput | number
    newQuantity?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialTransactionUncheckedUpdateManyWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    previousQuantity?: FloatFieldUpdateOperationsInput | number
    newQuantity?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}